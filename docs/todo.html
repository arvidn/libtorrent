<html><head>
<script type="text/javascript">
/* <![CDATA[ */
	var expanded = -1
	function expand(id) {
		if (expanded != -1) {
			var ctx = document.getElementById(expanded);
			ctx.style.display = "none";
			// if we're expanding the field that's already
			// expanded, just collapse it
			var no_expand = id == expanded;
			expanded = -1;
			if (no_expand) return;
		}
		var ctx = document.getElementById(id);
		ctx.style.display = "table-row";
		expanded = id;
	}
/* ]]> */
</script>

</head><body>
<h1>libtorrent todo-list</h1>
<span style="color: #f77">2 important</span>
<span style="color: #3c3">6 relevant</span>
<span style="color: #77f">13 feasible</span>
<span style="color: #999">46 notes</span>
<table width="100%" border="1" style="border-collapse: collapse;"><tr style="background: #fdd"><td>relevance&nbsp;4</td><td><a href="javascript:expand(0)">../src/session_impl.cpp:664</a></td><td>in order to support SSL over uTP, the utp_socket manager either needs to be able to receive packets on multiple ports, or we need to peek into the first few bytes the payload stream of a socket to determine whether or not it's an SSL connection. (The former is simpler but won't do as well with NATs)</td></tr><tr id="0" style="display: none;" colspan="3"><td colspan="3"><h2>in order to support SSL over uTP, the utp_socket manager either
needs to be able to receive packets on multiple ports, or we need to
peek into the first few bytes the payload stream of a socket to determine
whether or not it's an SSL connection. (The former is simpler but won't
do as well with NATs)</h2><h4>../src/session_impl.cpp:664</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		, m_optimistic_unchoke_time_scaler(0)
		, m_disconnect_time_scaler(90)
		, m_auto_scrape_time_scaler(180)
		, m_next_explicit_cache_torrent(0)
		, m_cache_rotation_timer(0)
		, m_peak_up_rate(0)
		, m_peak_down_rate(0)
		, m_created(time_now_hires())
		, m_last_tick(m_created)
		, m_last_second_tick(m_created - milliseconds(900))
		, m_last_disk_performance_warning(min_time())
		, m_last_disk_queue_performance_warning(min_time())
		, m_last_choke(m_created)
		, m_next_rss_update(min_time())
#ifndef TORRENT_DISABLE_DHT
		, m_dht_announce_timer(m_io_service)
		, m_dht_interval_update_torrents(0)
#endif
		, m_external_udp_port(0)
		, m_udp_socket(m_io_service, m_half_open)
<div style="background: #ffff00" width="100%">		, m_utp_socket_manager(m_settings, m_udp_socket
</div>			, boost::bind(&amp;session_impl::incoming_connection, this, _1))
		, m_boost_connections(0)
		, m_timer(m_io_service)
		, m_lsd_announce_timer(m_io_service)
		, m_host_resolver(m_io_service)
		, m_current_connect_attempts(0)
		, m_tick_residual(0)
		, m_non_filtered_torrents(0)
#if defined TORRENT_VERBOSE_LOGGING || defined TORRENT_LOGGING || defined TORRENT_ERROR_LOGGING
		, m_logpath(".")
#endif
#ifndef TORRENT_DISABLE_GEO_IP
		, m_asnum_db(0)
		, m_country_db(0)
#endif
		, m_total_failed_bytes(0)
		, m_total_redundant_bytes(0)
		, m_pending_auto_manage(false)
		, m_need_auto_manage(false)
		, m_abort(false)
		, m_paused(false)
		, m_incoming_connection(false)
#if TORRENT_USE_ASSERTS &amp;&amp; defined BOOST_HAS_PTHREADS
		, m_network_thread(0)
#endif
	{
#if TORRENT_USE_ASSERTS
		m_posting_torrent_updates = false;
#endif

</pre></td></tr><tr style="background: #fdd"><td>relevance&nbsp;4</td><td><a href="javascript:expand(1)">../src/settings.cpp:43</a></td><td>eliminate all use of this mechanism</td></tr><tr id="1" style="display: none;" colspan="3"><td colspan="3"><h2>eliminate all use of this mechanism</h2><h4>../src/settings.cpp:43</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

*/

#include "libtorrent/settings.hpp"
#include "libtorrent/lazy_entry.hpp"
#include "libtorrent/entry.hpp"
#include "libtorrent/assert.hpp"

#include &lt;string&gt;

namespace libtorrent
{

<div style="background: #ffff00" width="100%">	void load_struct(lazy_entry const&amp; e, void* s, bencode_map_entry const* m, int num)
</div>	{
		for (int i = 0; i &lt; num; ++i)
		{
			lazy_entry const* key = e.dict_find(m[i].name);
			if (key == 0) continue;
			void* dest = ((char*)s) + m[i].offset;
			switch (m[i].type)
			{
				case std_string:
				{
					if (key-&gt;type() != lazy_entry::string_t) continue;
					*((std::string*)dest) = key-&gt;string_value();
					break;
				}
				case character:
				case integer16:
				case boolean:
				case integer:
				case size_integer:
				case time_integer:
				case floating_point:
				{
					if (key-&gt;type() != lazy_entry::int_t) continue;
					size_type val = key-&gt;int_value();
					switch (m[i].type)
					{
						case character: *((char*)dest) = char(val); break;
						case integer16: *((boost::uint16_t*)dest) = boost::uint16_t(val); break;
						case integer: *((int*)dest) = int(val); break;
						case size_integer: *((size_type*)dest) = size_type(val); break;
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(2)">../src/torrent.cpp:6244</a></td><td>if peer is a really good peer, maybe we shouldn't disconnect it</td></tr><tr id="2" style="display: none;" colspan="3"><td colspan="3"><h2>if peer is a really good peer, maybe we shouldn't disconnect it</h2><h4>../src/torrent.cpp:6244</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			return false;
		}
		TORRENT_ASSERT(m_connections.find(p) == m_connections.end());
		m_connections.insert(p);
#ifdef TORRENT_DEBUG
		error_code ec;
		TORRENT_ASSERT(p-&gt;remote() == p-&gt;get_socket()-&gt;remote_endpoint(ec) || ec);
#endif

		TORRENT_ASSERT(p-&gt;peer_info_struct() != NULL);

		// we need to do this after we've added the peer to the policy
		// since that's when the peer is assigned its peer_info object,
		// which holds the rank
		if (maybe_replace_peer)
		{
			// now, find the lowest rank peer and disconnect that
			// if it's lower rank than the incoming connection
			peer_connection* peer = find_lowest_ranking_peer();

<div style="background: #ffff00" width="100%">			if (peer &amp;&amp; peer-&gt;peer_rank() &lt; p-&gt;peer_rank())
</div>			{
				peer-&gt;disconnect(errors::too_many_connections);
				p-&gt;peer_disconnected_other();
			}
			else
			{
				p-&gt;disconnect(errors::too_many_connections);
				// we have to do this here because from the peer's point of
				// it wasn't really attached to the torrent, but we do need
				// to let policy know we're removing it
				remove_peer(p);
				return false;
			}
		}

#if TORRENT_USE_INVARIANT_CHECKS
		m_policy.check_invariant();
#endif

		if (m_share_mode)
			recalc_share_mode();

		return true;
	}

	bool torrent::want_more_peers() const
	{
		return m_connections.size() &lt; m_max_connections
			&amp;&amp; !is_paused()
			&amp;&amp; ((m_state != torrent_status::checking_files
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(3)">../src/web_peer_connection.cpp:580</a></td><td>just make this peer not have the pieces associated with the file we just requested. Only when it doesn't have any of the file do the following</td></tr><tr id="3" style="display: none;" colspan="3"><td colspan="3"><h2>just make this peer not have the pieces
associated with the file we just requested. Only
when it doesn't have any of the file do the following</h2><h4>../src/web_peer_connection.cpp:580</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			{
				++m_num_responses;

				if (m_parser.connection_close())
				{
					incoming_choke();
					if (m_num_responses == 1)
						m_web.supports_keepalive = false;
				}

#ifdef TORRENT_VERBOSE_LOGGING
				peer_log("*** STATUS: %d %s", m_parser.status_code(), m_parser.message().c_str());
				std::multimap&lt;std::string, std::string&gt; const&amp; headers = m_parser.headers();
				for (std::multimap&lt;std::string, std::string&gt;::const_iterator i = headers.begin()
					, end(headers.end()); i != end; ++i)
					peer_log("   %s: %s", i-&gt;first.c_str(), i-&gt;second.c_str());
#endif
				// if the status code is not one of the accepted ones, abort
				if (!is_ok_status(m_parser.status_code()))
				{
<div style="background: #ffff00" width="100%">					int retry_time = atoi(m_parser.header("retry-after").c_str());
</div>					if (retry_time &lt;= 0) retry_time = m_ses.settings().urlseed_wait_retry;
					// temporarily unavailable, retry later
					t-&gt;retry_web_seed(this, retry_time);
					std::string error_msg = to_string(m_parser.status_code()).elems
						+ (" " + m_parser.message());
					if (m_ses.m_alerts.should_post&lt;url_seed_alert&gt;())
					{
						m_ses.m_alerts.post_alert(url_seed_alert(t-&gt;get_handle(), m_url
							, error_msg));
					}
					m_statistics.received_bytes(0, bytes_transferred);
					disconnect(error_code(m_parser.status_code(), get_http_category()), 1);
#ifdef TORRENT_DEBUG
					TORRENT_ASSERT(m_statistics.last_payload_downloaded()
						+ m_statistics.last_protocol_downloaded()
						== dl_target);
#endif
					return;
				}
				if (is_redirect(m_parser.status_code()))
				{
					// this means we got a redirection request
					// look for the location header
					std::string location = m_parser.header("location");
					m_statistics.received_bytes(0, bytes_transferred);

					if (location.empty())
					{
						// we should not try this server again.
						t-&gt;remove_web_seed(this);
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(4)">../src/gzip.cpp:132</a></td><td>it would be nice to use proper error handling here</td></tr><tr id="4" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to use proper error handling here</h2><h4>../src/gzip.cpp:132</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				--size;
				++buffer;
			}
			if (!size || *buffer) return -1;

			--size;
			++buffer;
		}

		if (flags &amp; FHCRC)
		{
			if (size &lt; 2) return -1;

			size -= 2;
//			buffer += 2;
		}

		return total_size - size;
	}

<div style="background: #ffff00" width="100%">	TORRENT_EXTRA_EXPORT bool inflate_gzip(
</div>		char const* in
		, int size
		, std::vector&lt;char&gt;&amp; buffer
		, int maximum_size
		, std::string&amp; error)
	{
		TORRENT_ASSERT(maximum_size &gt; 0);

		int header_len = gzip_header(in, size);
		if (header_len &lt; 0)
		{
			error = "invalid gzip header";
			return true;
		}

		// start off with 4 kilobytes and grow
		// if needed
		boost::uint32_t destlen = 4096;
		int ret = 0;
		boost::uint32_t srclen = size - header_len;
		in += header_len;

		do
		{
			TORRENT_TRY {
				buffer.resize(destlen);
			} TORRENT_CATCH(std::exception&amp; e) {
				error = "out of memory: ";
				error += e.what();
				return true;
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(5)">../src/policy.cpp:153</a></td><td>this could be optimized if SSE 4.2 is available. It could also be optimized given that we have a fixed length</td></tr><tr id="5" style="display: none;" colspan="3"><td colspan="3"><h2>this could be optimized if SSE 4.2 is
available. It could also be optimized given
that we have a fixed length</h2><h4>../src/policy.cpp:153</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// 4. if IPs are not in the same /16, mask the IPs by 0xffff5555, hash them
	//    ordered, lowest first.
	//
	// * for IPv6 peers, just use the first 64 bits and widen the masks.
	//   like this: 0xffff5555 -&gt; 0xffffffff55555555
	//   the lower 64 bits are always unmasked
	//
	// * for IPv6 addresses, compare /32 and /48 instead of /16 and /24
	// 
	// * the two IP addresses that are used to calculate the rank must
	//   always be of the same address family
	//
	// * all IP addresses are in network byte order when hashed
	boost::uint32_t peer_priority(tcp::endpoint e1, tcp::endpoint e2)
	{
		TORRENT_ASSERT(e1.address().is_v4() == e2.address().is_v4());

		using std::swap;

		// this is the crc32c (Castagnoli) polynomial
<div style="background: #ffff00" width="100%">		boost::crc_optimal&lt;32, 0x1EDC6F41, 0xFFFFFFFF, 0xFFFFFFFF, true, true&gt; crc;
</div>
		if (e1.address() == e2.address())
		{
			if (e1.port() &gt; e2.port())
				swap(e1, e2);
			boost::uint16_t p[2];
			p[0] = htons(e1.port());
			p[1] = htons(e2.port());
			crc.process_bytes((char const*)&amp;p[0], 4);
		}
#if TORRENT_USE_IPV6
		else if (e1.address().is_v6())
		{
			const static boost::uint8_t v6mask[][8] = {
				{ 0xff, 0xff, 0xff, 0xff, 0x55, 0x55, 0x55, 0x55 },
				{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x55, 0x55 },
				{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }
			};

			if (e2 &lt; e1) swap(e1, e2);
			address_v6::bytes_type b1 = e1.address().to_v6().to_bytes();
			address_v6::bytes_type b2 = e2.address().to_v6().to_bytes();
			int mask = memcmp(&amp;b1[0], &amp;b2[0], 4) ? 0
				: memcmp(&amp;b1[0], &amp;b2[0], 6) ? 1 : 2;
			apply_mask(&amp;b1[0], v6mask[mask], 8);
			apply_mask(&amp;b2[0], v6mask[mask], 8);

			crc.process_bytes((char const*)&amp;b1[0], 16);
			crc.process_bytes((char const*)&amp;b2[0], 16);
		}
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(6)">../src/torrent.cpp:634</a></td><td>post alert</td></tr><tr id="6" style="display: none;" colspan="3"><td colspan="3"><h2>post alert</h2><h4>../src/torrent.cpp:634</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		state_updated();

		set_state(torrent_status::downloading);

		m_override_resume_data = true;
		init();
	}

#endif // if 0

	void torrent::leave_seed_mode(bool seed)
	{
		if (!m_seed_mode) return;

		if (!seed)
		{
			// this means the user promised we had all the
			// files, but it turned out we didn't. This is
			// an error.

<div style="background: #ffff00" width="100%">		
</div>#if defined TORRENT_ERROR_LOGGING
			debug_log("*** FAILED SEED MODE, rechecking");
#endif
		}

#if defined TORRENT_VERBOSE_LOGGING || defined TORRENT_LOGGING
		debug_log("*** LEAVING SEED MODE (%s)", seed ? "as seed" : "as non-seed");
#endif
		m_seed_mode = false;
		// seed is false if we turned out not
		// to be a seed after all
		if (!seed)
		{
			set_state(torrent_status::downloading);
			force_recheck();
		}
		m_num_verified = 0;
		m_verified.clear();
	}

	void torrent::verified(int piece)
	{
		TORRENT_ASSERT(piece &lt; int(m_verified.size()));
		TORRENT_ASSERT(piece &gt;= 0);
		TORRENT_ASSERT(m_verified.get_bit(piece) == false);
		++m_num_verified;
		m_verified.set_bit(piece);
	}

	void torrent::start()
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(7)">../src/web_peer_connection.cpp:633</a></td><td>create a mapping of file-index to redirection URLs. Use that to form URLs instead. Support to reconnect to a new server without destructing this peer_connection</td></tr><tr id="7" style="display: none;" colspan="3"><td colspan="3"><h2>create a mapping of file-index to redirection URLs. Use that to form
URLs instead. Support to reconnect to a new server without destructing this
peer_connection</h2><h4>../src/web_peer_connection.cpp:633</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">						t-&gt;remove_web_seed(this);
						disconnect(errors::missing_location, 2);
#ifdef TORRENT_DEBUG
						TORRENT_ASSERT(m_statistics.last_payload_downloaded()
							+ m_statistics.last_protocol_downloaded()
							== dl_target);
#endif
						return;
					}
					
					bool single_file_request = false;
					if (!m_path.empty() &amp;&amp; m_path[m_path.size() - 1] != '/')
						single_file_request = true;

					// add the redirected url and remove the current one
					if (!single_file_request)
					{
						TORRENT_ASSERT(!m_file_requests.empty());
						int file_index = m_file_requests.front();

<div style="background: #ffff00" width="100%">						torrent_info const&amp; info = t-&gt;torrent_file();
</div>						std::string path = info.orig_files().file_path(file_index);
#ifdef TORRENT_WINDOWS
						convert_path_to_posix(path);
#endif
						path = escape_path(path.c_str(), path.length());
						size_t i = location.rfind(path);
						if (i == std::string::npos)
						{
							t-&gt;remove_web_seed(this);
							disconnect(errors::invalid_redirection, 2);
#ifdef TORRENT_DEBUG
							TORRENT_ASSERT(m_statistics.last_payload_downloaded()
								+ m_statistics.last_protocol_downloaded()
								== dl_target);
#endif
							return;
						}
						location.resize(i);
					}
					t-&gt;add_web_seed(location, web_seed_entry::url_seed, m_external_auth, m_extra_headers);
					t-&gt;remove_web_seed(this);
					disconnect(errors::redirecting, 2);
#ifdef TORRENT_DEBUG
					TORRENT_ASSERT(m_statistics.last_payload_downloaded()
						+ m_statistics.last_protocol_downloaded()
						== dl_target);
#endif
					return;
				}

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(8)">../src/kademlia/node.cpp:66</a></td><td>make this configurable in dht_settings</td></tr><tr id="8" style="display: none;" colspan="3"><td colspan="3"><h2>make this configurable in dht_settings</h2><h4>../src/kademlia/node.cpp:66</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include "libtorrent/kademlia/rpc_manager.hpp"
#include "libtorrent/kademlia/routing_table.hpp"
#include "libtorrent/kademlia/node.hpp"
#include "libtorrent/kademlia/dht_observer.hpp"

#include "libtorrent/kademlia/refresh.hpp"
#include "libtorrent/kademlia/get_peers.hpp"
#include "libtorrent/kademlia/get_item.hpp"

#ifdef TORRENT_USE_VALGRIND
#include &lt;valgrind/memcheck.h&gt;
#endif

namespace libtorrent { namespace dht
{

void incoming_error(entry&amp; e, char const* msg, int error_code = 203);

using detail::write_endpoint;

<div style="background: #ffff00" width="100%">enum { announce_interval = 30 };
</div>
#ifdef TORRENT_DHT_VERBOSE_LOGGING
TORRENT_DEFINE_LOG(node)

extern int g_failed_announces;
extern int g_announces;

#endif

// remove peers that have timed out
void purge_peers(std::set&lt;peer_entry&gt;&amp; peers)
{
	for (std::set&lt;peer_entry&gt;::iterator i = peers.begin()
		  , end(peers.end()); i != end;)
	{
		// the peer has timed out
		if (i-&gt;added + minutes(int(announce_interval * 1.5f)) &lt; time_now())
		{
#ifdef TORRENT_DHT_VERBOSE_LOGGING
			TORRENT_LOG(node) &lt;&lt; "peer timed out at: " &lt;&lt; i-&gt;addr;
#endif
			peers.erase(i++);
		}
		else
			++i;
	}
}

void nop() {}

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(9)">../src/kademlia/node_id.cpp:135</a></td><td>this could be optimized if SSE 4.2 is available. It could also be optimized given that we have a fixed length</td></tr><tr id="9" style="display: none;" colspan="3"><td colspan="3"><h2>this could be optimized if SSE 4.2 is
available. It could also be optimized given
that we have a fixed length</h2><h4>../src/kademlia/node_id.cpp:135</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		b6 = ip_.to_v6().to_bytes();
		ip = &amp;b6[0];
		num_octets = 8;
		mask = v6mask;
	}
	else
#endif
	{
		b4 = ip_.to_v4().to_bytes();
		ip = &amp;b4[0];
		num_octets = 4;
		mask = v4mask;
	}

	for (int i = 0; i &lt; num_octets; ++i)
		ip[i] &amp;= mask[i];

	ip[0] |= (r &amp; 0x7) &lt;&lt; 5;

	// this is the crc32c (Castagnoli) polynomial
<div style="background: #ffff00" width="100%">	boost::crc_optimal&lt;32, 0x1EDC6F41, 0xFFFFFFFF, 0xFFFFFFFF, true, true&gt; crc;
</div>	crc.process_block(ip, ip + num_octets);
	boost::uint32_t c = crc.checksum();
	node_id id;

	id[0] = (c &gt;&gt; 24) &amp; 0xff;
	id[1] = (c &gt;&gt; 16) &amp; 0xff;
	id[2] = ((c &gt;&gt; 8) &amp; 0xf8) | (random() &amp; 0x7);

	for (int i = 3; i &lt; 19; ++i) id[i] = random() &amp; 0xff;
	id[19] = r &amp; 0xff;

	return id;
}

node_id generate_random_id()
{
	char r[20];
	for (int i = 0; i &lt; 20; ++i) r[i] = random() &amp; 0xff;
	return hasher(r, 20).final();
}

// verifies whether a node-id matches the IP it's used from
// returns true if the node-id is OK coming from this source
// and false otherwise.
bool verify_id(node_id const&amp; nid, address const&amp; source_ip)
{
	// no need to verify local IPs, they would be incorrect anyway
	if (is_local(source_ip)) return true;

	node_id h = generate_id_impl(source_ip, nid[19]);
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(10)">../src/http_seed_connection.cpp:115</a></td><td>in chunked encoding mode, this assert won't hold. the chunk headers should be subtracted from the receive_buffer_size</td></tr><tr id="10" style="display: none;" colspan="3"><td colspan="3"><h2>in chunked encoding mode, this assert won't hold.
the chunk headers should be subtracted from the receive_buffer_size</h2><h4>../src/http_seed_connection.cpp:115</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	boost::optional&lt;piece_block_progress&gt;
	http_seed_connection::downloading_piece_progress() const
	{
		if (m_requests.empty())
			return boost::optional&lt;piece_block_progress&gt;();

		boost::shared_ptr&lt;torrent&gt; t = associated_torrent().lock();
		TORRENT_ASSERT(t);

		piece_block_progress ret;

		peer_request const&amp; pr = m_requests.front();
		ret.piece_index = pr.piece;
		if (!m_parser.header_finished())
		{
			ret.bytes_downloaded = 0;
		}
		else
		{
			int receive_buffer_size = receive_buffer().left() - m_parser.body_start();
<div style="background: #ffff00" width="100%">			TORRENT_ASSERT_VAL(receive_buffer_size &lt;= t-&gt;block_size(), receive_buffer_size);
</div>			ret.bytes_downloaded = t-&gt;block_size() - receive_buffer_size;
		}
		// this is used to make sure that the block_index stays within
		// bounds. If the entire piece is downloaded, the block_index
		// would otherwise point to one past the end
		int correction = ret.bytes_downloaded ? -1 : 0;
		ret.block_index = (pr.start + ret.bytes_downloaded + correction) / t-&gt;block_size();
		ret.full_block_bytes = t-&gt;block_size();
		const int last_piece = t-&gt;torrent_file().num_pieces() - 1;
		if (ret.piece_index == last_piece &amp;&amp; ret.block_index
			== t-&gt;torrent_file().piece_size(last_piece) / t-&gt;block_size())
			ret.full_block_bytes = t-&gt;torrent_file().piece_size(last_piece) % t-&gt;block_size();
		return ret;
	}

	void http_seed_connection::write_request(peer_request const&amp; r)
	{
		INVARIANT_CHECK;

		boost::shared_ptr&lt;torrent&gt; t = associated_torrent().lock();
		TORRENT_ASSERT(t);

		TORRENT_ASSERT(t-&gt;valid_metadata());
		// http_seeds don't support requesting more than one piece
		// at a time
		TORRENT_ASSERT(r.length &lt;= t-&gt;torrent_file().piece_size(r.piece));

		std::string request;
		request.reserve(400);

</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(11)">../src/peer_connection.cpp:2587</a></td><td>peers should really be corked/uncorked outside of all completed disk operations</td></tr><tr id="11" style="display: none;" colspan="3"><td colspan="3"><h2>peers should really be corked/uncorked outside of
all completed disk operations</h2><h4>../src/peer_connection.cpp:2587</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		}

		if (is_disconnecting()) return;

#ifdef TORRENT_STATS
		++m_ses.m_incoming_piece_picks;
#endif
		request_a_block(*t, *this);
		send_block_requests();
	}

	void peer_connection::on_disk_write_complete(int ret, disk_io_job const&amp; j
		, peer_request p, boost::shared_ptr&lt;torrent&gt; t)
	{
#ifdef TORRENT_STATS
		++m_ses.m_num_messages[aux::session_impl::on_disk_write_counter];
#endif
		TORRENT_ASSERT(m_ses.is_network_thread());

		// flush send buffer at the end of this scope
<div style="background: #ffff00" width="100%">		cork _c(*this);
</div>
		INVARIANT_CHECK;

		m_outstanding_writing_bytes -= p.length;
		TORRENT_ASSERT(m_outstanding_writing_bytes &gt;= 0);

#if defined(TORRENT_VERBOSE_LOGGING) || defined(TORRENT_LOGGING)
//		(*m_ses.m_logger) &lt;&lt; time_now_string() &lt;&lt; " *** DISK_WRITE_COMPLETE [ p: "
//			&lt;&lt; p.piece &lt;&lt; " o: " &lt;&lt; p.start &lt;&lt; " ]\n";
#endif

		if (!t)
		{
			disconnect(j.error);
			return;
		}

		// in case the outstanding bytes just dropped down
		// to allow to receive more data
		setup_receive(read_async);

		piece_block block_finished(p.piece, p.start / t-&gt;block_size());

		if (ret == -1)
		{
			// handle_disk_error may disconnect us
			t-&gt;handle_disk_error(j, this);
			return;
		}

</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(12)">../src/session_impl.cpp:5550</a></td><td>report the proper address of the router as the source IP of this understanding of our external address, instead of the empty address</td></tr><tr id="12" style="display: none;" colspan="3"><td colspan="3"><h2>report the proper address of the router as the source IP of
this understanding of our external address, instead of the empty address</h2><h4>../src/session_impl.cpp:5550</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	void session_impl::on_port_mapping(int mapping, address const&amp; ip, int port
		, error_code const&amp; ec, int map_transport)
	{
		TORRENT_ASSERT(is_network_thread());

		TORRENT_ASSERT(map_transport &gt;= 0 &amp;&amp; map_transport &lt;= 1);

		if (mapping == m_udp_mapping[map_transport] &amp;&amp; port != 0)
		{
			m_external_udp_port = port;
			if (m_alerts.should_post&lt;portmap_alert&gt;())
				m_alerts.post_alert(portmap_alert(mapping, port
					, map_transport));
			return;
		}

		if (mapping == m_tcp_mapping[map_transport] &amp;&amp; port != 0)
		{
			if (ip != address())
			{
<div style="background: #ffff00" width="100%">				set_external_address(ip, source_router, address());
</div>			}

			if (!m_listen_sockets.empty()) {
				m_listen_sockets.front().external_address = ip;
				m_listen_sockets.front().external_port = port;
			}
			if (m_alerts.should_post&lt;portmap_alert&gt;())
				m_alerts.post_alert(portmap_alert(mapping, port
					, map_transport));
			return;
		}

		if (ec)
		{
			if (m_alerts.should_post&lt;portmap_error_alert&gt;())
				m_alerts.post_alert(portmap_error_alert(mapping
					, map_transport, ec));
		}
		else
		{
			if (m_alerts.should_post&lt;portmap_alert&gt;())
				m_alerts.post_alert(portmap_alert(mapping, port
					, map_transport));
		}
	}

	session_status session_impl::status() const
	{
//		INVARIANT_CHECK;
		TORRENT_ASSERT(is_network_thread());
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(13)">../src/session_impl.cpp:6339</a></td><td>we only need to do this if our global IPv4 address has changed since the DHT (currently) only supports IPv4. Since restarting the DHT is kind of expensive, it would be nice to not do it unnecessarily</td></tr><tr id="13" style="display: none;" colspan="3"><td colspan="3"><h2>we only need to do this if our global IPv4 address has changed
since the DHT (currently) only supports IPv4. Since restarting the DHT
is kind of expensive, it would be nice to not do it unnecessarily</h2><h4>../src/session_impl.cpp:6339</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#endif

		if (!m_external_ip.cast_vote(ip, source_type, source)) return;

#if defined TORRENT_VERBOSE_LOGGING
		session_log("  external IP updated");
#endif

		if (m_alerts.should_post&lt;external_ip_alert&gt;())
			m_alerts.post_alert(external_ip_alert(ip));

		for (torrent_map::iterator i = m_torrents.begin()
			, end(m_torrents.end()); i != end; ++i)
		{
			i-&gt;second-&gt;new_external_ip();
		}

		// since we have a new external IP now, we need to
		// restart the DHT with a new node ID
#ifndef TORRENT_DISABLE_DHT
<div style="background: #ffff00" width="100%">		if (m_dht)
</div>		{
			entry s = m_dht-&gt;state();
			int cur_state = 0;
			int prev_state = 0;
			entry* nodes1 = s.find_key("nodes");
			if (nodes1 &amp;&amp; nodes1-&gt;type() == entry::list_t) cur_state = nodes1-&gt;list().size();
			entry* nodes2 = m_dht_state.find_key("nodes");
			if (nodes2 &amp;&amp; nodes2-&gt;type() == entry::list_t) prev_state = nodes2-&gt;list().size();
			if (cur_state &gt; prev_state) m_dht_state = s;
			start_dht(m_dht_state);
		}
#endif
	}

	void session_impl::free_disk_buffer(char* buf)
	{
		m_disk_thread.free_buffer(buf);
	}

	char* session_impl::allocate_disk_buffer(char const* category)
	{
		return m_disk_thread.allocate_buffer(category);
	}
	
	char* session_impl::allocate_buffer()
	{
		TORRENT_ASSERT(is_network_thread());

#ifdef TORRENT_DISK_STATS
		TORRENT_ASSERT(m_buffer_allocations &gt;= 0);
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(14)">../src/torrent.cpp:1031</a></td><td>make this depend on the error and on the filesystem the files are being downloaded to. If the error is no_space_left_on_device and the filesystem doesn't support sparse files, only zero the priorities of the pieces that are at the tails of all files, leaving everything up to the highest written piece in each file</td></tr><tr id="14" style="display: none;" colspan="3"><td colspan="3"><h2>make this depend on the error and on the filesystem the
files are being downloaded to. If the error is no_space_left_on_device
and the filesystem doesn't support sparse files, only zero the priorities
of the pieces that are at the tails of all files, leaving everything
up to the highest written piece in each file</h2><h4>../src/torrent.cpp:1031</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			if (c) c-&gt;disconnect(errors::no_memory);
			return;
		}

		// notify the user of the error
		if (alerts().should_post&lt;file_error_alert&gt;())
			alerts().post_alert(file_error_alert(j.error_file, get_handle(), j.error));

		// put the torrent in an error-state
		set_error(j.error, j.error_file);

		if (j.action == disk_io_job::write
			&amp;&amp; (j.error == boost::system::errc::read_only_file_system
			|| j.error == boost::system::errc::permission_denied
			|| j.error == boost::system::errc::operation_not_permitted
			|| j.error == boost::system::errc::no_space_on_device
			|| j.error == boost::system::errc::file_too_large))
		{
			// if we failed to write, stop downloading and just
			// keep seeding.
<div style="background: #ffff00" width="100%">			set_upload_mode(true);
</div>			return;
		}

		// if the error appears to be more serious than a full disk, just pause the torrent
		pause();
	}

	void torrent::on_disk_read_complete(int ret, disk_io_job const&amp; j
		, peer_request r, read_piece_struct* rp)
	{
		TORRENT_ASSERT(m_ses.is_network_thread());

		disk_buffer_holder buffer(m_ses, j.buffer);

		--rp-&gt;blocks_left;
		if (ret != r.length)
		{
			rp-&gt;fail = true;
			rp-&gt;error = j.error;
			handle_disk_error(j);
		}
		else
		{
			std::memcpy(rp-&gt;piece_data.get() + r.start, j.buffer, r.length);
		}

		if (rp-&gt;blocks_left == 0)
		{
			int size = m_torrent_file-&gt;piece_size(r.piece);
			if (rp-&gt;fail)
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(15)">../src/torrent.cpp:5505</a></td><td>save the send_stats state instead of throwing them away it may pose an issue when downgrading though</td></tr><tr id="15" style="display: none;" colspan="3"><td colspan="3"><h2>save the send_stats state instead of throwing them away
it may pose an issue when downgrading though</h2><h4>../src/torrent.cpp:5505</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">						? (1 &lt;&lt; k) : 0;
					bitmask.append(1, v);
					TORRENT_ASSERT(bits == 8 || j == num_bitmask_bytes - 1);
				}
				piece_struct["bitmask"] = bitmask;
				// push the struct onto the unfinished-piece list
				up.push_back(piece_struct);
			}
		}

		// save trackers
		if (!m_trackers.empty())
		{
			entry::list_type&amp; tr_list = ret["trackers"].list();
			tr_list.push_back(entry::list_type());
			int tier = 0;
			for (std::vector&lt;announce_entry&gt;::const_iterator i = m_trackers.begin()
				, end(m_trackers.end()); i != end; ++i)
			{
				// don't save trackers we can't trust
<div style="background: #ffff00" width="100%">				if (i-&gt;send_stats == false) continue;
</div>				if (i-&gt;tier == tier)
				{
					tr_list.back().list().push_back(i-&gt;url);
				}
				else
				{
					tr_list.push_back(entry::list_t);
					tr_list.back().list().push_back(i-&gt;url);
					tier = i-&gt;tier;
				}
			}
		}

		// save web seeds
		if (!m_web_seeds.empty())
		{
			entry::list_type&amp; url_list = ret["url-list"].list();
			entry::list_type&amp; httpseed_list = ret["httpseeds"].list();
			for (std::list&lt;web_seed_entry&gt;::const_iterator i = m_web_seeds.begin()
				, end(m_web_seeds.end()); i != end; ++i)
			{
				if (i-&gt;type == web_seed_entry::url_seed)
					url_list.push_back(i-&gt;url);
				else if (i-&gt;type == web_seed_entry::http_seed)
					httpseed_list.push_back(i-&gt;url);
			}
		}

		// write have bitmask
		// the pieces string has one byte per piece. Each
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(16)">../src/torrent.cpp:6412</a></td><td>should disconnect all peers that have the pieces we have not just seeds. It would be pretty expensive to check all pieces for all peers though</td></tr><tr id="16" style="display: none;" colspan="3"><td colspan="3"><h2>should disconnect all peers that have the pieces we have
not just seeds. It would be pretty expensive to check all pieces
for all peers though</h2><h4>../src/torrent.cpp:6412</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		TORRENT_ASSERT(m_state != torrent_status::finished &amp;&amp; m_state != torrent_status::seeding);

		set_state(torrent_status::finished);
		set_queue_position(-1);

		// we have to call completed() before we start
		// disconnecting peers, since there's an assert
		// to make sure we're cleared the piece picker
		if (is_seed()) completed();

		send_upload_only();

		state_updated();

		if (m_completed_time == 0)
			m_completed_time = time(0);

		// disconnect all seeds
		if (settings().close_redundant_connections)
		{
<div style="background: #ffff00" width="100%">			std::vector&lt;peer_connection*&gt; seeds;
</div>			for (peer_iterator i = m_connections.begin();
				i != m_connections.end(); ++i)
			{
				peer_connection* p = *i;
				TORRENT_ASSERT(p-&gt;associated_torrent().lock().get() == this);
				if (p-&gt;upload_only())
				{
#if defined TORRENT_VERBOSE_LOGGING || defined TORRENT_ERROR_LOGGING
					p-&gt;peer_log("*** SEED, CLOSING CONNECTION");
#endif
					seeds.push_back(p);
				}
			}
			std::for_each(seeds.begin(), seeds.end()
				, boost::bind(&amp;peer_connection::disconnect, _1, errors::torrent_finished, 0));
		}

		if (m_abort) return;

		m_policy.recalculate_connect_candidates();

		TORRENT_ASSERT(m_storage);
		// we need to keep the object alive during this operation
		m_storage-&gt;async_release_files(
			boost::bind(&amp;torrent::on_files_released, shared_from_this(), _1, _2));
		
		// this torrent just completed downloads, which means it will fall
		// under a different limit with the auto-manager. Make sure we
		// update auto-manage torrents in that case
		if (m_auto_managed)
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(17)">../src/torrent_info.cpp:181</a></td><td>we might save constructing a std::string if this would take a char const* instead</td></tr><tr id="17" style="display: none;" colspan="3"><td colspan="3"><h2>we might save constructing a std::string if this would take a char const* instead</h2><h4>../src/torrent_info.cpp:181</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			{
				tmp_path += i[0];
				tmp_path += i[1];
				tmp_path += i[2];
				tmp_path += i[3];
				i += 3;
				continue;
			}

			tmp_path += "_";
			valid_encoding = false;
		}
		// the encoding was not valid utf-8
		// save the original encoding and replace the
		// commonly used path with the correctly
		// encoded string
		if (!valid_encoding) target = tmp_path;
		return valid_encoding;
	}

<div style="background: #ffff00" width="100%">	bool valid_path_element(std::string const&amp; element)
</div>	{
		if (element.empty()
			|| element == "." || element == ".."
			|| element[0] == '/' || element[0] == '\\'
			|| element[element.size()-1] == ':')
			return false;
		return true;
	}

	TORRENT_EXTRA_EXPORT void trim_path_element(std::string&amp; element)
	{
		const int max_path_len = TORRENT_MAX_PATH;

		// on windows, the max path is expressed in
		// unicode characters, not bytes
#if defined TORRENT_WINDOWS &amp;&amp; TORRENT_USE_WSTRING
		std::wstring path_element;
		utf8_wchar(element, path_element);
		if (path_element.size() &gt; max_path_len)
		{
			// truncate filenames that are too long. But keep extensions!
			std::wstring ext;
			wchar_t const* ext1 = wcsrchr(path_element.c_str(), '.');
			if (ext1 != NULL) ext = ext1;

			if (ext.size() &gt; 15)
			{
				path_element.resize(max_path_len);
			}
			else
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(18)">../src/torrent_info.cpp:405</a></td><td>this logic should be a separate step done once the torrent is loaded, and the original filenames should be preserved!</td></tr><tr id="18" style="display: none;" colspan="3"><td colspan="3"><h2>this logic should be a separate step
done once the torrent is loaded, and the original
filenames should be preserved!</h2><h4>../src/torrent_info.cpp:405</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	
			while (*s1 != 0 || *s2 != 0)
			{
				c1 = to_lower(*s1);
				c2 = to_lower(*s2);
				if (c1 &lt; c2) return true;
				if (c1 &gt; c2) return false;
				++s1;
				++s2;
			}
			return false;
		}
	};

	bool extract_files(lazy_entry const&amp; list, file_storage&amp; target
		, std::string const&amp; root_dir, ptrdiff_t info_ptr_diff)
	{
		if (list.type() != lazy_entry::list_t) return false;
		target.reserve(list.list_size());

<div style="background: #ffff00" width="100%">		std::set&lt;std::string, string_less_no_case&gt; files;
</div>
		for (int i = 0, end(list.list_size()); i &lt; end; ++i)
		{
			lazy_entry const* file_hash = 0;
			time_t mtime = 0;
			file_entry e;
			lazy_entry const* fee = 0;
			if (!extract_single_file(*list.list_at(i), e, root_dir
				, &amp;file_hash, &amp;fee, &amp;mtime))
				return false;

			// as long as this file already exists
			// increase the counter
			int cnt = 0;
			if (!files.insert(e.path).second)
			{
				std::string base = remove_extension(e.path);
				std::string ext = extension(e.path);
				do
				{
					++cnt;
					char new_ext[50];
					snprintf(new_ext, sizeof(new_ext), ".%d%s", cnt, ext.c_str());
					e.path = base + new_ext;
				} while (!files.insert(e.path).second);
			}
			target.add_file(e, file_hash ? file_hash-&gt;string_ptr() + info_ptr_diff : 0);

			// This is a memory optimization! Instead of having
			// each entry keep a string for its filename, make it
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(19)">../src/torrent_info.cpp:441</a></td><td>once the filename renaming is removed from here this check can be removed as well</td></tr><tr id="19" style="display: none;" colspan="3"><td colspan="3"><h2>once the filename renaming is removed from here
this check can be removed as well</h2><h4>../src/torrent_info.cpp:441</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// increase the counter
			int cnt = 0;
			if (!files.insert(e.path).second)
			{
				std::string base = remove_extension(e.path);
				std::string ext = extension(e.path);
				do
				{
					++cnt;
					char new_ext[50];
					snprintf(new_ext, sizeof(new_ext), ".%d%s", cnt, ext.c_str());
					e.path = base + new_ext;
				} while (!files.insert(e.path).second);
			}
			target.add_file(e, file_hash ? file_hash-&gt;string_ptr() + info_ptr_diff : 0);

			// This is a memory optimization! Instead of having
			// each entry keep a string for its filename, make it
			// simply point into the info-section buffer
			int last_index = target.num_files() - 1;
<div style="background: #ffff00" width="100%">			if (fee &amp;&amp; target.file_name(last_index) == fee-&gt;string_value())
</div>			{
				// this string pointer does not necessarily point into
				// the m_info_section buffer.
				char const* str_ptr = fee-&gt;string_ptr() + info_ptr_diff;
				target.rename_file_borrow(last_index, str_ptr, fee-&gt;string_length());
			}
		}
		return true;
	}

	int merkle_get_parent(int tree_node)
	{
		// node 0 doesn't have a parent
		TORRENT_ASSERT(tree_node &gt; 0);
		return (tree_node - 1) / 2;
	}

	int merkle_get_sibling(int tree_node)
	{
		// node 0 doesn't have a sibling
		TORRENT_ASSERT(tree_node &gt; 0);
		// even numbers have their sibling to the left
		// odd numbers have their sibling to the right
		return tree_node + (tree_node&amp;1?1:-1);
	}

	int merkle_num_nodes(int leafs)
	{
		TORRENT_ASSERT(leafs &gt; 0);
		return (leafs &lt;&lt; 1) - 1;
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(20)">../src/kademlia/node.cpp:810</a></td><td>find_node should write directly to the response entry</td></tr><tr id="20" style="display: none;" colspan="3"><td colspan="3"><h2>find_node should write directly to the response entry</h2><h4>../src/kademlia/node.cpp:810</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		{
			TORRENT_LOG(node) &lt;&lt; " values: " &lt;&lt; reply["values"].list().size();
		}
#endif
	}
	else if (strcmp(query, "find_node") == 0)
	{
		key_desc_t msg_desc[] = {
			{"target", lazy_entry::string_t, 20, 0},
		};

		lazy_entry const* msg_keys[1];
		if (!verify_message(arg_ent, msg_desc, msg_keys, 1, error_string, sizeof(error_string)))
		{
			incoming_error(e, error_string);
			return;
		}

		sha1_hash target(msg_keys[0]-&gt;string_ptr());

<div style="background: #ffff00" width="100%">		nodes_t n;
</div>		m_table.find_node(target, n, 0);
		write_nodes_entry(reply, n);
	}
	else if (strcmp(query, "announce_peer") == 0)
	{
		key_desc_t msg_desc[] = {
			{"info_hash", lazy_entry::string_t, 20, 0},
			{"port", lazy_entry::int_t, 0, 0},
			{"token", lazy_entry::string_t, 0, 0},
			{"n", lazy_entry::string_t, 0, key_desc_t::optional},
			{"seed", lazy_entry::int_t, 0, key_desc_t::optional},
			{"implied_port", lazy_entry::int_t, 0, key_desc_t::optional},
		};

		lazy_entry const* msg_keys[6];
		if (!verify_message(arg_ent, msg_desc, msg_keys, 6, error_string, sizeof(error_string)))
		{
#ifdef TORRENT_DHT_VERBOSE_LOGGING
			++g_failed_announces;
#endif
			incoming_error(e, error_string);
			return;
		}

		int port = int(msg_keys[1]-&gt;int_value());

		// is the announcer asking to ignore the explicit
		// listen port and instead use the source port of the packet?
		if (msg_keys[5] &amp;&amp; msg_keys[5]-&gt;int_value() != 0)
			port = m.addr.port();
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(21)">../include/libtorrent/ip_voter.hpp:122</a></td><td>instead, have one instance per possible subnet, global IPv4, global IPv6, loopback, 192.168.x.x, 10.x.x.x, etc.</td></tr><tr id="21" style="display: none;" colspan="3"><td colspan="3"><h2>instead, have one instance per possible subnet, global IPv4, global IPv6, loopback, 192.168.x.x, 10.x.x.x, etc.</h2><h4>../include/libtorrent/ip_voter.hpp:122</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// away all the votes and started from scratch, in case
		// our IP has changed
		ptime m_last_rotate;
	};

	// this keeps track of multiple external IPs (for now, just IPv6 and IPv4, but
	// it could be extended to deal with loopback and local network addresses as well)
	struct TORRENT_EXTRA_EXPORT external_ip
	{
		// returns true if a different IP is the top vote now
		// i.e. we changed our idea of what our external IP is
		bool cast_vote(address const&amp; ip, int source_type, address const&amp; source);

		// the external IP as it would be observed from `ip`
		address external_address(address const&amp; ip) const;

	private:

		// for now, assume one external IPv4 and one external IPv6 address
		// 0 = IPv4 1 = IPv6
<div style="background: #ffff00" width="100%">		ip_voter m_vote_group[2];
</div>	};

}

#endif

</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(22)">../include/libtorrent/web_peer_connection.hpp:130</a></td><td>if we make this be a disk_buffer_holder instead we would save a copy sometimes use allocate_disk_receive_buffer and release_disk_receive_buffer</td></tr><tr id="22" style="display: none;" colspan="3"><td colspan="3"><h2>if we make this be a disk_buffer_holder instead
we would save a copy sometimes
use allocate_disk_receive_buffer and release_disk_receive_buffer</h2><h4>../include/libtorrent/web_peer_connection.hpp:130</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// returns the block currently being
		// downloaded. And the progress of that
		// block. If the peer isn't downloading
		// a piece for the moment, the boost::optional
		// will be invalid.
		boost::optional&lt;piece_block_progress&gt; downloading_piece_progress() const;

		void handle_padfile(buffer::const_interval&amp; recv_buffer);

		// this has one entry per http-request
		// (might be more than the bt requests)
		std::deque&lt;int&gt; m_file_requests;

		std::string m_url;
	
		web_seed_entry&amp; m_web;
			
		// this is used for intermediate storage of pieces
		// that are received in more than one HTTP response
<div style="background: #ffff00" width="100%">		std::vector&lt;char&gt; m_piece;
</div>		
		// the number of bytes received in the current HTTP
		// response. used to know where in the buffer the
		// next response starts
		size_type m_received_body;

		// position in the current range response
		size_type m_range_pos;

		// the position in the current block
		int m_block_pos;

		// this is the offset inside the current receive
		// buffer where the next chunk header will be.
		// this is updated for each chunk header that's
		// parsed. It does not necessarily point to a valid
		// offset in the receive buffer, if we haven't received
		// it yet. This offset never includes the HTTP header
		size_type m_chunk_pos;

		// this is the number of bytes we've already received
		// from the next chunk header we're waiting for
		int m_partial_chunk_header;

		// the number of responses we've received so far on
		// this connection
		int m_num_responses;
	};
}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(23)">../src/bt_peer_connection.cpp:641</a></td><td>this could be optimized using knuth morris pratt</td></tr><tr id="23" style="display: none;" colspan="3"><td colspan="3"><h2>this could be optimized using knuth morris pratt</h2><h4>../src/bt_peer_connection.cpp:641</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		{
			disconnect(errors::no_memory);
			return;
		}

#ifdef TORRENT_VERBOSE_LOGGING
		peer_log(" computed RC4 keys");
#endif
	}

	int bt_peer_connection::get_syncoffset(char const* src, int src_size,
		char const* target, int target_size) const
	{
		TORRENT_ASSERT(target_size &gt;= src_size);
		TORRENT_ASSERT(src_size &gt; 0);
		TORRENT_ASSERT(src);
		TORRENT_ASSERT(target);

		int traverse_limit = target_size - src_size;

<div style="background: #ffff00" width="100%">		for (int i = 0; i &lt; traverse_limit; ++i)
</div>		{
			char const* target_ptr = target + i;
			if (std::equal(src, src+src_size, target_ptr))
				return i;
		}

//	    // Partial sync
// 		for (int i = 0; i &lt; target_size; ++i)
// 		{
// 			// first is iterator in src[] at which mismatch occurs
// 			// second is iterator in target[] at which mismatch occurs
// 			std::pair&lt;const char*, const char*&gt; ret;
// 			int src_sync_size;
//  			if (i &gt; traverse_limit) // partial sync test
//  			{
//  				ret = std::mismatch(src, src + src_size - (i - traverse_limit), &amp;target[i]);
//  				src_sync_size = ret.first - src;
//  				if (src_sync_size == (src_size - (i - traverse_limit)))
//  					return i;
//  			}
//  			else // complete sync test
// 			{
// 				ret = std::mismatch(src, src + src_size, &amp;target[i]);
// 				src_sync_size = ret.first - src;
// 				if (src_sync_size == src_size)
// 					return i;
// 			}
// 		}

        // no complete sync
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(24)">../src/bt_peer_connection.cpp:2110</a></td><td>if we're finished, send upload_only message</td></tr><tr id="24" style="display: none;" colspan="3"><td colspan="3"><h2>if we're finished, send upload_only message</h2><h4>../src/bt_peer_connection.cpp:2110</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			if (msg[5 + k / 8] &amp; (0x80 &gt;&gt; (k % 8))) bitfield_string[k] = '1';
			else bitfield_string[k] = '0';
		}
		peer_log("==&gt; BITFIELD [ %s ]", bitfield_string.c_str());
#endif
#if TORRENT_USE_ASSERTS
		m_sent_bitfield = true;
#endif

		send_buffer(msg, packet_size);

		if (num_lazy_pieces &gt; 0)
		{
			for (int i = 0; i &lt; num_lazy_pieces; ++i)
			{
#ifdef TORRENT_VERBOSE_LOGGING
				peer_log("==&gt; HAVE    [ piece: %d ]", lazy_pieces[i]);
#endif
				write_have(lazy_pieces[i]);
			}
<div style="background: #ffff00" width="100%">		}
</div>
		if (m_supports_fast)
			send_allowed_set();
	}

#ifndef TORRENT_DISABLE_EXTENSIONS
	void bt_peer_connection::write_extensions()
	{
		INVARIANT_CHECK;

		TORRENT_ASSERT(m_supports_extensions);
		TORRENT_ASSERT(m_sent_handshake);

		entry handshake;
		entry::dictionary_type&amp; m = handshake["m"].dict();

		// if we're using a proxy, our listen port won't be useful
		// anyway.
		if (!m_ses.settings().force_proxy &amp;&amp; is_outgoing())
			handshake["p"] = m_ses.listen_port();

		// only send the port in case we bade the connection
		// on incoming connections the other end already knows
		// our listen port
		if (!m_ses.m_settings.anonymous_mode)
		{
			handshake["v"] = m_ses.settings().handshake_client_version.empty()
				? m_ses.settings().user_agent : m_ses.settings().handshake_client_version;
		}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(25)">../src/bt_peer_connection.cpp:3362</a></td><td>move the erasing into the loop above remove all payload ranges that has been sent</td></tr><tr id="25" style="display: none;" colspan="3"><td colspan="3"><h2>move the erasing into the loop above
remove all payload ranges that has been sent</h2><h4>../src/bt_peer_connection.cpp:3362</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			for (std::vector&lt;range&gt;::iterator i = m_payloads.begin();
				i != m_payloads.end(); ++i)
			{
				i-&gt;start -= bytes_transferred;
				if (i-&gt;start &lt; 0)
				{
					if (i-&gt;start + i-&gt;length &lt;= 0)
					{
						amount_payload += i-&gt;length;
					}
					else
					{
						amount_payload += -i-&gt;start;
						i-&gt;length -= -i-&gt;start;
						i-&gt;start = 0;
					}
				}
			}
		}

<div style="background: #ffff00" width="100%">		m_payloads.erase(
</div>			std::remove_if(m_payloads.begin(), m_payloads.end(), range_below_zero)
			, m_payloads.end());

		TORRENT_ASSERT(amount_payload &lt;= (int)bytes_transferred);
		m_statistics.sent_bytes(amount_payload, bytes_transferred - amount_payload);
		
		if (amount_payload &gt; 0)
		{
			boost::shared_ptr&lt;torrent&gt; t = associated_torrent().lock();
			TORRENT_ASSERT(t);
			if (t) t-&gt;update_last_upload();
		}
	}

#if TORRENT_USE_INVARIANT_CHECKS
	void bt_peer_connection::check_invariant() const
	{
		boost::shared_ptr&lt;torrent&gt; t = associated_torrent().lock();

#ifndef TORRENT_DISABLE_ENCRYPTION
		TORRENT_ASSERT( (bool(m_state != read_pe_dhkey) || m_dh_key_exchange.get())
				|| !is_outgoing());

		TORRENT_ASSERT(!m_rc4_encrypted || m_enc_handler.get());
#endif
		if (!in_handshake())
		{
			TORRENT_ASSERT(m_sent_handshake);
		}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(26)">../src/file.cpp:1403</a></td><td>is there any way to pre-fetch data from a file on windows?</td></tr><tr id="26" style="display: none;" colspan="3"><td colspan="3"><h2>is there any way to pre-fetch data from a file on windows?</h2><h4>../src/file.cpp:1403</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	void file::init_file()
	{
		if (m_page_size != 0) return;

		m_page_size = page_size();
	}

#endif

	void file::hint_read(size_type file_offset, int len)
	{
#if defined POSIX_FADV_WILLNEED
		posix_fadvise(m_fd, file_offset, len, POSIX_FADV_WILLNEED);
#elif defined F_RDADVISE
		radvisory r;
		r.ra_offset = file_offset;
		r.ra_count = len;
		fcntl(m_fd, F_RDADVISE, &amp;r);
#else
<div style="background: #ffff00" width="100%">#endif
</div>	}

	size_type file::readv(size_type file_offset, iovec_t const* bufs, int num_bufs, error_code&amp; ec)
	{
#ifdef TORRENT_WINDOWS
		if (m_file_handle == INVALID_HANDLE_VALUE)
		{
			ec = error_code(ERROR_INVALID_HANDLE, get_system_category());
			return -1;
		}
#else
		if (m_fd == -1)
		{
			ec = error_code(EBADF, get_system_category());
			return -1;
		}
#endif
		TORRENT_ASSERT((m_open_mode &amp; rw_mask) == read_only || (m_open_mode &amp; rw_mask) == read_write);
		TORRENT_ASSERT(bufs);
		TORRENT_ASSERT(num_bufs &gt; 0);
		TORRENT_ASSERT(is_open());

#if defined TORRENT_WINDOWS || defined TORRENT_LINUX || defined TORRENT_DEBUG
		// make sure m_page_size is initialized
		init_file();
#endif

#ifdef TORRENT_DEBUG
		if (m_open_mode &amp; no_buffer)
		{
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(27)">../src/http_tracker_connection.cpp:97</a></td><td>support authentication (i.e. user name and password) in the URL</td></tr><tr id="27" style="display: none;" colspan="3"><td colspan="3"><h2>support authentication (i.e. user name and password) in the URL</h2><h4>../src/http_tracker_connection.cpp:97</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		, aux::session_impl const&amp; ses
		, proxy_settings const&amp; ps
		, std::string const&amp; auth
#if TORRENT_USE_I2P
		, i2p_connection* i2p_conn
#endif
		)
		: tracker_connection(man, req, ios, c)
		, m_man(man)
		, m_ses(ses)
		, m_ps(ps)
		, m_cc(cc)
		, m_ios(ios)
#if TORRENT_USE_I2P
		, m_i2p_conn(i2p_conn)
#endif
	{}

	void http_tracker_connection::start()
	{
<div style="background: #ffff00" width="100%">		std::string url = tracker_req().url;
</div>
		if (tracker_req().kind == tracker_request::scrape_request)
		{
			// find and replace "announce" with "scrape"
			// in request

			std::size_t pos = url.find("announce");
			if (pos == std::string::npos)
			{
				tracker_connection::fail(error_code(errors::scrape_not_available));
				return;
			}
			url.replace(pos, 8, "scrape");
		}
		
#if TORRENT_USE_I2P
		bool i2p = is_i2p_url(url);
#else
		static const bool i2p = false;
#endif

		session_settings const&amp; settings = m_ses.settings();

		// if request-string already contains
		// some parameters, append an ampersand instead
		// of a question mark
		size_t arguments_start = url.find('?');
		if (arguments_start != std::string::npos)
			url += "&amp;";
		else
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(28)">../src/i2p_stream.cpp:210</a></td><td>move this to proxy_base and use it in all proxies</td></tr><tr id="28" style="display: none;" colspan="3"><td colspan="3"><h2>move this to proxy_base and use it in all proxies</h2><h4>../src/i2p_stream.cpp:210</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	i2p_stream::i2p_stream(io_service&amp; io_service)
		: proxy_base(io_service)
		, m_id(0)
		, m_command(cmd_create_session)
		, m_state(0)
	{
#if TORRENT_USE_ASSERTS
		m_magic = 0x1337;
#endif
	}

	i2p_stream::~i2p_stream()
	{
#if TORRENT_USE_ASSERTS
		TORRENT_ASSERT(m_magic == 0x1337);
		m_magic = 0;
#endif
	}

<div style="background: #ffff00" width="100%">	bool i2p_stream::handle_error(error_code const&amp; e, boost::shared_ptr&lt;handler_type&gt; const&amp; h)
</div>	{
		TORRENT_ASSERT(m_magic == 0x1337);
		if (!e) return false;
//		fprintf(stderr, "i2p error \"%s\"\n", e.message().c_str());
		(*h)(e);
		return true;
	}

	void i2p_stream::do_connect(error_code const&amp; e, tcp::resolver::iterator i
		, boost::shared_ptr&lt;handler_type&gt; h)
	{
		TORRENT_ASSERT(m_magic == 0x1337);
		if (e || i == tcp::resolver::iterator())
		{
			(*h)(e);
			error_code ec;
			close(ec);
			return;
		}

#if defined TORRENT_ASIO_DEBUGGING
		add_outstanding_async("i2p_stream::connected");
#endif
		m_sock.async_connect(i-&gt;endpoint(), boost::bind(
			&amp;i2p_stream::connected, this, _1, h));
	}

	void i2p_stream::connected(error_code const&amp; e, boost::shared_ptr&lt;handler_type&gt; h)
	{
		TORRENT_ASSERT(m_magic == 0x1337);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(29)">../src/packet_buffer.cpp:176</a></td><td>use compare_less_wrap for this comparison as well</td></tr><tr id="29" style="display: none;" colspan="3"><td colspan="3"><h2>use compare_less_wrap for this comparison as well</h2><h4>../src/packet_buffer.cpp:176</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		while (new_size &lt; size)
			new_size &lt;&lt;= 1;

		void** new_storage = (void**)malloc(sizeof(void*) * new_size);

		for (index_type i = 0; i &lt; new_size; ++i)
			new_storage[i] = 0;

		for (index_type i = m_first; i &lt; (m_first + m_capacity); ++i)
			new_storage[i &amp; (new_size - 1)] = m_storage[i &amp; (m_capacity - 1)];

		free(m_storage);

		m_storage = new_storage;
		m_capacity = new_size;
	}

	void* packet_buffer::remove(index_type idx)
	{
		INVARIANT_CHECK;
<div style="background: #ffff00" width="100%">		if (idx &gt;= m_first + m_capacity)
</div>			return 0;

		if (compare_less_wrap(idx, m_first, 0xffff))
			return 0;

		const int mask = (m_capacity - 1);
		void* old_value = m_storage[idx &amp; mask];
		m_storage[idx &amp; mask] = 0;

		if (old_value)
		{
			--m_size;
			if (m_size == 0) m_last = m_first;
		}

		if (idx == m_first &amp;&amp; m_size != 0)
		{
			++m_first;
			for (boost::uint32_t i = 0; i &lt; m_capacity; ++i, ++m_first)
				if (m_storage[m_first &amp; mask]) break;
			m_first &amp;= 0xffff;
		}

		if (((idx + 1) &amp; 0xffff) == m_last &amp;&amp; m_size != 0)
		{
			--m_last;
			for (boost::uint32_t i = 0; i &lt; m_capacity; ++i, --m_last)
				if (m_storage[m_last &amp; mask]) break;
			++m_last;
			m_last &amp;= 0xffff;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(30)">../src/peer_connection.cpp:986</a></td><td>this should only be peers we're trying to download from</td></tr><tr id="30" style="display: none;" colspan="3"><td colspan="3"><h2>this should only be peers we're trying to download from</h2><h4>../src/peer_connection.cpp:986</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	time_duration peer_connection::download_queue_time(int extra_bytes) const
	{
		boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		TORRENT_ASSERT(t);

		int rate = 0;

		// if we haven't received any data recently, the current download rate
		// is not representative
		if (time_now() - m_last_piece &gt; seconds(30) &amp;&amp; m_download_rate_peak &gt; 0)
		{
			rate = m_download_rate_peak;
		}
		else if (time_now() - m_last_unchoked &lt; seconds(5)
			&amp;&amp; m_statistics.total_payload_upload() &lt; 2 * 0x4000)
		{
			// if we're have only been unchoked for a short period of time,
			// we don't know what rate we can get from this peer. Instead of assuming
			// the lowest possible rate, assume the average.

<div style="background: #ffff00" width="100%">			int peers_with_requests = m_ses.num_connections();
</div>			// avoid division by 0
			if (peers_with_requests == 0) peers_with_requests = 1;

			rate = m_ses.m_stat.transfer_rate(stat::download_payload) / peers_with_requests;
		}
		else
		{
			// current download rate in bytes per seconds
			rate = m_statistics.transfer_rate(stat::download_payload);
		}

		// avoid division by zero
		if (rate &lt; 50) rate = 50;

		// average of current rate and peak
//		rate = (rate + m_download_rate_peak) / 2;

		return seconds((m_outstanding_bytes + m_queued_time_critical * t-&gt;block_size()) / rate);
	}

	void peer_connection::add_stat(size_type downloaded, size_type uploaded)
	{
		m_statistics.add_stat(downloaded, uploaded);
	}

	bitfield const&amp; peer_connection::get_bitfield() const
	{
		return m_have_piece;
	}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(31)">../src/peer_connection.cpp:2750</a></td><td>this might need something more so that once we have the metadata we can construct a full bitfield</td></tr><tr id="31" style="display: none;" colspan="3"><td colspan="3"><h2>this might need something more
so that once we have the metadata
we can construct a full bitfield</h2><h4>../src/peer_connection.cpp:2750</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
#ifdef TORRENT_VERBOSE_LOGGING
		peer_log("*** THIS IS A SEED [ p: %p ]", m_peer_info);
#endif

		t-&gt;get_policy().set_seed(m_peer_info, true);
		m_upload_only = true;
		m_bitfield_received = true;

		// if we don't have metadata yet
		// just remember the bitmask
		// don't update the piecepicker
		// (since it doesn't exist yet)
		if (!t-&gt;ready_for_connections())
		{
			// assume seeds are interesting when we
			// don't even have the metadata
			t-&gt;get_policy().peer_is_interesting(*this);

			disconnect_if_redundant();
<div style="background: #ffff00" width="100%">			return;
</div>		}

		TORRENT_ASSERT(!m_have_piece.empty());
		m_have_piece.set_all();
		m_num_pieces = m_have_piece.size();
		
		t-&gt;peer_has_all(this);

		// if we're finished, we're not interested
		if (t-&gt;is_upload_only()) send_not_interested();
		else t-&gt;get_policy().peer_is_interesting(*this);

		disconnect_if_redundant();
	}
	
	// -----------------------------
	// --------- HAVE NONE ---------
	// -----------------------------

	void peer_connection::incoming_have_none()
	{
		INVARIANT_CHECK;

#ifdef TORRENT_VERBOSE_LOGGING
		peer_log("&lt;== HAVE_NONE");
#endif

		boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		TORRENT_ASSERT(t);

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(32)">../src/peer_connection.cpp:2881</a></td><td>sort the allowed fast set in priority order</td></tr><tr id="32" style="display: none;" colspan="3"><td colspan="3"><h2>sort the allowed fast set in priority order</h2><h4>../src/peer_connection.cpp:2881</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// this piece index later
		m_allowed_fast.push_back(index);

		// if the peer has the piece and we want
		// to download it, request it
		if (int(m_have_piece.size()) &gt; index
			&amp;&amp; m_have_piece[index]
			&amp;&amp; t-&gt;valid_metadata()
			&amp;&amp; t-&gt;has_picker()
			&amp;&amp; t-&gt;picker().piece_priority(index) &gt; 0)
		{
			t-&gt;get_policy().peer_is_interesting(*this);
		}
	}

	std::vector&lt;int&gt; const&amp; peer_connection::allowed_fast()
	{
		boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		TORRENT_ASSERT(t);

<div style="background: #ffff00" width="100%">		return m_allowed_fast;
</div>	}

	bool peer_connection::can_request_time_critical() const
	{
		if (has_peer_choked() || !is_interesting()) return false;
		if ((int)m_download_queue.size() + (int)m_request_queue.size()
			&gt; m_desired_queue_size * 2) return false;
		if (on_parole()) return false; 
		if (m_disconnecting) return false;
		boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		TORRENT_ASSERT(t);
		if (t-&gt;upload_mode()) return false;

		// ignore snubbed peers, since they're not likely to return pieces in a
		// timely manner anyway
		if (m_snubbed) return false;
		return true;
	}

	bool peer_connection::make_time_critical(piece_block const&amp; block)
	{
		std::vector&lt;pending_block&gt;::iterator rit = std::find_if(m_request_queue.begin()
			, m_request_queue.end(), has_block(block));
		if (rit == m_request_queue.end()) return false;
#if TORRENT_USE_ASSERTS
		boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		TORRENT_ASSERT(t);
		TORRENT_ASSERT(t-&gt;has_picker());
		TORRENT_ASSERT(t-&gt;picker().is_requested(block));
#endif
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(33)">../src/peer_connection.cpp:4547</a></td><td>peers should really be corked/uncorked outside of all completed disk operations</td></tr><tr id="33" style="display: none;" colspan="3"><td colspan="3"><h2>peers should really be corked/uncorked outside of
all completed disk operations</h2><h4>../src/peer_connection.cpp:4547</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				// this means we're in seed mode and we haven't yet
				// verified this piece (r.piece)
				t-&gt;filesystem().async_read_and_hash(r, boost::bind(&amp;peer_connection::on_disk_read_complete
					, self(), _1, _2, r), cache.second);
				t-&gt;verified(r.piece);
			}

			m_reading_bytes += r.length;

			m_requests.erase(m_requests.begin());
			sent_a_piece = true;
		}

		if (t-&gt;share_mode() &amp;&amp; sent_a_piece)
			t-&gt;recalc_share_mode();
	}

	void peer_connection::on_disk_read_complete(int ret, disk_io_job const&amp; j, peer_request r)
	{
		// flush send buffer at the end of this scope
<div style="background: #ffff00" width="100%">		cork _c(*this);
</div>
#ifdef TORRENT_STATS
		++m_ses.m_num_messages[aux::session_impl::on_disk_read_counter];
#endif
		TORRENT_ASSERT(m_ses.is_network_thread());

		m_reading_bytes -= r.length;

		disk_buffer_holder buffer(m_ses, j.buffer);
#if TORRENT_DISK_STATS
		if (j.buffer) m_ses.m_disk_thread.rename_buffer(j.buffer, "received send buffer");
#endif

		boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		if (!t)
		{
			disconnect(j.error);
			return;
		}
		
		if (ret != r.length)
		{
			if (ret == -3)
			{
#if defined TORRENT_VERBOSE_LOGGING
				peer_log("==&gt; REJECT_PIECE [ piece: %d s: %d l: %d ]"
					, r.piece , r.start , r.length);
#endif
				write_reject_request(r);
				if (t-&gt;seed_mode()) t-&gt;leave_seed_mode(false);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(34)">../src/policy.cpp:886</a></td><td>only allow _one_ connection to use this override at a time</td></tr><tr id="34" style="display: none;" colspan="3"><td colspan="3"><h2>only allow _one_ connection to use this
override at a time</h2><h4>../src/policy.cpp:886</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				" external: " &lt;&lt; external.external_address(m_peers[candidate]-&gt;address()) &lt;&lt;
				" t: " &lt;&lt; (session_time - m_peers[candidate]-&gt;last_connected) &lt;&lt;
				" ]\n";
		}
#endif

		if (candidate == -1) return m_peers.end();
		return m_peers.begin() + candidate;
	}

	bool policy::new_connection(peer_connection&amp; c, int session_time)
	{
		TORRENT_ASSERT(!c.is_outgoing());

		INVARIANT_CHECK;

		// if the connection comes from the tracker,
		// it's probably just a NAT-check. Ignore the
		// num connections constraint then.

<div style="background: #ffff00" width="100%">		error_code ec;
</div>		TORRENT_ASSERT(c.remote() == c.get_socket()-&gt;remote_endpoint(ec) || ec);
		TORRENT_ASSERT(!m_torrent-&gt;is_paused());

#if defined TORRENT_VERBOSE_LOGGING || defined TORRENT_LOGGING
		if (c.remote().address() == m_torrent-&gt;current_tracker().address())
		{
			m_torrent-&gt;debug_log("overriding connection limit for tracker NAT-check");
		}
#endif

		iterator iter;
		peer* i = 0;

		bool found = false;
		if (m_torrent-&gt;settings().allow_multiple_connections_per_ip)
		{
			tcp::endpoint remote = c.remote();
			std::pair&lt;iterator, iterator&gt; range = find_peers(remote.address());
			iter = std::find_if(range.first, range.second, match_peer_endpoint(remote));
	
			if (iter != range.second)
			{
				TORRENT_ASSERT((*iter)-&gt;in_use);
				found = true;
			}
		}
		else
		{
			iter = std::lower_bound(
				m_peers.begin(), m_peers.end()
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(35)">../src/session_impl.cpp:1765</a></td><td>recalculate all connect candidates for all torrents</td></tr><tr id="35" style="display: none;" colspan="3"><td colspan="3"><h2>recalculate all connect candidates for all torrents</h2><h4>../src/session_impl.cpp:1765</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// #error closing the udp socket here means that
		// the uTP connections cannot be closed gracefully
		m_udp_socket.close();
		m_external_udp_port = 0;

		m_undead_peers.clear();

#ifndef TORRENT_DISABLE_GEO_IP
		if (m_asnum_db) GeoIP_delete(m_asnum_db);
		if (m_country_db) GeoIP_delete(m_country_db);
		m_asnum_db = 0;
		m_country_db = 0;
#endif

		m_disk_thread.abort();
	}

	void session_impl::set_port_filter(port_filter const&amp; f)
	{
		m_port_filter = f;
<div style="background: #ffff00" width="100%">	}
</div>
	void session_impl::set_ip_filter(ip_filter const&amp; f)
	{
		INVARIANT_CHECK;

		m_ip_filter = f;

		// Close connections whose endpoint is filtered
		// by the new ip-filter
		for (torrent_map::iterator i = m_torrents.begin()
			, end(m_torrents.end()); i != end; ++i)
			i-&gt;second-&gt;ip_filter_updated();
	}

	ip_filter const&amp; session_impl::get_ip_filter() const
	{
		return m_ip_filter;
	}

	void session_impl::update_disk_thread_settings()
	{
		disk_io_job j;
		j.buffer = (char*)new session_settings(m_settings);
		j.action = disk_io_job::update_settings;
		m_disk_thread.add_job(j);
	}

	template &lt;class Socket&gt;
	void static set_socket_buffer_size(Socket&amp; s, session_settings const&amp; sett, error_code&amp; ec)
	{
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(36)">../src/session_impl.cpp:3238</a></td><td>have a separate list for these connections, instead of having to loop through all of them</td></tr><tr id="36" style="display: none;" colspan="3"><td colspan="3"><h2>have a separate list for these connections, instead of having to loop through all of them</h2><h4>../src/session_impl.cpp:3238</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// --------------------------------------------------------------
		if (!m_paused) m_auto_manage_time_scaler--;
		if (m_auto_manage_time_scaler &lt; 0)
		{
			m_auto_manage_time_scaler = settings().auto_manage_interval;
			recalculate_auto_managed_torrents();
		}

		// --------------------------------------------------------------
		// check for incoming connections that might have timed out
		// --------------------------------------------------------------

		for (connection_map::iterator i = m_connections.begin();
			i != m_connections.end();)
		{
			peer_connection* p = (*i).get();
			++i;
			// ignore connections that already have a torrent, since they
			// are ticked through the torrents' second_tick
			if (!p-&gt;associated_torrent().expired()) continue;
<div style="background: #ffff00" width="100%">			if (m_last_tick - p-&gt;connected_time() &gt; seconds(m_settings.handshake_timeout))
</div>				p-&gt;disconnect(errors::timed_out);
		}

		// --------------------------------------------------------------
		// second_tick every torrent
		// --------------------------------------------------------------

		int congested_torrents = 0;
		int uncongested_torrents = 0;

		// count the number of seeding torrents vs. downloading
		// torrents we are running
		int num_seeds = 0;
		int num_downloads = 0;

		// count the number of peers of downloading torrents
		int num_downloads_peers = 0;

		torrent_map::iterator least_recently_scraped = m_torrents.end();
		int num_paused_auto_managed = 0;

		int num_checking = 0;
		int num_queued = 0;

#if TORRENT_DEBUG_STREAMING &gt; 0
		printf("\033[2J\033[0;0H");
#endif

		for (torrent_map::iterator i = m_torrents.begin();
			i != m_torrents.end();)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(37)">../src/session_impl.cpp:4306</a></td><td>allow extensions to sort torrents for queuing</td></tr><tr id="37" style="display: none;" colspan="3"><td colspan="3"><h2>allow extensions to sort torrents for queuing</h2><h4>../src/session_impl.cpp:4306</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			if (t-&gt;is_auto_managed() &amp;&amp; !t-&gt;has_error())
			{
				TORRENT_ASSERT(t-&gt;m_resume_data_loaded || !t-&gt;valid_metadata());
				// this torrent is auto managed, add it to
				// the list (depending on if it's a seed or not)
				if (t-&gt;is_finished())
					seeds.push_back(t);
				else
					downloaders.push_back(t);
			}
			else if (!t-&gt;is_paused())
			{
				TORRENT_ASSERT(t-&gt;m_resume_data_loaded || !t-&gt;valid_metadata());
				--hard_limit;
			}
		}

		bool handled_by_extension = false;

#ifndef TORRENT_DISABLE_EXTENSIONS
<div style="background: #ffff00" width="100%">#endif
</div>
		if (!handled_by_extension)
		{
			std::sort(downloaders.begin(), downloaders.end()
				, boost::bind(&amp;torrent::sequence_number, _1) &lt; boost::bind(&amp;torrent::sequence_number, _2));

			std::sort(seeds.begin(), seeds.end()
				, boost::bind(&amp;torrent::seed_rank, _1, boost::ref(m_settings))
				&gt; boost::bind(&amp;torrent::seed_rank, _2, boost::ref(m_settings)));
		}

		if (settings().auto_manage_prefer_seeds)
		{
			auto_manage_torrents(seeds, dht_limit, tracker_limit, lsd_limit
				, hard_limit, num_seeds);
			auto_manage_torrents(downloaders, dht_limit, tracker_limit, lsd_limit
				, hard_limit, num_downloaders);
		}
		else
		{
			auto_manage_torrents(downloaders, dht_limit, tracker_limit, lsd_limit
				, hard_limit, num_downloaders);
			auto_manage_torrents(seeds, dht_limit, tracker_limit, lsd_limit
				, hard_limit, num_seeds);
		}
	}

	void session_impl::recalculate_optimistic_unchoke_slots()
	{
		TORRENT_ASSERT(is_network_thread());
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(38)">../src/session_impl.cpp:4471</a></td><td>use a lower limit than m_settings.connections_limit to allocate the to 10% or so of connection slots for incoming connections</td></tr><tr id="38" style="display: none;" colspan="3"><td colspan="3"><h2>use a lower limit than m_settings.connections_limit
to allocate the to 10% or so of connection slots for incoming
connections</h2><h4>../src/session_impl.cpp:4471</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		{
			if (m_boost_connections &gt; max_connections)
			{
				m_boost_connections -= max_connections;
				max_connections = 0;
			}
			else
			{
				max_connections -= m_boost_connections;
				m_boost_connections = 0;
			}
		}

		// this logic is here to smooth out the number of new connection
		// attempts over time, to prevent connecting a large number of
		// sockets, wait 10 seconds, and then try again
		int limit = (std::min)(m_settings.connections_limit - num_connections(), free_slots);
		if (m_settings.smooth_connects &amp;&amp; max_connections &gt; (limit+1) / 2)
			max_connections = (limit+1) / 2;

<div style="background: #ffff00" width="100%">		if (!m_torrents.empty()
</div>			&amp;&amp; free_slots &gt; -m_half_open.limit()
			&amp;&amp; num_connections() &lt; m_settings.connections_limit
			&amp;&amp; !m_abort
			&amp;&amp; m_settings.connection_speed &gt; 0
			&amp;&amp; max_connections &gt; 0)
		{
			// this is the maximum number of connections we will
			// attempt this tick
			int average_peers = 0;
			if (num_downloads &gt; 0)
				average_peers = num_downloads_peers / num_downloads;

			if (m_next_connect_torrent == m_torrents.end())
				m_next_connect_torrent = m_torrents.begin();

			int steps_since_last_connect = 0;
			int num_torrents = int(m_torrents.size());
			for (;;)
			{
				torrent&amp; t = *m_next_connect_torrent-&gt;second;
				if (t.want_more_peers())
				{
					TORRENT_ASSERT(t.allows_peers());
					// have a bias to give more connection attempts
					// to downloading torrents than seed, and even
					// more to downloading torrents with less than
					// average number of connections
					int num_attempts = 1;
					if (!t.is_finished())
					{
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(39)">../src/session_impl.cpp:4505</a></td><td>make this bias configurable</td></tr><tr id="39" style="display: none;" colspan="3"><td colspan="3"><h2>make this bias configurable</h2><h4>../src/session_impl.cpp:4505</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(40)">../src/session_impl.cpp:4506</a></td><td>also take average_peers into account, to create a bias for downloading torrents with < average peers</td></tr><tr id="40" style="display: none;" colspan="3"><td colspan="3"><h2>also take average_peers into account, to create a bias for downloading torrents with < average peers</h2><h4>../src/session_impl.cpp:4506</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				average_peers = num_downloads_peers / num_downloads;

			if (m_next_connect_torrent == m_torrents.end())
				m_next_connect_torrent = m_torrents.begin();

			int steps_since_last_connect = 0;
			int num_torrents = int(m_torrents.size());
			for (;;)
			{
				torrent&amp; t = *m_next_connect_torrent-&gt;second;
				if (t.want_more_peers())
				{
					TORRENT_ASSERT(t.allows_peers());
					// have a bias to give more connection attempts
					// to downloading torrents than seed, and even
					// more to downloading torrents with less than
					// average number of connections
					int num_attempts = 1;
					if (!t.is_finished())
					{
<div style="background: #ffff00" width="100%">						TORRENT_ASSERT(m_num_active_downloading &gt; 0);
</div>						num_attempts += m_num_active_finished / m_num_active_downloading;
					}
					while (m_current_connect_attempts &lt; num_attempts)
					{
						TORRENT_TRY
						{
							++m_current_connect_attempts;
							if (t.try_connect_peer())
							{
								--max_connections;
								--free_slots;
								steps_since_last_connect = 0;
#ifdef TORRENT_STATS
								++m_connection_attempts;
#endif
							}
						}
						TORRENT_CATCH(std::bad_alloc&amp;)
						{
							// we ran out of memory trying to connect to a peer
							// lower the global limit to the number of peers
							// we already have
							m_settings.connections_limit = num_connections();
							if (m_settings.connections_limit &lt; 2) m_settings.connections_limit = 2;
						}
						if (!t.want_more_peers()) break;
						if (free_slots &lt;= -m_half_open.limit()) return;
						if (max_connections == 0) return;
						if (num_connections() &gt;= m_settings.connections_limit) return;
					}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(41)">../src/session_impl.cpp:4616</a></td><td>post a message to have this happen immediately instead of waiting for the next tick</td></tr><tr id="41" style="display: none;" colspan="3"><td colspan="3"><h2>post a message to have this happen
immediately instead of waiting for the next tick</h2><h4>../src/session_impl.cpp:4616</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">					{
						// we've unchoked this peer, and it hasn't reciprocated
						// we may want to increase our estimated reciprocation rate
						p-&gt;increase_est_reciprocation_rate();
					}
				}
			}

			if (!p-&gt;is_peer_interested()
				|| p-&gt;is_disconnecting()
				|| p-&gt;is_connecting())
			{
				// this peer is not unchokable. So, if it's unchoked
				// already, make sure to choke it.
				if (p-&gt;is_choked()) continue;
				if (pi &amp;&amp; pi-&gt;optimistically_unchoked)
				{
					pi-&gt;optimistically_unchoked = false;
					// force a new optimistic unchoke
					m_optimistic_unchoke_time_scaler = 0;
<div style="background: #ffff00" width="100%">				}
</div>				t-&gt;choke_peer(*p);
				continue;
			}
			peers.push_back(p.get());
		}

		if (m_settings.choking_algorithm == session_settings::rate_based_choker)
		{
			m_allowed_upload_slots = 0;
			std::sort(peers.begin(), peers.end()
				, boost::bind(&amp;peer_connection::upload_rate_compare, _1, _2));

#ifdef TORRENT_DEBUG
			for (std::vector&lt;peer_connection*&gt;::const_iterator i = peers.begin()
				, end(peers.end()), prev(peers.end()); i != end; ++i)
			{
				if (prev != end)
				{
					boost::shared_ptr&lt;torrent&gt; t1 = (*prev)-&gt;associated_torrent().lock();
					TORRENT_ASSERT(t1);
					boost::shared_ptr&lt;torrent&gt; t2 = (*i)-&gt;associated_torrent().lock();
					TORRENT_ASSERT(t2);
					TORRENT_ASSERT((*prev)-&gt;uploaded_in_last_round() * 1000
						* (1 + t1-&gt;priority()) / total_milliseconds(unchoke_interval)
						&gt;= (*i)-&gt;uploaded_in_last_round() * 1000
						* (1 + t2-&gt;priority()) / total_milliseconds(unchoke_interval));
				}
				prev = i;
			}
#endif
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(42)">../src/session_impl.cpp:4650</a></td><td>make configurable</td></tr><tr id="42" style="display: none;" colspan="3"><td colspan="3"><h2>make configurable</h2><h4>../src/session_impl.cpp:4650</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
#ifdef TORRENT_DEBUG
			for (std::vector&lt;peer_connection*&gt;::const_iterator i = peers.begin()
				, end(peers.end()), prev(peers.end()); i != end; ++i)
			{
				if (prev != end)
				{
					boost::shared_ptr&lt;torrent&gt; t1 = (*prev)-&gt;associated_torrent().lock();
					TORRENT_ASSERT(t1);
					boost::shared_ptr&lt;torrent&gt; t2 = (*i)-&gt;associated_torrent().lock();
					TORRENT_ASSERT(t2);
					TORRENT_ASSERT((*prev)-&gt;uploaded_in_last_round() * 1000
						* (1 + t1-&gt;priority()) / total_milliseconds(unchoke_interval)
						&gt;= (*i)-&gt;uploaded_in_last_round() * 1000
						* (1 + t2-&gt;priority()) / total_milliseconds(unchoke_interval));
				}
				prev = i;
			}
#endif

<div style="background: #ffff00" width="100%">			int rate_threshold = 1024;
</div>
			for (std::vector&lt;peer_connection*&gt;::const_iterator i = peers.begin()
				, end(peers.end()); i != end; ++i)
			{
				peer_connection const&amp; p = **i;
				int rate = int(p.uploaded_in_last_round()
					* 1000 / total_milliseconds(unchoke_interval));

				if (rate &lt; rate_threshold) break;

				++m_allowed_upload_slots;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(43)">../src/session_impl.cpp:4664</a></td><td>make configurable</td></tr><tr id="43" style="display: none;" colspan="3"><td colspan="3"><h2>make configurable</h2><h4>../src/session_impl.cpp:4664</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">						&gt;= (*i)-&gt;uploaded_in_last_round() * 1000
						* (1 + t2-&gt;priority()) / total_milliseconds(unchoke_interval));
				}
				prev = i;
			}
#endif

			int rate_threshold = 1024;

			for (std::vector&lt;peer_connection*&gt;::const_iterator i = peers.begin()
				, end(peers.end()); i != end; ++i)
			{
				peer_connection const&amp; p = **i;
				int rate = int(p.uploaded_in_last_round()
					* 1000 / total_milliseconds(unchoke_interval));

				if (rate &lt; rate_threshold) break;

				++m_allowed_upload_slots;

<div style="background: #ffff00" width="100%">				rate_threshold += 1024;
</div>			}
			// allow one optimistic unchoke
			++m_allowed_upload_slots;
		}

		if (m_settings.choking_algorithm == session_settings::bittyrant_choker)
		{
			// if we're using the bittyrant choker, sort peers by their return
			// on investment. i.e. download rate / upload rate
			std::sort(peers.begin(), peers.end()
				, boost::bind(&amp;peer_connection::bittyrant_unchoke_compare, _1, _2));
		}
		else
		{
			// sorts the peers that are eligible for unchoke by download rate and secondary
			// by total upload. The reason for this is, if all torrents are being seeded,
			// the download rate will be 0, and the peers we have sent the least to should
			// be unchoked
			std::sort(peers.begin(), peers.end()
				, boost::bind(&amp;peer_connection::unchoke_compare, _1, _2));
		}

		// auto unchoke
		int upload_limit = m_bandwidth_channel[peer_connection::upload_channel]-&gt;throttle();
		if (m_settings.choking_algorithm == session_settings::auto_expand_choker
			&amp;&amp; upload_limit &gt; 0)
		{
			// if our current upload rate is less than 90% of our 
			// limit AND most torrents are not "congested", i.e.
			// they are not holding back because of a per-torrent
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(44)">../src/storage.cpp:322</a></td><td>if the read fails, set error and exit immediately</td></tr><tr id="44" style="display: none;" colspan="3"><td colspan="3"><h2>if the read fails, set error and exit immediately</h2><h4>../src/storage.cpp:322</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			if (m_storage-&gt;disk_pool()) block_size = m_storage-&gt;disk_pool()-&gt;block_size();
			int size = slot_size;
			int num_blocks = (size + block_size - 1) / block_size;

			// when we optimize for speed we allocate all the buffers we
			// need for the rest of the piece, and read it all in one call
			// and then hash it. When optimizing for memory usage, we read
			// one block at a time and hash it. This ends up only using a
			// single buffer
			if (m_storage-&gt;settings().optimize_hashing_for_speed)
			{
				file::iovec_t* bufs = TORRENT_ALLOCA(file::iovec_t, num_blocks);
				for (int i = 0; i &lt; num_blocks; ++i)
				{
					bufs[i].iov_base = m_storage-&gt;disk_pool()-&gt;allocate_buffer("hash temp");
					bufs[i].iov_len = (std::min)(block_size, size);
					size -= bufs[i].iov_len;
				}
				// deliberately pass in 0 as flags, to disable random_access
				num_read = m_storage-&gt;readv(bufs, slot, ph.offset, num_blocks, 0);
<div style="background: #ffff00" width="100%">
</div>				for (int i = 0; i &lt; num_blocks; ++i)
				{
					if (small_hash &amp;&amp; small_piece_size &lt;= block_size)
					{
						ph.h.update((char const*)bufs[i].iov_base, small_piece_size);
						*small_hash = hasher(ph.h).final();
						small_hash = 0; // avoid this case again
						if (int(bufs[i].iov_len) &gt; small_piece_size)
							ph.h.update((char const*)bufs[i].iov_base + small_piece_size
								, bufs[i].iov_len - small_piece_size);
					}
					else
					{
						ph.h.update((char const*)bufs[i].iov_base, bufs[i].iov_len);
						small_piece_size -= bufs[i].iov_len;
					}
					ph.offset += bufs[i].iov_len;
					m_storage-&gt;disk_pool()-&gt;free_buffer((char*)bufs[i].iov_base);
				}
			}
			else
			{
				file::iovec_t buf;
				disk_buffer_holder holder(*m_storage-&gt;disk_pool()
					, m_storage-&gt;disk_pool()-&gt;allocate_buffer("hash temp"));
				buf.iov_base = holder.get();
				for (int i = 0; i &lt; num_blocks; ++i)
				{
					buf.iov_len = (std::min)(block_size, size);
					// deliberately pass in 0 as flags, to disable random_access
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(45)">../src/storage.cpp:356</a></td><td>if the read fails, set error and exit immediately</td></tr><tr id="45" style="display: none;" colspan="3"><td colspan="3"><h2>if the read fails, set error and exit immediately</h2><h4>../src/storage.cpp:356</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">					{
						ph.h.update((char const*)bufs[i].iov_base, bufs[i].iov_len);
						small_piece_size -= bufs[i].iov_len;
					}
					ph.offset += bufs[i].iov_len;
					m_storage-&gt;disk_pool()-&gt;free_buffer((char*)bufs[i].iov_base);
				}
			}
			else
			{
				file::iovec_t buf;
				disk_buffer_holder holder(*m_storage-&gt;disk_pool()
					, m_storage-&gt;disk_pool()-&gt;allocate_buffer("hash temp"));
				buf.iov_base = holder.get();
				for (int i = 0; i &lt; num_blocks; ++i)
				{
					buf.iov_len = (std::min)(block_size, size);
					// deliberately pass in 0 as flags, to disable random_access
					int ret = m_storage-&gt;readv(&amp;buf, slot, ph.offset, 1, 0);
					if (ret &gt; 0) num_read += ret;
<div style="background: #ffff00" width="100%">
</div>					if (small_hash &amp;&amp; small_piece_size &lt;= block_size)
					{
						if (small_piece_size &gt; 0) ph.h.update((char const*)buf.iov_base, small_piece_size);
						*small_hash = hasher(ph.h).final();
						small_hash = 0; // avoid this case again
						if (int(buf.iov_len) &gt; small_piece_size)
							ph.h.update((char const*)buf.iov_base + small_piece_size
								, buf.iov_len - small_piece_size);
					}
					else
					{
						ph.h.update((char const*)buf.iov_base, buf.iov_len);
						small_piece_size -= buf.iov_len;
					}

					ph.offset += buf.iov_len;
					size -= buf.iov_len;
				}
			}
			if (error()) return 0;
		}
		return num_read;
	}

	default_storage::default_storage(file_storage const&amp; fs, file_storage const* mapped, std::string const&amp; path
		, file_pool&amp; fp, std::vector&lt;boost::uint8_t&gt; const&amp; file_prio)
		: m_files(fs)
		, m_file_priority(file_prio)
		, m_pool(fp)
		, m_page_size(page_size())
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(46)">../src/storage.cpp:645</a></td><td>make this more generic to not just work if files have been renamed, but also if they have been merged into a single file for instance maybe use the same format as .torrent files and reuse some code from torrent_info</td></tr><tr id="46" style="display: none;" colspan="3"><td colspan="3"><h2>make this more generic to not just work if files have been
renamed, but also if they have been merged into a single file for instance
maybe use the same format as .torrent files and reuse some code from torrent_info</h2><h4>../src/storage.cpp:645</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		for (;;)
		{
			if (file_offset &lt; files().file_size(file_index))
				break;

			file_offset -= files().file_size(file_index);
			++file_index;
			TORRENT_ASSERT(file_index != files().num_files());
		}
	
		error_code ec;
		boost::intrusive_ptr&lt;file&gt; file_handle = open_file(file_index, file::read_only, ec);
		if (!file_handle || ec) return slot;

		size_type data_start = file_handle-&gt;sparse_end(file_offset);
		return int((data_start + files().piece_length() - 1) / files().piece_length());
	}

	bool default_storage::verify_resume_data(lazy_entry const&amp; rd, error_code&amp; error)
	{
<div style="background: #ffff00" width="100%">		lazy_entry const* mapped_files = rd.dict_find_list("mapped_files");
</div>		if (mapped_files &amp;&amp; mapped_files-&gt;list_size() == m_files.num_files())
		{
			m_mapped_files.reset(new file_storage(m_files));
			for (int i = 0; i &lt; m_files.num_files(); ++i)
			{
				std::string new_filename = mapped_files-&gt;list_string_value_at(i);
				if (new_filename.empty()) continue;
				m_mapped_files-&gt;rename_file(i, new_filename);
			}
		}
		
		lazy_entry const* file_priority = rd.dict_find_list("file_priority");
		if (file_priority &amp;&amp; file_priority-&gt;list_size()
			== files().num_files())
		{
			m_file_priority.resize(file_priority-&gt;list_size());
			for (int i = 0; i &lt; file_priority-&gt;list_size(); ++i)
				m_file_priority[i] = boost::uint8_t(file_priority-&gt;list_int_value_at(i, 1));
		}

		std::vector&lt;std::pair&lt;size_type, std::time_t&gt; &gt; file_sizes;
		lazy_entry const* file_sizes_ent = rd.dict_find_list("file sizes");
		if (file_sizes_ent == 0)
		{
			error = errors::missing_file_sizes;
			return false;
		}
		
		for (int i = 0; i &lt; file_sizes_ent-&gt;list_size(); ++i)
		{
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(47)">../src/storage.cpp:1280</a></td><td>what if file_base is used to merge several virtual files into a single physical file? We should probably disable this if file_base is used. This is not a widely used feature though</td></tr><tr id="47" style="display: none;" colspan="3"><td colspan="3"><h2>what if file_base is used to merge several virtual files
into a single physical file? We should probably disable this
if file_base is used. This is not a widely used feature though</h2><h4>../src/storage.cpp:1280</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			int bytes_transferred = 0;
			// if the file is opened in no_buffer mode, and the
			// read is unaligned, we need to fall back on a slow
			// special read that reads aligned buffers and copies
			// it into the one supplied
			size_type adjusted_offset = files().file_base(file_index) + file_offset;
			if ((file_handle-&gt;open_mode() &amp; file::no_buffer)
				&amp;&amp; ((adjusted_offset &amp; (file_handle-&gt;pos_alignment()-1)) != 0
				|| (uintptr_t(tmp_bufs-&gt;iov_base) &amp; (file_handle-&gt;buf_alignment()-1)) != 0))
			{
				bytes_transferred = (int)(this-&gt;*op.unaligned_op)(file_handle, adjusted_offset
					, tmp_bufs, num_tmp_bufs, ec);
				if ((op.mode &amp; file::rw_mask) != file::read_only
					&amp;&amp; adjusted_offset + bytes_transferred &gt;= files().file_size(file_index)
					&amp;&amp; (file_handle-&gt;pos_alignment() &gt; 0 || file_handle-&gt;size_alignment() &gt; 0))
				{
					// we were writing, and we just wrote the last block of the file
					// we likely wrote a bit too much, since we're restricted to
					// a specific alignment for writes. Make sure to truncate the size

<div style="background: #ffff00" width="100%">					file_handle-&gt;set_size(files().file_size(file_index), ec);
</div>				}
			}
			else
			{
				bytes_transferred = (int)((*file_handle).*op.regular_op)(adjusted_offset
					, tmp_bufs, num_tmp_bufs, ec);
				TORRENT_ASSERT(bytes_transferred &lt;= bufs_size(tmp_bufs, num_tmp_bufs));
			}
			file_offset = 0;

			if (ec)
			{
				set_error(files().file_path(file_index, m_save_path), ec);
				return -1;
			}

			if (file_bytes_left != bytes_transferred)
				return bytes_transferred;

			advance_bufs(current_buf, bytes_transferred);
			TORRENT_ASSERT(count_bufs(current_buf, bytes_left - file_bytes_left) &lt;= num_bufs);
		}
		return size;
	}

	// these functions are inefficient, but should be fairly uncommon. The read
	// case happens if unaligned files are opened in no_buffer mode or if clients
	// makes unaligned requests (and the disk cache is disabled or fully utilized
	// for write cache).

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(48)">../src/torrent.cpp:1233</a></td><td>is verify_peer_cert called once per certificate in the chain, and this function just tells us which depth we're at right now? If so, the comment makes sense. any certificate that isn't the leaf (i.e. the one presented by the peer) should be accepted automatically, given preverified is true. The leaf certificate need to be verified to make sure its DN matches the info-hash</td></tr><tr id="48" style="display: none;" colspan="3"><td colspan="3"><h2>is verify_peer_cert called once per certificate in the chain, and
this function just tells us which depth we're at right now? If so, the comment
makes sense.
any certificate that isn't the leaf (i.e. the one presented by the peer)
should be accepted automatically, given preverified is true. The leaf certificate
need to be verified to make sure its DN matches the info-hash</h2><h4>../src/torrent.cpp:1233</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			if (pp) p-&gt;add_extension(pp);
		}

		// if files are checked for this torrent, call the extension
		// to let it initialize itself
		if (m_connections_initialized)
			tp-&gt;on_files_checked();
	}

#endif

#ifdef TORRENT_USE_OPENSSL

#if BOOST_VERSION &gt;= 104700
	bool torrent::verify_peer_cert(bool preverified, boost::asio::ssl::verify_context&amp; ctx)
	{
		// if the cert wasn't signed by the correct CA, fail the verification
		if (!preverified) return false;

		// we're only interested in checking the certificate at the end of the chain.
<div style="background: #ffff00" width="100%">		int depth = X509_STORE_CTX_get_error_depth(ctx.native_handle());
</div>		if (depth &gt; 0) return true;

		X509* cert = X509_STORE_CTX_get_current_cert(ctx.native_handle());

		// Go through the alternate names in the certificate looking for matching DNS entries
		GENERAL_NAMES* gens = static_cast&lt;GENERAL_NAMES*&gt;(
			X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0));

#if defined(TORRENT_VERBOSE_LOGGING) || defined(TORRENT_LOGGING)
		std::string names;
		bool match = false;
#endif
		for (int i = 0; i &lt; sk_GENERAL_NAME_num(gens); ++i)
		{
			GENERAL_NAME* gen = sk_GENERAL_NAME_value(gens, i);
			if (gen-&gt;type != GEN_DNS) continue;
			ASN1_IA5STRING* domain = gen-&gt;d.dNSName;
			if (domain-&gt;type != V_ASN1_IA5STRING || !domain-&gt;data || !domain-&gt;length) continue;
			const char* torrent_name = reinterpret_cast&lt;const char*&gt;(domain-&gt;data);
			std::size_t name_length = domain-&gt;length;

#if defined(TORRENT_VERBOSE_LOGGING) || defined(TORRENT_LOGGING)
			if (i &gt; 1) names += " | n: ";
			names.append(torrent_name, name_length);
#endif
			if (strncmp(torrent_name, "*", name_length) == 0
				|| strncmp(torrent_name, m_torrent_file-&gt;name().c_str(), name_length) == 0)
			{
#if defined(TORRENT_VERBOSE_LOGGING) || defined(TORRENT_LOGGING)
				match = true;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(49)">../src/torrent.cpp:5236</a></td><td>make this more generic to not just work if files have been renamed, but also if they have been merged into a single file for instance maybe use the same format as .torrent files and reuse some code from torrent_info The mapped_files needs to be read both in the network thread and in the disk thread, since they both have their own mapped files structures which are kept in sync</td></tr><tr id="49" style="display: none;" colspan="3"><td colspan="3"><h2>make this more generic to not just work if files have been
renamed, but also if they have been merged into a single file for instance
maybe use the same format as .torrent files and reuse some code from torrent_info
The mapped_files needs to be read both in the network thread
and in the disk thread, since they both have their own mapped files structures
which are kept in sync</h2><h4>../src/torrent.cpp:5236</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		if (!m_use_resume_save_path)
		{
			std::string p = rd.dict_find_string_value("save_path");
			if (!p.empty()) m_save_path = p;
		}

		m_url = rd.dict_find_string_value("url");
		m_uuid = rd.dict_find_string_value("uuid");
		m_source_feed_url = rd.dict_find_string_value("feed");

		if (!m_uuid.empty() || !m_url.empty())
		{
			boost::shared_ptr&lt;torrent&gt; me(shared_from_this());

			// insert this torrent in the uuid index
			m_ses.m_uuids.insert(std::make_pair(m_uuid.empty()
				? m_url : m_uuid, me));
		}

<div style="background: #ffff00" width="100%">		lazy_entry const* mapped_files = rd.dict_find_list("mapped_files");
</div>		if (mapped_files &amp;&amp; mapped_files-&gt;list_size() == m_torrent_file-&gt;num_files())
		{
			for (int i = 0; i &lt; m_torrent_file-&gt;num_files(); ++i)
			{
				std::string new_filename = mapped_files-&gt;list_string_value_at(i);
				if (new_filename.empty()) continue;
				m_torrent_file-&gt;rename_file(i, new_filename);
			}
		}
		
		m_added_time = rd.dict_find_int_value("added_time", m_added_time);
		m_completed_time = rd.dict_find_int_value("completed_time", m_completed_time);
		if (m_completed_time != 0 &amp;&amp; m_completed_time &lt; m_added_time)
			m_completed_time = m_added_time;

		lazy_entry const* file_priority = rd.dict_find_list("file_priority");
		if (file_priority &amp;&amp; file_priority-&gt;list_size()
			== m_torrent_file-&gt;num_files())
		{
			for (int i = 0; i &lt; file_priority-&gt;list_size(); ++i)
				m_file_priority[i] = file_priority-&gt;list_int_value_at(i, 1);
			update_piece_priorities();
		}

		lazy_entry const* piece_priority = rd.dict_find_string("piece_priority");
		if (piece_priority &amp;&amp; piece_priority-&gt;string_length()
			== m_torrent_file-&gt;num_pieces())
		{
			char const* p = piece_priority-&gt;string_ptr();
			for (int i = 0; i &lt; piece_priority-&gt;string_length(); ++i)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(50)">../src/torrent.cpp:5372</a></td><td>if this is a merkle torrent and we can't restore the tree, we need to wipe all the bits in the have array, but not necessarily we might want to do a full check to see if we have all the pieces. This is low priority since almost no one uses merkle torrents</td></tr><tr id="50" style="display: none;" colspan="3"><td colspan="3"><h2>if this is a merkle torrent and we can't
restore the tree, we need to wipe all the
bits in the have array, but not necessarily
we might want to do a full check to see if we have
all the pieces. This is low priority since almost
no one uses merkle torrents</h2><h4>../src/torrent.cpp:5372</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				add_web_seed(url, web_seed_entry::http_seed);
			}
		}

		if (m_torrent_file-&gt;is_merkle_torrent())
		{
			lazy_entry const* mt = rd.dict_find_string("merkle tree");
			if (mt)
			{
				std::vector&lt;sha1_hash&gt; tree;
				tree.resize(m_torrent_file-&gt;merkle_tree().size());
				std::memcpy(&amp;tree[0], mt-&gt;string_ptr()
					, (std::min)(mt-&gt;string_length(), int(tree.size()) * 20));
				if (mt-&gt;string_length() &lt; int(tree.size()) * 20)
					std::memset(&amp;tree[0] + mt-&gt;string_length() / 20, 0
						, tree.size() - mt-&gt;string_length() / 20);
				m_torrent_file-&gt;set_merkle_tree(tree);
			}
			else
			{
<div style="background: #ffff00" width="100%">				TORRENT_ASSERT(false);
</div>			}
		}
	}

	boost::intrusive_ptr&lt;torrent_info const&gt; torrent::get_torrent_copy()
	{
		if (!m_torrent_file-&gt;is_valid()) return boost::intrusive_ptr&lt;torrent_info&gt;();

		// copy the torrent_info object
		return boost::intrusive_ptr&lt;torrent_info&gt;(new torrent_info(*m_torrent_file));
	}
	
	void torrent::write_resume_data(entry&amp; ret) const
	{
		using namespace libtorrent::detail; // for write_*_endpoint()
		ret["file-format"] = "libtorrent resume file";
		ret["file-version"] = 1;
		ret["libtorrent-version"] = LIBTORRENT_VERSION;

		ret["total_uploaded"] = m_total_uploaded;
		ret["total_downloaded"] = m_total_downloaded;

		ret["active_time"] = m_active_time;
		ret["finished_time"] = m_finished_time;
		ret["seeding_time"] = m_seeding_time;
		ret["last_seen_complete"] = m_last_seen_complete;

		ret["num_complete"] = m_complete;
		ret["num_incomplete"] = m_incomplete;
		ret["num_downloaded"] = m_downloaded;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(51)">../src/torrent.cpp:5562</a></td><td>make this more generic to not just work if files have been renamed, but also if they have been merged into a single file for instance. using file_base</td></tr><tr id="51" style="display: none;" colspan="3"><td colspan="3"><h2>make this more generic to not just work if files have been
renamed, but also if they have been merged into a single file for instance.
using file_base</h2><h4>../src/torrent.cpp:5562</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		entry::string_type&amp; pieces = ret["pieces"].string();
		pieces.resize(m_torrent_file-&gt;num_pieces());
		if (is_seed())
		{
			std::memset(&amp;pieces[0], 1, pieces.size());
		}
		else
		{
			for (int i = 0, end(pieces.size()); i &lt; end; ++i)
				pieces[i] = m_picker-&gt;have_piece(i) ? 1 : 0;
		}

		if (m_seed_mode)
		{
			TORRENT_ASSERT(m_verified.size() == pieces.size());
			for (int i = 0, end(pieces.size()); i &lt; end; ++i)
				pieces[i] |= m_verified[i] ? 2 : 0;
		}

		// write renamed files
<div style="background: #ffff00" width="100%">		if (&amp;m_torrent_file-&gt;files() != &amp;m_torrent_file-&gt;orig_files()
</div>			&amp;&amp; m_torrent_file-&gt;files().num_files() == m_torrent_file-&gt;orig_files().num_files())
		{
			entry::list_type&amp; fl = ret["mapped_files"].list();
			file_storage const&amp; fs = m_torrent_file-&gt;files();
			for (int i = 0; i &lt; fs.num_files(); ++i)
			{
				fl.push_back(fs.file_path(i));
			}
		}

		// write local peers

		std::back_insert_iterator&lt;entry::string_type&gt; peers(ret["peers"].string());
		std::back_insert_iterator&lt;entry::string_type&gt; banned_peers(ret["banned_peers"].string());
#if TORRENT_USE_IPV6
		std::back_insert_iterator&lt;entry::string_type&gt; peers6(ret["peers6"].string());
		std::back_insert_iterator&lt;entry::string_type&gt; banned_peers6(ret["banned_peers6"].string());
#endif

		// failcount is a 5 bit value
		int max_failcount = (std::min)(settings().max_failcount, 31);

		int num_saved_peers = 0;

		for (policy::const_iterator i = m_policy.begin_peer()
			, end(m_policy.end_peer()); i != end; ++i)
		{
			error_code ec;
			policy::peer const* p = *i;
			address addr = p-&gt;address();
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(52)">../src/torrent.cpp:8176</a></td><td>go through the pieces we have and count the total number of downloaders we have. Only count peers that are interested in us since some peers might not send have messages for pieces we have it num_interested == 0, we need to pick a new piece</td></tr><tr id="52" style="display: none;" colspan="3"><td colspan="3"><h2>go through the pieces we have and count the total number
of downloaders we have. Only count peers that are interested in us
since some peers might not send have messages for pieces we have
it num_interested == 0, we need to pick a new piece</h2><h4>../src/torrent.cpp:8176</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			}

			rarest_pieces.clear();
			rarest_rarity = pp.peer_count;
			rarest_pieces.push_back(i);
		}

		if (prio_updated)
			m_policy.recalculate_connect_candidates();

		// now, rarest_pieces is a list of all pieces that are the rarest ones.
		// and rarest_rarity is the number of peers that have the rarest pieces

		// if there's only a single peer that doesn't have the rarest piece
		// it's impossible for us to download one piece and upload it
		// twice. i.e. we cannot get a positive share ratio
		if (num_peers - rarest_rarity &lt; settings().share_mode_target) return;

		// we might be able to do better than a share ratio of 2 if there are
		// enough downloaders of the pieces we already have.
<div style="background: #ffff00" width="100%">
</div>		// now, pick one of the rarest pieces to download
		int pick = random() % rarest_pieces.size();
		bool was_finished = is_finished();
		m_picker-&gt;set_piece_priority(rarest_pieces[pick], 1);
		update_peer_interest(was_finished);

		m_policy.recalculate_connect_candidates();
	}

	void torrent::refresh_explicit_cache(int cache_size)
	{
		TORRENT_ASSERT(m_ses.is_network_thread());
		if (!ready_for_connections()) return;

		if (m_abort) return;
		TORRENT_ASSERT(m_storage);

		// rotate the cached pieces

		// add blocks_per_piece / 2 in order to round to closest whole piece
		int blocks_per_piece = m_torrent_file-&gt;piece_length() / block_size();
		int num_cache_pieces = (cache_size + blocks_per_piece / 2) / blocks_per_piece;
		if (num_cache_pieces &gt; m_torrent_file-&gt;num_pieces())
			num_cache_pieces = m_torrent_file-&gt;num_pieces();

		std::vector&lt;int&gt; avail_vec;
		if (has_picker())
		{
			m_picker-&gt;get_availability(avail_vec);
		}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(53)">../src/torrent.cpp:8821</a></td><td>instead of resorting the whole list, insert the peers directly into the right place</td></tr><tr id="53" style="display: none;" colspan="3"><td colspan="3"><h2>instead of resorting the whole list, insert the peers
directly into the right place</h2><h4>../src/torrent.cpp:8821</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				printf("timed out [average-piece-time: %d ms ]\n"
					, m_average_piece_time);
#endif
			}

			// pick all blocks for this piece. the peers list is kept up to date
			// and sorted. when we issue a request to a peer, its download queue
			// time will increase and it may need to be bumped in the peers list,
			// since it's ordered by download queue time
			pick_time_critical_block(peers, ignore_peers
				, peers_with_requests
				, pi, &amp;*i, m_picker.get()
				, blocks_in_piece, timed_out);

			// put back the peers we ignored into the peer list for the next piece
			if (!ignore_peers.empty())
			{
				peers.insert(peers.begin(), ignore_peers.begin(), ignore_peers.end());
				ignore_peers.clear();

<div style="background: #ffff00" width="100%">				std::sort(peers.begin(), peers.end()
</div>					, boost::bind(&amp;peer_connection::download_queue_time, _1, 16*1024)
					&lt; boost::bind(&amp;peer_connection::download_queue_time, _2, 16*1024));
			}

			// if this peer's download time exceeds 2 seconds, we're done.
			// We don't want to build unreasonably long request queues
			if (!peers.empty() &amp;&amp; peers[0]-&gt;download_queue_time() &gt; milliseconds(2000))
				break;
		}

		// commit all the time critical requests
		for (std::set&lt;peer_connection*&gt;::iterator i = peers_with_requests.begin()
			, end(peers_with_requests.end()); i != end; ++i)
		{
			(*i)-&gt;send_block_requests();
		}
	}

	std::set&lt;std::string&gt; torrent::web_seeds(web_seed_entry::type_t type) const
	{
		TORRENT_ASSERT(m_ses.is_network_thread());
		std::set&lt;std::string&gt; ret;
		for (std::list&lt;web_seed_entry&gt;::const_iterator i = m_web_seeds.begin()
			, end(m_web_seeds.end()); i != end; ++i)
		{
			if (i-&gt;peer_info.banned) continue;
			if (i-&gt;type != type) continue;
			ret.insert(i-&gt;url);
		}
		return ret;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(54)">../src/udp_socket.cpp:292</a></td><td>it would be nice to detect this on posix systems also</td></tr><tr id="54" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to detect this on posix systems also</h2><h4>../src/udp_socket.cpp:292</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		--m_v6_outstanding;
	}
	else
#endif
	{
		TORRENT_ASSERT(m_v4_outstanding &gt; 0);
		--m_v4_outstanding;
	}

	if (ec == asio::error::operation_aborted) return;
	if (m_abort) return;

	CHECK_MAGIC;

	for (;;)
	{
		error_code ec;
		udp::endpoint ep;
		size_t bytes_transferred = s-&gt;receive_from(asio::buffer(m_buf, m_buf_size), ep, 0, ec);

<div style="background: #ffff00" width="100%">#ifdef TORRENT_WINDOWS
</div>		if ((ec == error_code(ERROR_MORE_DATA, get_system_category())
			|| ec == error_code(WSAEMSGSIZE, get_system_category()))
			&amp;&amp; m_buf_size &lt; 65536)
		{
			// if this function fails to allocate memory, m_buf_size
			// is set to 0. In that case, don't issue the async_read().
			set_buf_size(m_buf_size * 2);
			if (m_buf_size == 0) return;
			continue;
		}
#endif

		if (ec == asio::error::would_block || ec == asio::error::try_again) break;
		on_read_impl(s, ep, ec, bytes_transferred);
	}
	call_drained_handler();
	setup_read(s);
}

void udp_socket::call_handler(error_code const&amp; ec, udp::endpoint const&amp; ep, char const* buf, int size)
{
	m_observers_locked = true;
	for (std::vector&lt;udp_socket_observer*&gt;::iterator i = m_observers.begin();
		i != m_observers.end();)
	{
		bool ret = false;
		TORRENT_TRY {
			ret = (*i)-&gt;incoming_packet(ec, ep, buf, size);
		} TORRENT_CATCH (std::exception&amp;) {}
		if (*i == NULL) i = m_observers.erase(i);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(55)">../src/udp_tracker_connection.cpp:548</a></td><td>it would be more efficient to not use a string here. however, the problem is that some trackers will respond with actual strings. For example i2p trackers</td></tr><tr id="55" style="display: none;" colspan="3"><td colspan="3"><h2>it would be more efficient to not use a string here.
however, the problem is that some trackers will respond
with actual strings. For example i2p trackers</h2><h4>../src/udp_tracker_connection.cpp:548</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		}

		boost::shared_ptr&lt;request_callback&gt; cb = requester();
#if defined TORRENT_VERBOSE_LOGGING || defined TORRENT_LOGGING
		if (cb)
		{
			boost::shared_ptr&lt;request_callback&gt; cb = requester();
			cb-&gt;debug_log("&lt;== UDP_TRACKER_RESPONSE [ url: %s ]", tracker_req().url.c_str());
		}
#endif

		if (!cb)
		{
			close();
			return true;
		}

		std::vector&lt;peer_entry&gt; peer_list;
		for (int i = 0; i &lt; num_peers; ++i)
		{
<div style="background: #ffff00" width="100%">			peer_entry e;
</div>			char ip_string[100];
			unsigned int a = detail::read_uint8(buf);
			unsigned int b = detail::read_uint8(buf);
			unsigned int c = detail::read_uint8(buf);
			unsigned int d = detail::read_uint8(buf);
			snprintf(ip_string, 100, "%u.%u.%u.%u", a, b, c, d);
			e.ip = ip_string;
			e.port = detail::read_uint16(buf);
			e.pid.clear();
			peer_list.push_back(e);
		}

		std::list&lt;address&gt; ip_list;
		for (std::list&lt;tcp::endpoint&gt;::const_iterator i = m_endpoints.begin()
			, end(m_endpoints.end()); i != end; ++i)
		{
			ip_list.push_back(i-&gt;address());
		}

		cb-&gt;tracker_response(tracker_req(), m_target.address(), ip_list
			, peer_list, interval, min_interval, complete, incomplete, 0, address(), "" /*trackerid*/);

		close();
		return true;
	}

	bool udp_tracker_connection::on_scrape_response(char const* buf, int size)
	{
		restart_read_timeout();
		int action = detail::read_int32(buf);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(56)">../src/upnp.cpp:63</a></td><td>listen_interface is not used. It's meant to bind the broadcast socket</td></tr><tr id="56" style="display: none;" colspan="3"><td colspan="3"><h2>listen_interface is not used. It's meant to bind the broadcast socket</h2><h4>../src/upnp.cpp:63</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
#if defined TORRENT_ASIO_DEBUGGING
#include "libtorrent/debug.hpp"
#endif

#include &lt;boost/bind.hpp&gt;
#include &lt;boost/ref.hpp&gt;
#if BOOST_VERSION &lt; 103500
#include &lt;asio/ip/host_name.hpp&gt;
#include &lt;asio/ip/multicast.hpp&gt;
#else
#include &lt;boost/asio/ip/host_name.hpp&gt;
#include &lt;boost/asio/ip/multicast.hpp&gt;
#endif
#include &lt;cstdlib&gt;

namespace libtorrent {

static error_code ec;

<div style="background: #ffff00" width="100%">upnp::upnp(io_service&amp; ios, connection_queue&amp; cc
</div>	, address const&amp; listen_interface, std::string const&amp; user_agent
	, portmap_callback_t const&amp; cb, log_callback_t const&amp; lcb
	, bool ignore_nonrouters, void* state)
	: m_user_agent(user_agent)
	, m_callback(cb)
	, m_log_callback(lcb)
	, m_retry_count(0)
	, m_io_service(ios)
	, m_socket(udp::endpoint(address_v4::from_string("239.255.255.250", ec), 1900)
		, boost::bind(&amp;upnp::on_reply, self(), _1, _2, _3))
	, m_broadcast_timer(ios)
	, m_refresh_timer(ios)
	, m_map_timer(ios)
	, m_disabled(false)
	, m_closing(false)
	, m_ignore_non_routers(ignore_nonrouters)
	, m_cc(cc)
{
	TORRENT_ASSERT(cb);

	error_code ec;
	m_socket.open(ios, ec);

	if (state)
	{
		upnp_state_t* s = (upnp_state_t*)state;
		m_devices.swap(s-&gt;devices);
		m_mappings.swap(s-&gt;mappings);
		delete s;
	}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(57)">../src/utp_stream.cpp:1606</a></td><td>this loop may not be very efficient</td></tr><tr id="57" style="display: none;" colspan="3"><td colspan="3"><h2>this loop may not be very efficient</h2><h4>../src/utp_stream.cpp:1606</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	char* m_buf;
};

// sends a packet, pulls data from the write buffer (if there's any)
// if ack is true, we need to send a packet regardless of if there's
// any data. Returns true if we could send more data (i.e. call
// send_pkt() again)
// returns true if there is more space for payload in our
// congestion window, false if there is no more space.
bool utp_socket_impl::send_pkt(int flags)
{
	INVARIANT_CHECK;

	bool force = (flags &amp; pkt_ack) || (flags &amp; pkt_fin);

//	TORRENT_ASSERT(m_state != UTP_STATE_FIN_SENT || (flags &amp; pkt_ack));

	// first see if we need to resend any packets

<div style="background: #ffff00" width="100%">	for (int i = (m_acked_seq_nr + 1) &amp; ACK_MASK; i != m_seq_nr; i = (i + 1) &amp; ACK_MASK)
</div>	{
		packet* p = (packet*)m_outbuf.at(i);
		if (!p) continue;
		if (!p-&gt;need_resend) continue;
		if (!resend_packet(p))
		{
			// we couldn't resend the packet. It probably doesn't
			// fit in our cwnd. If force is set, we need to continue
			// to send our packet anyway, if we don't have force set,
			// we might as well return
			if (!force) return false;
			// resend_packet might have failed
			if (m_state == UTP_STATE_ERROR_WAIT || m_state == UTP_STATE_DELETE) return false;
			break;
		}

		// don't fast-resend this packet
		if (m_fast_resend_seq_nr == i)
			m_fast_resend_seq_nr = (m_fast_resend_seq_nr + 1) &amp; ACK_MASK;
	}

	int sack = 0;
	if (m_inbuf.size())
	{
		// the SACK bitfield should ideally fit all
		// the pieces we have successfully received
		sack = (m_inbuf.span() + 7) / 8;
		if (sack &gt; 32) sack = 32;
	}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(58)">../src/kademlia/dht_tracker.cpp:426</a></td><td>ideally this function would be called when the put completes</td></tr><tr id="58" style="display: none;" colspan="3"><td colspan="3"><h2>ideally this function would be called when the
put completes</h2><h4>../src/kademlia/dht_tracker.cpp:426</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// since it controls whether we re-put the content
		TORRENT_ASSERT(!it.is_mutable());
		f(it);
		return false;
	}

	bool get_mutable_item_callback(item&amp; it, boost::function&lt;void(item const&amp;)&gt; f)
	{
		// the reason to wrap here is to control the return value
		// since it controls whether we re-put the content
		TORRENT_ASSERT(it.is_mutable());
		f(it);
		return false;
	}

	bool put_immutable_item_callback(item&amp; it, boost::function&lt;void()&gt; f
		, entry data)
	{
		TORRENT_ASSERT(!it.is_mutable());
		it.assign(data);
<div style="background: #ffff00" width="100%">		f();
</div>		return true;
	}

	bool put_mutable_item_callback(item&amp; it, boost::function&lt;void(item&amp;)&gt; cb)
	{
		cb(it);
		return true;
	}

	void dht_tracker::get_item(sha1_hash const&amp; target
		, boost::function&lt;void(item const&amp;)&gt; cb)
	{
		m_dht.get_item(target, boost::bind(&amp;get_immutable_item_callback, _1, cb));
	}

	// key is a 32-byte binary string, the public key to look up.
	// the salt is optional
	void dht_tracker::get_item(char const* key
		, boost::function&lt;void(item const&amp;)&gt; cb
		, std::string salt)
	{
		m_dht.get_item(key, salt, boost::bind(&amp;get_mutable_item_callback, _1, cb));
	}

	void dht_tracker::put_item(entry data
		, boost::function&lt;void()&gt; cb)
	{
		std::string flat_data;
		bencode(std::back_inserter(flat_data), data);
		sha1_hash target = item_target_id(
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(59)">../src/kademlia/routing_table.cpp:291</a></td><td>instad of refreshing a bucket by using find_nodes, ping each node periodically</td></tr><tr id="59" style="display: none;" colspan="3"><td colspan="3"><h2>instad of refreshing a bucket by using find_nodes,
ping each node periodically</h2><h4>../src/kademlia/routing_table.cpp:291</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		os &lt;&lt; "]\n";
	}
}

#endif

void routing_table::touch_bucket(node_id const&amp; target)
{
	table_t::iterator i = find_bucket(target);
	i-&gt;last_active = time_now();
}

// returns true if lhs is in more need of a refresh than rhs
bool compare_bucket_refresh(routing_table_node const&amp; lhs, routing_table_node const&amp; rhs)
{
	// add the number of nodes to prioritize buckets with few nodes in them
	return lhs.last_active + seconds(lhs.live_nodes.size() * 5)
		&lt; rhs.last_active + seconds(rhs.live_nodes.size() * 5);
}

<div style="background: #ffff00" width="100%">bool routing_table::need_refresh(node_id&amp; target) const
</div>{
	INVARIANT_CHECK;

	ptime now = time_now();

	// refresh our own bucket once every 15 minutes
	if (now - m_last_self_refresh &gt; minutes(15))
	{
		m_last_self_refresh = now;
		target = m_id;
#ifdef TORRENT_DHT_VERBOSE_LOGGING
		TORRENT_LOG(table) &lt;&lt; "need_refresh [ bucket: self target: " &lt;&lt; target &lt;&lt; " ]";
#endif
		return true;
	}

	if (m_buckets.empty()) return false;

	table_t::const_iterator i = std::min_element(m_buckets.begin(), m_buckets.end()
		, &amp;compare_bucket_refresh);

	if (now - i-&gt;last_active &lt; minutes(15)) return false;
	if (now - m_last_refresh &lt; seconds(45)) return false;

	// generate a random node_id within the given bucket
	target = generate_random_id();
	int num_bits = std::distance(m_buckets.begin(), i) + 1;
	node_id mask = generate_prefix_mask(num_bits);

	// target = (target &amp; ~mask) | (root &amp; mask)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(60)">../include/libtorrent/config.hpp:333</a></td><td>Make this count Unicode characters instead of bytes on windows</td></tr><tr id="60" style="display: none;" colspan="3"><td colspan="3"><h2>Make this count Unicode characters instead of bytes on windows</h2><h4>../include/libtorrent/config.hpp:333</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
// ==== eCS(OS/2) ===
#elif defined __OS2__
#define TORRENT_OS2
#define TORRENT_HAS_FALLOCATE 0
#define TORRENT_USE_IFCONF 1
#define TORRENT_USE_SYSCTL 1
#define TORRENT_USE_MLOCK 0
#define TORRENT_USE_IPV6 0
#define TORRENT_ICONV_ARG (const char**)
#define TORRENT_USE_WRITEV 0
#define TORRENT_USE_READV 0

#else
#warning unknown OS, assuming BSD
#define TORRENT_BSD
#endif

// on windows, NAME_MAX refers to Unicode characters
// on linux it refers to bytes (utf-8 encoded)
<div style="background: #ffff00" width="100%">
</div>// windows
#if defined FILENAME_MAX
#define TORRENT_MAX_PATH FILENAME_MAX

// beos
#elif defined B_PATH_NAME_LENGTH
#define TORRENT_MAX_PATH B_PATH_NAME_LENGTH

// solaris
#elif defined MAXPATH
#define TORRENT_MAX_PATH MAXPATH

// posix
#elif defined NAME_MAX
#define TORRENT_MAX_PATH NAME_MAX

// none of the above
#else
// this is the maximum number of characters in a
// path element / filename on windows
#define TORRENT_MAX_PATH 255
#warning unknown platform, assuming the longest path is 255

#endif

#if defined TORRENT_WINDOWS &amp;&amp; !defined TORRENT_MINGW

#include &lt;stdarg.h&gt;

// internal
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(61)">../include/libtorrent/peer_connection.hpp:725</a></td><td>make this private</td></tr><tr id="61" style="display: none;" colspan="3"><td colspan="3"><h2>make this private</h2><h4>../include/libtorrent/peer_connection.hpp:725</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		void set_soft_packet_size(int size) { m_soft_packet_size = size; }

		// if allow_encrypted is false, and the torrent 'ih' turns out
		// to be an encrypted torrent (AES-256 encrypted) the peer will
		// be disconnected. This is to prevent non-encrypted peers to
		// attach to an encrypted torrent
		void attach_to_torrent(sha1_hash const&amp; ih, bool allow_encrypted);

		bool verify_piece(peer_request const&amp; p) const;

		void update_desired_queue_size();

		void set_timeout(int s) { m_timeout = s; }

		boost::intrusive_ptr&lt;peer_connection&gt; self()
		{
			TORRENT_ASSERT(!m_in_constructor);
			return boost::intrusive_ptr&lt;peer_connection&gt;(this);
		}

<div style="background: #ffff00" width="100%">	public:
</div>
		// upload and download channel state
		// enum from peer_info::bw_state
		boost::uint8_t m_channel_state[2];

	private:

		// is true if we learn the incoming connections listening
		// during the extended handshake
		bool m_received_listen_port:1;

		// this is set to true when a have_all
		// message is received. This information
		// is used to fill the bitmask in init()
		bool m_have_all:1;

		// other side says that it's interested in downloading
		// from us.
		bool m_peer_interested:1;

		// the other side has told us that it won't send anymore
		// data to us for a while
		bool m_peer_choked:1;

		// the peer has pieces we are interested in
		bool m_interesting:1;

		// we have choked the upload to the peer
		bool m_choked:1;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(62)">../include/libtorrent/peer_connection.hpp:806</a></td><td>make these private as well</td></tr><tr id="62" style="display: none;" colspan="3"><td colspan="3"><h2>make these private as well</h2><h4>../include/libtorrent/peer_connection.hpp:806</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// when this is set, the peer_connection socket is
		// corked, similar to the linux TCP feature TCP_CORK.
		// we won't send anything to the actual socket, just
		// buffer messages up in the application layer send
		// buffer, and send it once we're uncorked.
		bool m_corked:1;

		// set to true if this peer has metadata, and false
		// otherwise.
		bool m_has_metadata:1;

		// this is set to true if this peer was accepted exceeding
		// the connection limit. It means it has to disconnect
		// itself, or some other peer, as soon as it's completed
		// the handshake. We need to wait for the handshake in
		// order to know which torrent it belongs to, to know which
		// other peers to compare it to.
		bool m_exceeded_limit:1;

<div style="background: #ffff00" width="100%">	protected:
</div>
		// number of bytes this peer can send and receive
		int m_quota[2];

		// statistics about upload and download speeds
		// and total amount of uploads and downloads for
		// this peer
		stat m_statistics;

		// a back reference to the session
		// the peer belongs to.
		aux::session_impl&amp; m_ses;

#ifndef TORRENT_DISABLE_EXTENSIONS
		typedef std::list&lt;boost::shared_ptr&lt;peer_plugin&gt; &gt; extension_list_t;
		extension_list_t m_extensions;
#endif

		// called from the main loop when this connection has any
		// work to do.
		void on_send_data(error_code const&amp; error
			, std::size_t bytes_transferred);
		void on_receive_data(error_code const&amp; error
			, std::size_t bytes_transferred);

		// the average rate of receiving complete piece messages
		sliding_average&lt;20&gt; m_piece_rate;
		sliding_average&lt;20&gt; m_send_rate;

	private:
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(63)">../include/libtorrent/proxy_base.hpp:166</a></td><td>it would be nice to remember the bind port and bind once we know where the proxy is m_sock.bind(endpoint, ec);</td></tr><tr id="63" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to remember the bind port and bind once we know where the proxy is
m_sock.bind(endpoint, ec);</h2><h4>../include/libtorrent/proxy_base.hpp:166</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{
		return m_sock.get_option(opt, ec);
	}

#ifndef BOOST_NO_EXCEPTIONS
	void bind(endpoint_type const&amp; endpoint)
	{
//		m_sock.bind(endpoint);
	}
#endif

	void bind(endpoint_type const&amp; endpoint, error_code&amp; ec)
	{
		// the reason why we ignore binds here is because we don't
		// (necessarily) yet know what address family the proxy
		// will resolve to, and binding to the wrong one would
		// break our connection attempt later. The caller here
		// doesn't necessarily know that we're proxying, so this
		// bind address is based on the final endpoint, not the
		// proxy.
<div style="background: #ffff00" width="100%">	}
</div>
#ifndef BOOST_NO_EXCEPTIONS
	void open(protocol_type const&amp; p)
	{
//		m_sock.open(p);
	}
#endif

	void open(protocol_type const&amp; p, error_code&amp; ec)
	{
		// we need to ignore this for the same reason as stated
		// for ignoring bind()
//		m_sock.open(p, ec);
	}

#ifndef BOOST_NO_EXCEPTIONS
	void close()
	{
		m_remote_endpoint = endpoint_type();
		m_sock.close();
		m_resolver.cancel();
	}
#endif

	void close(error_code&amp; ec)
	{
		m_remote_endpoint = endpoint_type();
		m_sock.close(ec);
		m_resolver.cancel();
	}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(64)">../include/libtorrent/stat.hpp:113</a></td><td>this is 4 bytes of padding!</td></tr><tr id="64" style="display: none;" colspan="3"><td colspan="3"><h2>this is 4 bytes of padding!</h2><h4>../include/libtorrent/stat.hpp:113</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		int counter() const { return m_counter; }

		void clear()
		{
			m_counter = 0;
			m_5_sec_average = 0;
			m_30_sec_average = 0;
			m_total_counter = 0;
		}

	private:

		// the accumulator for this second.
		int m_counter;

		// sliding average
		int m_5_sec_average;
		int m_30_sec_average;

<div style="background: #ffff00" width="100%">
</div>		// total counters
		size_type m_total_counter;
	};

	class TORRENT_EXTRA_EXPORT stat
	{
	friend class invariant_access;
	public:
		void operator+=(const stat&amp; s)
		{
			for (int i = 0; i &lt; num_channels; ++i)
				m_stat[i] += s.m_stat[i];
		}

		void sent_syn(bool ipv6)
		{
#ifndef TORRENT_DISABLE_FULL_STATS
			m_stat[upload_ip_protocol].add(ipv6 ? 60 : 40);
#endif
		}

		void received_synack(bool ipv6)
		{
#ifndef TORRENT_DISABLE_FULL_STATS
			// we received SYN-ACK and also sent ACK back
			m_stat[download_ip_protocol].add(ipv6 ? 60 : 40);
			m_stat[upload_ip_protocol].add(ipv6 ? 60 : 40);
#endif
		}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(65)">../include/libtorrent/torrent_info.hpp:123</a></td><td>include the number of peers received from this tracker, at last announce</td></tr><tr id="65" style="display: none;" colspan="3"><td colspan="3"><h2>include the number of peers received from this tracker, at last announce</h2><h4>../include/libtorrent/torrent_info.hpp:123</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// if this tracker failed the last time it was contacted
		// this error code specifies what error occurred
		error_code last_error;

		// returns the number of seconds to the next announce on
		// this tracker. ``min_announce_in()`` returns the number of seconds until we are
		// allowed to force another tracker update with this tracker.
		// 
		// If the last time this tracker was contacted failed, ``last_error`` is the error
		// code describing what error occurred.
		int next_announce_in() const;
		int min_announce_in() const;

		// the time of next tracker announce
		ptime next_announce;

		// no announces before this time
		ptime min_announce;

<div style="background: #ffff00" width="100%">
</div>		// these are either -1 or the scrape information this tracker last responded with. *incomplete* is
		// the current number of downloaders in the swarm, *complete* is the current number
		// of seeds in the swarm and *downloaded* is the cumulative number of completed
		// downloads of this torrent, since the beginning of time (from this tracker's point
		// of view).

		// if this tracker has returned scrape data, these fields are filled
		// in with valid numbers. Otherwise they are set to -1.
		// the number of current downloaders
		int scrape_incomplete;
		int scrape_complete;
		int scrape_downloaded;

		// the tier this tracker belongs to
		boost::uint8_t tier;

		// the max number of failures to announce to this tracker in
		// a row, before this tracker is not used anymore. 0 means unlimited
		boost::uint8_t fail_limit;

		// the number of times in a row we have failed to announce to this
		// tracker.
		boost::uint8_t fails:7;

		// true while we're waiting for a response from the tracker.
		bool updating:1;

		// flags for the source bitmask, each indicating where
		// we heard about this tracker
		enum tracker_source
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(66)">../include/libtorrent/upnp.hpp:108</a></td><td>support using the windows API for UPnP operations as well</td></tr><tr id="66" style="display: none;" colspan="3"><td colspan="3"><h2>support using the windows API for UPnP operations as well</h2><h4>../include/libtorrent/upnp.hpp:108</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// specific IP addres or DNS name
			remote_host_must_be_wildcard = 726,
			// ExternalPort must be a wildcard and cannot be a
			// specific port
			external_port_must_be_wildcard = 727
		};
	}

	TORRENT_EXPORT boost::system::error_category&amp; get_upnp_category();

// int: port-mapping index
// address: external address as queried from router
// int: external port
// std::string: error message
// an empty string as error means success
// a port-mapping index of -1 means it's
// an informational log message
typedef boost::function&lt;void(int, address, int, error_code const&amp;)&gt; portmap_callback_t;
typedef boost::function&lt;void(char const*)&gt; log_callback_t;

<div style="background: #ffff00" width="100%">class TORRENT_EXTRA_EXPORT upnp : public intrusive_ptr_base&lt;upnp&gt;
</div>{
public:
	upnp(io_service&amp; ios, connection_queue&amp; cc
		, address const&amp; listen_interface, std::string const&amp; user_agent
		, portmap_callback_t const&amp; cb, log_callback_t const&amp; lcb
		, bool ignore_nonrouters, void* state = 0);
	~upnp();

	void* drain_state();

	enum protocol_type { none = 0, udp = 1, tcp = 2 };

	// Attempts to add a port mapping for the specified protocol. Valid protocols are
	// ``upnp::tcp`` and ``upnp::udp`` for the UPnP class and ``natpmp::tcp`` and
	// ``natpmp::udp`` for the NAT-PMP class.
	// 
	// ``external_port`` is the port on the external address that will be mapped. This
	// is a hint, you are not guaranteed that this port will be available, and it may
	// end up being something else. In the portmap_alert_ notification, the actual
	// external port is reported.
	// 
	// ``local_port`` is the port in the local machine that the mapping should forward
	// to.
	// 
	// The return value is an index that identifies this port mapping. This is used
	// to refer to mappings that fails or succeeds in the portmap_error_alert_ and
	// portmap_alert_ respectively. If The mapping fails immediately, the return value
	// is -1, which means failure. There will not be any error alert notification for
	// mappings that fail with a -1 return value.
	int add_mapping(protocol_type p, int external_port, int local_port);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(67)">../include/libtorrent/utp_stream.hpp:378</a></td><td>implement blocking write. Low priority since it's not used (yet)</td></tr><tr id="67" style="display: none;" colspan="3"><td colspan="3"><h2>implement blocking write. Low priority since it's not used (yet)</h2><h4>../include/libtorrent/utp_stream.hpp:378</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		for (typename Mutable_Buffers::const_iterator i = buffers.begin()
			, end(buffers.end()); i != end; ++i)
		{
			using asio::buffer_cast;
			using asio::buffer_size;
			add_read_buffer(buffer_cast&lt;void*&gt;(*i), buffer_size(*i));
#if TORRENT_USE_ASSERTS
			buf_size += buffer_size(*i);
#endif
		}
		std::size_t ret = read_some(true);
		TORRENT_ASSERT(ret &lt;= buf_size);
		TORRENT_ASSERT(ret &gt; 0);
		return ret;
	}

	template &lt;class Const_Buffers&gt;
	std::size_t write_some(Const_Buffers const&amp; buffers, error_code&amp; ec)
	{
		TORRENT_ASSERT(false &amp;&amp; "not implemented!");
<div style="background: #ffff00" width="100%">		return 0;
</div>	}

#ifndef BOOST_NO_EXCEPTIONS
	template &lt;class Mutable_Buffers&gt;
	std::size_t read_some(Mutable_Buffers const&amp; buffers)
	{
		error_code ec;
		std::size_t ret = read_some(buffers, ec);
		if (ec)
			boost::throw_exception(boost::system::system_error(ec));
		return ret;
	}

	template &lt;class Const_Buffers&gt;
	std::size_t write_some(Const_Buffers const&amp; buffers)
	{
		error_code ec;
		std::size_t ret = write_some(buffers, ec);
		if (ec)
			boost::throw_exception(boost::system::system_error(ec));
		return ret;
	}
#endif

	template &lt;class Handler&gt;
	void async_write_some(boost::asio::null_buffers const&amp; buffers, Handler const&amp; handler)
	{
		TORRENT_ASSERT(false);
	}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(68)">../include/libtorrent/kademlia/item.hpp:61</a></td><td>since this is a public function, it should probably be moved out of this header and into one with other public functions.</td></tr><tr id="68" style="display: none;" colspan="3"><td colspan="3"><h2>since this is a public function, it should probably be moved
out of this header and into one with other public functions.</h2><h4>../include/libtorrent/kademlia/item.hpp:61</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include &lt;boost/array.hpp&gt;

namespace libtorrent { namespace dht
{

// calculate the target hash for an immutable item.
sha1_hash TORRENT_EXTRA_EXPORT item_target_id(
	std::pair&lt;char const*, int&gt; v);

// calculate the target hash for a mutable item.
sha1_hash TORRENT_EXTRA_EXPORT item_target_id(std::pair&lt;char const*, int&gt; salt
	, char const* pk);

bool TORRENT_EXTRA_EXPORT verify_mutable_item(
	std::pair&lt;char const*, int&gt; v
	, std::pair&lt;char const*, int&gt; salt
	, boost::uint64_t seq
	, char const* pk
	, char const* sig);

<div style="background: #ffff00" width="100%">
</div>// given a byte range ``v`` and an optional byte range ``salt``, a
// sequence number, public key ``pk`` (must be 32 bytes) and a secret key
// ``sk`` (must be 64 bytes), this function produces a signature which
// is written into a 64 byte buffer pointed to by ``sig``. The caller
// is responsible for allocating the destination buffer that's passed in
// as the ``sig`` argument. Typically it would be allocated on the stack.
void TORRENT_EXPORT sign_mutable_item(
	std::pair&lt;char const*, int&gt; v
	, std::pair&lt;char const*, int&gt; salt
	, boost::uint64_t seq
	, char const* pk
	, char const* sk
	, char* sig);

sha1_hash TORRENT_EXTRA_EXPORT mutable_item_cas(
	std::pair&lt;char const*, int&gt; v
	, std::pair&lt;char const*, int&gt; salt
	, boost::uint64_t seq);

struct TORRENT_EXTRA_EXPORT invalid_item : std::exception
{
	virtual const char* what() const throw() { return "invalid DHT item"; }
};

enum
{
	item_pk_len = 32,
	item_sk_len = 64,
	item_sig_len = 64
};
</pre></td></tr></table></body></html>