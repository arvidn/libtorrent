<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>Settings</title>
<meta name="author" content="Arvid Norberg, arvid&#64;rasterbar.com" />
<link rel="stylesheet" type="text/css" href="../../css/base.css" />
<link rel="stylesheet" type="text/css" href="../../css/rst.css" />
<script type="text/javascript">
/* <![CDATA[ */
    (function() {
        var s = document.createElement('script'), t = document.getElementsByTagName('script')[0];
        s.type = 'text/javascript';
        s.async = true;
        s.src = 'http://api.flattr.com/js/0.6/load.js?mode=auto';
        t.parentNode.insertBefore(s, t);
    })();
/* ]]> */
</script>
<link rel="stylesheet" href="style.css" type="text/css" />
<style type="text/css">
/* Hides from IE-mac \*/
* html pre { height: 1%; }
/* End hide from IE-mac */
</style>
</head>
<body>
<div class="document" id="settings">
    <div id="container">
    <div id="headerNav">
    <ul>
    <li class="first"><a href="/">Home</a></li>
    <li><a href="../../products.html">Products</a></li>
    <li><a href="../../contact.html">Contact</a></li>
    </ul>
    </div>
    <div id="header">
    <div id="orange"></div>
    <div id="logo"></div>
    </div>
    <div id="main">
<h1 class="title">Settings</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Arvid Norberg, <a class="last reference external" href="mailto:arvid&#64;rasterbar.com">arvid&#64;rasterbar.com</a></td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>1.0.1</td></tr>
</tbody>
</table>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#proxy-settings" id="id46">proxy_settings</a></li>
<li><a class="reference internal" href="#session-settings" id="id47">session_settings</a></li>
<li><a class="reference internal" href="#dht-settings" id="id48">dht_settings</a></li>
<li><a class="reference internal" href="#pe-settings" id="id49">pe_settings</a></li>
</ul>
</div>
<a name="proxy_settings"></a><div class="section" id="proxy-settings">
<h1>proxy_settings</h1>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<p>The <tt class="docutils literal">proxy_settings</tt> structs contains the information needed to
direct certain traffic to a proxy.</p>
<pre class="literal-block">
struct proxy_settings
{
   <strong>proxy_settings</strong> ();

   enum proxy_type
   {
      none,
      socks4,
      socks5,
      socks5_pw,
      http,
      http_pw,
      i2p_proxy,
   };

   std::string hostname;
   std::string username;
   std::string password;
   boost::uint8_t type;
   boost::uint16_t port;
   bool proxy_hostnames;
   bool proxy_peer_connections;
};
</pre>
<a name="proxy_settings()"></a><div class="section" id="id2">
<h2>proxy_settings()</h2>
<pre class="literal-block">
<strong>proxy_settings</strong> ();
</pre>
<p>defaults constructs proxy settings, initializing it to the default
settings.</p>
<a name="proxy_type"></a></div>
<div class="section" id="enum-proxy-type">
<h2>enum proxy_type</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="7%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>none</td>
<td>0</td>
<td>This is the default, no proxy server is used, all other fields are
ignored.</td>
</tr>
<tr><td>socks4</td>
<td>1</td>
<td>The server is assumed to be a <a class="reference external" href="http://www.ufasoft.com/doc/socks4_protocol.htm">SOCKS4 server</a> that requires a
username.</td>
</tr>
<tr><td>socks5</td>
<td>2</td>
<td>The server is assumed to be a SOCKS5 server (<a class="reference external" href="http://www.faqs.org/rfcs/rfc1928.html">RFC 1928</a>) that does
not require any authentication. The username and password are
ignored.</td>
</tr>
<tr><td>socks5_pw</td>
<td>3</td>
<td>The server is assumed to be a SOCKS5 server that supports plain
text username and password authentication (<a class="reference external" href="http://www.faqs.org/rfcs/rfc1929.html">RFC 1929</a>). The
username and password specified may be sent to the proxy if it
requires.</td>
</tr>
<tr><td>http</td>
<td>4</td>
<td>The server is assumed to be an HTTP proxy. If the transport used
for the connection is non-HTTP, the server is assumed to support
the <a class="reference external" href="http://tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01">CONNECT</a> method. i.e. for web seeds and HTTP trackers, a plain
proxy will suffice. The proxy is assumed to not require
authorization. The username and password will not be used.</td>
</tr>
<tr><td>http_pw</td>
<td>5</td>
<td>The server is assumed to be an HTTP proxy that requires user
authorization. The username and password will be sent to the proxy.</td>
</tr>
<tr><td>i2p_proxy</td>
<td>6</td>
<td>route through a i2p SAM proxy</td>
</tr>
</tbody>
</table>
<a name="hostname"></a><dl class="docutils">
<dt>hostname</dt>
<dd>the name or IP of the proxy server. <tt class="docutils literal">port</tt> is the port number the
proxy listens to. If required, <tt class="docutils literal">username</tt> and <tt class="docutils literal">password</tt> can be
set to authenticate with the proxy.</dd>
</dl>
<a name="username"></a>
<a name="password"></a><dl class="docutils">
<dt>username  password</dt>
<dd>when using a proy type that requires authentication, the username
and password fields must be set to the credentials for the proxy.</dd>
</dl>
<a name="type"></a><dl class="docutils">
<dt>type</dt>
<dd>tells libtorrent what kind of proxy server it is. See <a class="reference external" href="reference-Settings.html#proxy_type">proxy_type</a>
enum for options</dd>
</dl>
<a name="port"></a><dl class="docutils">
<dt>port</dt>
<dd>the port the proxy server is running on</dd>
</dl>
<a name="proxy_hostnames"></a><dl class="docutils">
<dt>proxy_hostnames</dt>
<dd>defaults to true. It means that hostnames should be attempted to be
resolved through the proxy instead of using the local DNS service.
This is only supported by SOCKS5 and HTTP.</dd>
</dl>
<a name="proxy_peer_connections"></a><dl class="docutils">
<dt>proxy_peer_connections</dt>
<dd>determines whether or not to excempt peer and web seed connections
from using the proxy. This defaults to true, i.e. peer connections are
proxied by default.</dd>
</dl>
<a name="session_settings"></a></div>
</div>
<div class="section" id="session-settings">
<h1>session_settings</h1>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<p>This holds most of the session-wide settings in libtorrent. Pass this
to <a class="reference external" href="reference-Session.html#set_settings()">session::set_settings()</a> to change the settings, initialize it from
session::get_settings() to get the current settings.</p>
<pre class="literal-block">
struct session_settings
{
   <strong>session_settings</strong> (std::string const&amp; user_agent = &quot;libtorrent/&quot;
      LIBTORRENT_VERSION);
   <strong>~session_settings</strong> ();

   enum suggest_mode_t
   {
      no_piece_suggestions,
      suggest_read_cache,
   };

   enum choking_algorithm_t
   {
      fixed_slots_choker,
      auto_expand_choker,
      rate_based_choker,
      bittyrant_choker,
   };

   enum seed_choking_algorithm_t
   {
      round_robin,
      fastest_upload,
      anti_leech,
   };

   enum io_buffer_mode_t
   {
      enable_os_cache,
      disable_os_cache_for_aligned_files,
      disable_os_cache,
   };

   enum disk_cache_algo_t
   {
      lru,
      largest_contiguous,
      avoid_readback,
   };

   enum bandwidth_mixed_algo_t
   {
      prefer_tcp,
      peer_proportional,
   };

   int version;
   std::string user_agent;
   int tracker_completion_timeout;
   int tracker_receive_timeout;
   int stop_tracker_timeout;
   int tracker_maximum_response_length;
   int piece_timeout;
   int request_timeout;
   int request_queue_time;
   int max_allowed_in_request_queue;
   int max_out_request_queue;
   int whole_pieces_threshold;
   int peer_timeout;
   int urlseed_timeout;
   int urlseed_pipeline_size;
   int urlseed_wait_retry;
   int file_pool_size;
   bool allow_multiple_connections_per_ip;
   int max_failcount;
   int min_reconnect_time;
   int peer_connect_timeout;
   bool ignore_limits_on_local_network;
   int connection_speed;
   bool send_redundant_have;
   bool lazy_bitfields;
   int inactivity_timeout;
   int unchoke_interval;
   int optimistic_unchoke_interval;
   std::string announce_ip;
   int num_want;
   int initial_picker_threshold;
   int allowed_fast_set_size;
   int suggest_mode;
   int max_queued_disk_bytes;
   int max_queued_disk_bytes_low_watermark;
   int handshake_timeout;
   bool use_dht_as_fallback;
   bool free_torrent_hashes;
   bool upnp_ignore_nonrouters;
   int send_buffer_low_watermark;
   int send_buffer_watermark;
   int send_buffer_watermark_factor;
   int choking_algorithm;
   int seed_choking_algorithm;
   bool use_parole_mode;
   int cache_size;
   int cache_buffer_chunk_size;
   int cache_expiry;
   bool use_read_cache;
   bool explicit_read_cache;
   int explicit_cache_interval;
   int disk_io_write_mode;
   int disk_io_read_mode;
   bool coalesce_reads;
   bool coalesce_writes;
   std::pair&lt;int, int&gt; outgoing_ports;
   char peer_tos;
   int active_downloads;
   int active_seeds;
   int active_dht_limit;
   int active_tracker_limit;
   int active_lsd_limit;
   int active_limit;
   bool auto_manage_prefer_seeds;
   bool dont_count_slow_torrents;
   int auto_manage_interval;
   float share_ratio_limit;
   float seed_time_ratio_limit;
   int seed_time_limit;
   int peer_turnover_interval;
   float peer_turnover;
   float peer_turnover_cutoff;
   bool close_redundant_connections;
   int auto_scrape_interval;
   int auto_scrape_min_interval;
   int max_peerlist_size;
   int max_paused_peerlist_size;
   int min_announce_interval;
   bool prioritize_partial_pieces;
   int auto_manage_startup;
   bool rate_limit_ip_overhead;
   bool announce_to_all_trackers;
   bool announce_to_all_tiers;
   bool prefer_udp_trackers;
   bool strict_super_seeding;
   int seeding_piece_quota;
   int max_sparse_regions;
   bool lock_disk_cache;
   int max_rejects;
   int recv_socket_buffer_size;
   int send_socket_buffer_size;
   bool optimize_hashing_for_speed;
   int file_checks_delay_per_block;
   disk_cache_algo_t disk_cache_algorithm;
   int read_cache_line_size;
   int write_cache_line_size;
   int optimistic_disk_retry;
   bool disable_hash_checks;
   bool allow_reordered_disk_operations;
   bool allow_i2p_mixed;
   int max_suggest_pieces;
   bool drop_skipped_requests;
   bool low_prio_disk;
   int local_service_announce_interval;
   int dht_announce_interval;
   int udp_tracker_token_expiry;
   bool volatile_read_cache;
   bool guided_read_cache;
   int default_cache_min_age;
   int num_optimistic_unchoke_slots;
   bool no_atime_storage;
   int default_est_reciprocation_rate;
   int increase_est_reciprocation_rate;
   int decrease_est_reciprocation_rate;
   bool incoming_starts_queued_torrents;
   bool report_true_downloaded;
   bool strict_end_game_mode;
   bool broadcast_lsd;
   bool enable_outgoing_utp;
   bool enable_incoming_utp;
   bool enable_outgoing_tcp;
   bool enable_incoming_tcp;
   int max_pex_peers;
   bool ignore_resume_timestamps;
   bool no_recheck_incomplete_resume;
   bool anonymous_mode;
   bool force_proxy;
   int tick_interval;
   bool report_web_seed_downloads;
   int share_mode_target;
   int upload_rate_limit;
   int download_rate_limit;
   int local_upload_rate_limit;
   int local_download_rate_limit;
   int dht_upload_rate_limit;
   int unchoke_slots_limit;
   int half_open_limit;
   int connections_limit;
   int connections_slack;
   int utp_target_delay;
   int utp_gain_factor;
   int utp_min_timeout;
   int utp_syn_resends;
   int utp_fin_resends;
   int utp_num_resends;
   int utp_connect_timeout;
   bool utp_dynamic_sock_buf;
   int utp_loss_multiplier;
   int mixed_mode_algorithm;
   bool rate_limit_utp;
   int listen_queue_size;
   bool announce_double_nat;
   int torrent_connect_boost;
   bool seeding_outgoing_connections;
   bool no_connect_privileged_ports;
   int alert_queue_size;
   int max_metadata_size;
   bool smooth_connects;
   bool always_send_user_agent;
   bool apply_ip_filter_to_trackers;
   int read_job_every;
   bool use_disk_read_ahead;
   bool lock_files;
   int ssl_listen;
   int tracker_backoff;
   bool ban_web_seeds;
   int max_http_recv_buffer_size;
   bool support_share_mode;
   bool support_merkle_torrents;
   bool report_redundant_bytes;
   std::string handshake_client_version;
   bool use_disk_cache_pool;
   int inactive_down_rate;
   int inactive_up_rate;
};
</pre>
<a name="~session_settings()"></a>
<a name="session_settings()"></a><div class="section" id="session-settings-session-settings">
<h2>~session_settings() session_settings()</h2>
<pre class="literal-block">
<strong>session_settings</strong> (std::string const&amp; user_agent = &quot;libtorrent/&quot;
      LIBTORRENT_VERSION);
<strong>~session_settings</strong> ();
</pre>
<p>initializes the <a class="reference external" href="reference-Settings.html#session_settings">session_settings</a> to the default settings.</p>
<a name="suggest_mode_t"></a></div>
<div class="section" id="enum-suggest-mode-t">
<h2>enum suggest_mode_t</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="7%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_piece_suggestions</td>
<td>0</td>
<td>the default. will not send out suggest messages.</td>
</tr>
<tr><td>suggest_read_cache</td>
<td>1</td>
<td>send out suggest messages for the most recent pieces that are in
the read cache.</td>
</tr>
</tbody>
</table>
<a name="choking_algorithm_t"></a></div>
<div class="section" id="enum-choking-algorithm-t">
<h2>enum choking_algorithm_t</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="7%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>fixed_slots_choker</td>
<td>0</td>
<td>the traditional choker with a fixed number of unchoke slots, as
specified by session::set_max_uploads()..</td>
</tr>
<tr><td>auto_expand_choker</td>
<td>1</td>
<td>opens at least the number of slots as specified by
session::set_max_uploads() but opens up more slots if the upload
capacity is not saturated. This unchoker will work just like the
<tt class="docutils literal">fixed_slot_choker</tt> if there's no global upload rate limit set.</td>
</tr>
<tr><td>rate_based_choker</td>
<td>2</td>
<td>opens up unchoke slots based on the upload rate achieved to peers.
The more slots that are opened, the marginal upload rate required
to open up another slot increases.</td>
</tr>
<tr><td>bittyrant_choker</td>
<td>3</td>
<td>attempts to optimize download rate by finding the reciprocation
rate of each peer individually and prefers peers that gives the
highest <em>return on investment</em>. It still allocates all upload
capacity, but shuffles it around to the best peers first. For this
choker to be efficient, you need to set a global upload rate limit
<a class="reference external" href="reference-Settings.html#upload_rate_limit">session_settings::upload_rate_limit</a>. For more information about
this choker, see the <a class="reference external" href="http://bittyrant.cs.washington.edu/#papers">paper</a>.</td>
</tr>
</tbody>
</table>
<a name="seed_choking_algorithm_t"></a></div>
<div class="section" id="enum-seed-choking-algorithm-t">
<h2>enum seed_choking_algorithm_t</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="8%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>round_robin</td>
<td>0</td>
<td>round-robins the peers that are unchoked when seeding. This
distributes the upload bandwidht uniformly and fairly. It minimizes
the ability for a peer to download everything without
redistributing it.</td>
</tr>
<tr><td>fastest_upload</td>
<td>1</td>
<td>unchokes the peers we can send to the fastest. This might be a bit
more reliable in utilizing all available capacity.</td>
</tr>
<tr><td>anti_leech</td>
<td>2</td>
<td>prioritizes peers who have just started or are just about to finish
the download. The intention is to force peers in the middle of the
download to trade with each other.</td>
</tr>
</tbody>
</table>
<a name="io_buffer_mode_t"></a></div>
<div class="section" id="enum-io-buffer-mode-t">
<h2>enum io_buffer_mode_t</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="6%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_os_cache</td>
<td>0</td>
<td>This is the default and files are opened normally, with the OS
caching reads and writes.</td>
</tr>
<tr><td>disable_os_cache_for_aligned_files</td>
<td>1</td>
<td>This will open files in unbuffered mode for files where every read
and write would be sector aligned. Using aligned disk offsets is a
requirement on some operating systems.</td>
</tr>
<tr><td>disable_os_cache</td>
<td>2</td>
<td>This opens all files in unbuffered mode (if allowed by the
operating system). Linux and Windows, for instance, require disk
offsets to be sector aligned, and in those cases, this option is
the same as <tt class="docutils literal">disable_os_caches_for_aligned_files</tt>.</td>
</tr>
</tbody>
</table>
<a name="disk_cache_algo_t"></a></div>
<div class="section" id="enum-disk-cache-algo-t">
<h2>enum disk_cache_algo_t</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="7%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>lru</td>
<td>0</td>
<td>This flushes the entire piece, in the write cache, that was least
recently written to.</td>
</tr>
<tr><td>largest_contiguous</td>
<td>1</td>
<td>will flush the largest sequences of contiguous blocks from the
write cache, regarless of the piece's last use time.</td>
</tr>
<tr><td>avoid_readback</td>
<td>2</td>
<td>will prioritize flushing blocks that will avoid having to read them
back in to verify the hash of the piece once it's done. This is
especially useful for high throughput setups, where reading from
the disk is especially expensive.</td>
</tr>
</tbody>
</table>
<a name="bandwidth_mixed_algo_t"></a></div>
<div class="section" id="enum-bandwidth-mixed-algo-t">
<h2>enum bandwidth_mixed_algo_t</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="8%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prefer_tcp</td>
<td>0</td>
<td>disables the mixed mode bandwidth balancing</td>
</tr>
<tr><td>peer_proportional</td>
<td>1</td>
<td>does not throttle uTP, throttles TCP to the same proportion
of throughput as there are TCP connections</td>
</tr>
</tbody>
</table>
<a name="version"></a><dl class="docutils">
<dt>version</dt>
<dd>automatically set to the libtorrent version you're using in order to
be forward binary compatible. This field should not be changed.</dd>
</dl>
<a name="user_agent"></a><dl class="docutils">
<dt>user_agent</dt>
<dd>the client identification to the tracker. The recommended format of
this string is: &quot;ClientName/ClientVersion
libtorrent/libtorrentVersion&quot;. This name will not only be used when
making HTTP requests, but also when sending extended headers to peers
that support that extension.</dd>
</dl>
<a name="tracker_completion_timeout"></a><dl class="docutils">
<dt>tracker_completion_timeout</dt>
<dd>the number of seconds the tracker connection will wait from when it
sent the request until it considers the tracker to have timed-out.
Default value is 60 seconds.</dd>
</dl>
<a name="tracker_receive_timeout"></a><dl class="docutils">
<dt>tracker_receive_timeout</dt>
<dd>the number of seconds to wait to receive any data from the tracker. If
no data is received for this number of seconds, the tracker will be
considered as having timed out. If a tracker is down, this is the kind
of timeout that will occur. The default value is 20 seconds.</dd>
</dl>
<a name="stop_tracker_timeout"></a><dl class="docutils">
<dt>stop_tracker_timeout</dt>
<dd><p class="first">the time to wait when sending a stopped message before considering a
tracker to have timed out. this is usually shorter, to make the client
quit faster</p>
<p class="last">This is given in seconds. Default is 10 seconds.</p>
</dd>
</dl>
<a name="tracker_maximum_response_length"></a><dl class="docutils">
<dt>tracker_maximum_response_length</dt>
<dd>the maximum number of bytes in a tracker response. If a response size
passes this number it will be rejected and the connection will be
closed. On gzipped responses this size is measured on the uncompressed
data. So, if you get 20 bytes of gzip response that'll expand to 2
megs, it will be interrupted before the entire response has been
uncompressed (given your limit is lower than 2 megs). Default limit is
1 megabyte.</dd>
</dl>
<a name="piece_timeout"></a><dl class="docutils">
<dt>piece_timeout</dt>
<dd>controls the number of seconds from a request is sent until it times
out if no piece response is returned.</dd>
</dl>
<a name="request_timeout"></a><dl class="docutils">
<dt>request_timeout</dt>
<dd>the number of seconds one block (16kB) is expected to be received
within. If it's not, the block is requested from a different peer</dd>
</dl>
<a name="request_queue_time"></a><dl class="docutils">
<dt>request_queue_time</dt>
<dd>the length of the request queue given in the number of seconds it
should take for the other end to send all the pieces. i.e. the actual
number of requests depends on the download rate and this number.</dd>
</dl>
<a name="max_allowed_in_request_queue"></a><dl class="docutils">
<dt>max_allowed_in_request_queue</dt>
<dd>the number of outstanding block requests a peer is allowed to queue up
in the client. If a peer sends more requests than this (before the
first one has been sent) the last request will be dropped. the higher
this is, the faster upload speeds the client can get to a single peer.</dd>
</dl>
<a name="max_out_request_queue"></a><dl class="docutils">
<dt>max_out_request_queue</dt>
<dd>the maximum number of outstanding requests to send to a peer. This
limit takes precedence over request_queue_time. i.e. no matter the
download speed, the number of outstanding requests will never exceed
this limit.</dd>
</dl>
<a name="whole_pieces_threshold"></a><dl class="docutils">
<dt>whole_pieces_threshold</dt>
<dd>if a whole piece can be downloaded in this number of seconds, or less,
the peer_connection will prefer to request whole pieces at a time from
this peer. The benefit of this is to better utilize disk caches by
doing localized accesses and also to make it easier to identify bad
peers if a piece fails the hash check.</dd>
</dl>
<a name="peer_timeout"></a><dl class="docutils">
<dt>peer_timeout</dt>
<dd>the number of seconds to wait for any activity on the peer wire before
closing the connectiong due to time out. This defaults to 120 seconds,
since that's what's specified in the protocol specification. After
half the time out, a keep alive message is sent.</dd>
</dl>
<a name="urlseed_timeout"></a><dl class="docutils">
<dt>urlseed_timeout</dt>
<dd>same as peer_timeout, but only applies to url-seeds. this is usually
set lower, because web servers are expected to be more reliable. This
value defaults to 20 seconds.</dd>
</dl>
<a name="urlseed_pipeline_size"></a><dl class="docutils">
<dt>urlseed_pipeline_size</dt>
<dd>controls the pipelining with the web server. When using persistent
connections to HTTP 1.1 servers, the client is allowed to send more
requests before the first response is received. This number controls
the number of outstanding requests to use with url-seeds. Default is
5.</dd>
</dl>
<a name="urlseed_wait_retry"></a><dl class="docutils">
<dt>urlseed_wait_retry</dt>
<dd>time to wait until a new retry takes place</dd>
</dl>
<a name="file_pool_size"></a><dl class="docutils">
<dt>file_pool_size</dt>
<dd>sets the upper limit on the total number of files this <a class="reference external" href="reference-Session.html#session">session</a> will
keep open. The reason why files are left open at all is that some anti
virus software hooks on every file close, and scans the file for
viruses. deferring the closing of the files will be the difference
between a usable system and a completely hogged down system. Most
operating systems also has a limit on the total number of file
descriptors a process may have open. It is usually a good idea to find
this limit and set the number of connections and the number of files
limits so their sum is slightly below it.</dd>
</dl>
<a name="allow_multiple_connections_per_ip"></a><dl class="docutils">
<dt>allow_multiple_connections_per_ip</dt>
<dd>determines if connections from the same IP address as existing
connections should be rejected or not. Multiple connections from the
same IP address is not allowed by default, to prevent abusive behavior
by peers. It may be useful to allow such connections in cases where
simulations are run on the same machie, and all peers in a swarm has
the same IP address.</dd>
</dl>
<a name="max_failcount"></a><dl class="docutils">
<dt>max_failcount</dt>
<dd>the maximum times we try to connect to a peer before stop connecting
again. If a peer succeeds, its failcounter is reset. If a peer is
retrieved from a peer source (other than DHT) the failcount is
decremented by one, allowing another try.</dd>
</dl>
<a name="min_reconnect_time"></a><dl class="docutils">
<dt>min_reconnect_time</dt>
<dd>the number of seconds to wait to reconnect to a peer. this time is
multiplied with the failcount.</dd>
</dl>
<a name="peer_connect_timeout"></a><dl class="docutils">
<dt>peer_connect_timeout</dt>
<dd>the number of seconds to wait after a connection attempt is initiated
to a peer until it is considered as having timed out. The default is
10 seconds. This setting is especially important in case the number of
half-open connections are limited, since stale half-open connection
may delay the connection of other peers considerably.</dd>
</dl>
<a name="ignore_limits_on_local_network"></a><dl class="docutils">
<dt>ignore_limits_on_local_network</dt>
<dd>if set to true, upload, download and unchoke limits are ignored for
peers on the local network.</dd>
</dl>
<a name="connection_speed"></a><dl class="docutils">
<dt>connection_speed</dt>
<dd>the number of connection attempts that are made per second. If a
number &lt; 0 is specified, it will default to 200 connections per
second. If 0 is specified, it means don't make outgoing connections at
all.</dd>
</dl>
<a name="send_redundant_have"></a><dl class="docutils">
<dt>send_redundant_have</dt>
<dd>if this is set to true, have messages will be sent to peers that
already have the piece. This is typically not necessary, but it might
be necessary for collecting statistics in some cases. Default is
false.</dd>
</dl>
<a name="lazy_bitfields"></a><dl class="docutils">
<dt>lazy_bitfields</dt>
<dd>prevents outgoing bitfields from being full. If the client is seed, a
few bits will be set to 0, and later filled in with have-messages.
This is an old attempt to prevent certain ISPs from stopping people
from seeding.</dd>
</dl>
<a name="inactivity_timeout"></a><dl class="docutils">
<dt>inactivity_timeout</dt>
<dd>if a peer is uninteresting and uninterested for longer than this
number of seconds, it will be disconnected. default is 10 minutes</dd>
</dl>
<a name="unchoke_interval"></a><dl class="docutils">
<dt>unchoke_interval</dt>
<dd>the number of seconds between chokes/unchokes. On this interval, peers
are re-evaluated for being choked/unchoked. This is defined as 30
seconds in the protocol, and it should be significantly longer than
what it takes for TCP to ramp up to it's max rate.</dd>
</dl>
<a name="optimistic_unchoke_interval"></a><dl class="docutils">
<dt>optimistic_unchoke_interval</dt>
<dd>the number of seconds between each <em>optimistic</em> unchoke. On this
timer, the currently optimistically unchoked peer will change.</dd>
</dl>
<a name="announce_ip"></a><dl class="docutils">
<dt>announce_ip</dt>
<dd>the ip address passed along to trackers as the <tt class="docutils literal">&amp;ip=</tt> parameter. If
left as the default (an empty string), that parameter is omitted. Most
trackers ignore this argument. This is here for completeness for
edge-cases where it may be useful.</dd>
</dl>
<a name="num_want"></a><dl class="docutils">
<dt>num_want</dt>
<dd>the number of peers we want from each tracker request. It defines what
is sent as the <tt class="docutils literal">&amp;num_want=</tt> parameter to the tracker. Stopped
messages always send num_want=0. This setting control what to say in
the case where we actually want peers.</dd>
</dl>
<a name="initial_picker_threshold"></a><dl class="docutils">
<dt>initial_picker_threshold</dt>
<dd>specifies the number of pieces we need before we switch to rarest
first picking. This defaults to 4, which means the 4 first pieces in
any torrent are picked at random, the following pieces are picked in
rarest first order.</dd>
</dl>
<a name="allowed_fast_set_size"></a><dl class="docutils">
<dt>allowed_fast_set_size</dt>
<dd>the number of allowed pieces to send to choked peers that supports the
fast extensions</dd>
</dl>
<a name="suggest_mode"></a><dl class="docutils">
<dt>suggest_mode</dt>
<dd><p class="first">this determines which pieces will be suggested to peers suggest read
cache will make libtorrent suggest pieces that are fresh in the disk
read cache, to potentially lower disk access and increase the cache
hit ratio</p>
<p class="last">for options, see <a class="reference external" href="reference-Settings.html#suggest_mode_t">suggest_mode_t</a>.</p>
</dd>
</dl>
<a name="max_queued_disk_bytes"></a><dl class="docutils">
<dt>max_queued_disk_bytes</dt>
<dd><p class="first">the maximum number of bytes a connection may have pending in the disk
write queue before its download rate is being throttled. This prevents
fast downloads to slow medias to allocate more memory indefinitely.
This should be set to at least 16 kB to not completely disrupt normal
downloads. If it's set to 0, you will be starving the disk thread and
nothing will be written to disk. this is a per <a class="reference external" href="reference-Session.html#session">session</a> setting.</p>
<p class="last">When this limit is reached, the peer connections will stop reading
data from their sockets, until the disk thread catches up. Setting
this too low will severly limit your download rate.</p>
</dd>
</dl>
<a name="max_queued_disk_bytes_low_watermark"></a><dl class="docutils">
<dt>max_queued_disk_bytes_low_watermark</dt>
<dd>this is the low watermark for the disk buffer queue. whenever the
number of queued bytes exceed the max_queued_disk_bytes, libtorrent
will wait for it to drop below this value before issuing more reads
from the sockets. If set to 0, the low watermark will be half of the
max queued disk bytes</dd>
</dl>
<a name="handshake_timeout"></a><dl class="docutils">
<dt>handshake_timeout</dt>
<dd>the number of seconds to wait for a handshake response from a peer. If
no response is received within this time, the peer is disconnected.</dd>
</dl>
<a name="use_dht_as_fallback"></a><dl class="docutils">
<dt>use_dht_as_fallback</dt>
<dd>determines how the DHT is used. If this is true, the DHT will only be
used for torrents where all trackers in its tracker list has failed.
Either by an explicit error message or a time out. This is false by
default, which means the DHT is used by default regardless of if the
trackers fail or not.</dd>
</dl>
<a name="free_torrent_hashes"></a><dl class="docutils">
<dt>free_torrent_hashes</dt>
<dd>determines whether or not the torrent's piece hashes are kept in
memory after the torrent becomes a seed or not. If it is set to
<tt class="docutils literal">true</tt> the hashes are freed once the torrent is a seed (they're not
needed anymore since the torrent won't download anything more). If
it's set to false they are not freed. If they are freed, the
<a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> returned by get_torrent_info() will return an object that
may be incomplete, that cannot be passed back to <a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a>
and <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> for instance.</dd>
</dl>
<a name="upnp_ignore_nonrouters"></a><dl class="docutils">
<dt>upnp_ignore_nonrouters</dt>
<dd>indicates whether or not the UPnP implementation should ignore any
broadcast response from a device whose address is not the configured
router for this machine. i.e. it's a way to not talk to other people's
routers by mistake.</dd>
</dl>
<a name="send_buffer_low_watermark"></a><dl class="docutils">
<dt>send_buffer_low_watermark</dt>
<dd>This is the minimum send buffer target size (send buffer includes
bytes pending being read from disk). For good and snappy seeding
performance, set this fairly high, to at least fit a few blocks. This
is essentially the initial window size which will determine how fast
we can ramp up the send rate</dd>
</dl>
<a name="send_buffer_watermark"></a><dl class="docutils">
<dt>send_buffer_watermark</dt>
<dd><p class="first">the upper limit of the send buffer low-watermark.</p>
<p class="last">if the send buffer has fewer bytes than this, we'll read another 16kB
block onto it. If set too small, upload rate capacity will suffer. If
set too high, memory will be wasted. The actual watermark may be lower
than this in case the upload rate is low, this is the upper limit.</p>
</dd>
</dl>
<a name="send_buffer_watermark_factor"></a><dl class="docutils">
<dt>send_buffer_watermark_factor</dt>
<dd><p class="first">the current upload rate to a peer is multiplied by this factor to get
the send buffer watermark. The factor is specified as a percentage.
i.e. 50 indicates a factor of 0.5.</p>
<p>This product is clamped to the send_buffer_watermark setting to not
exceed the max. For high speed upload, this should be set to a greater
value than 100. The default is 50.</p>
<p class="last">For high capacity connections, setting this higher can improve upload
performance and disk throughput. Setting it too high may waste RAM and
create a bias towards read jobs over write jobs.</p>
</dd>
</dl>
<a name="choking_algorithm"></a><dl class="docutils">
<dt>choking_algorithm</dt>
<dd>specifies which algorithm to use to determine which peers to unchoke.
This setting replaces the deprecated settings <tt class="docutils literal">auto_upload_slots</tt>
and <tt class="docutils literal">auto_upload_slots_rate_based</tt>. For options, see
<a class="reference external" href="reference-Settings.html#choking_algorithm_t">choking_algorithm_t</a>.</dd>
</dl>
<a name="seed_choking_algorithm"></a><dl class="docutils">
<dt>seed_choking_algorithm</dt>
<dd>controls the seeding unchoke behavior. For options, see
<a class="reference external" href="reference-Settings.html#seed_choking_algorithm_t">seed_choking_algorithm_t</a>.</dd>
</dl>
<a name="use_parole_mode"></a><dl class="docutils">
<dt>use_parole_mode</dt>
<dd>specifies if parole mode should be used. Parole mode means that peers
that participate in pieces that fail the hash check are put in a mode
where they are only allowed to download whole pieces. If the whole
piece a peer in parole mode fails the hash check, it is banned. If a
peer participates in a piece that passes the hash check, it is taken
out of parole mode.</dd>
</dl>
<a name="cache_size"></a><dl class="docutils">
<dt>cache_size</dt>
<dd><p class="first">the disk write and read  cache. It is specified in units of 16 KiB
blocks. Buffers that are part of a peer's send or receive buffer also
count against this limit. Send and receive buffers will never be
denied to be allocated, but they will cause the actual cached blocks
to be flushed or evicted. If this is set to -1, the cache size is
automatically set to the amount of physical RAM available in the
machine divided by 8. If the amount of physical RAM cannot be
determined, it's set to 1024 (= 16 MiB).</p>
<p class="last">Disk buffers are allocated using a pool allocator, the number of
blocks that are allocated at a time when the pool needs to grow can be
specified in <tt class="docutils literal">cache_buffer_chunk_size</tt>. This defaults to 16 blocks.
Lower numbers saves memory at the expense of more heap allocations. It
must be at least 1.</p>
</dd>
</dl>
<a name="cache_buffer_chunk_size"></a><dl class="docutils">
<dt>cache_buffer_chunk_size</dt>
<dd>this is the number of disk buffer blocks (16 kiB) that should be
allocated at a time. It must be at least 1. Lower number saves memory
at the expense of more heap allocations</dd>
</dl>
<a name="cache_expiry"></a><dl class="docutils">
<dt>cache_expiry</dt>
<dd>the number of seconds a write cache <a class="reference external" href="reference-Bencoding.html#entry">entry</a> sits idle in the cache
before it's forcefully flushed to disk.</dd>
</dl>
<a name="use_read_cache"></a><dl class="docutils">
<dt>use_read_cache</dt>
<dd>when set to true (default), the disk cache is also used to cache
pieces read from disk. Blocks for writing pieces takes presedence.</dd>
</dl>
<a name="explicit_read_cache"></a><dl class="docutils">
<dt>explicit_read_cache</dt>
<dd>defaults to 0. If set to something greater than 0, the disk read cache
will not be evicted by cache misses and will explicitly be controlled
based on the rarity of pieces. Rare pieces are more likely to be
cached. This would typically be used together with <tt class="docutils literal">suggest_mode</tt>
set to <tt class="docutils literal">suggest_read_cache</tt>. The value is the number of pieces to
keep in the read cache. If the actual read cache can't fit as many, it
will essentially be clamped.</dd>
</dl>
<a name="explicit_cache_interval"></a><dl class="docutils">
<dt>explicit_cache_interval</dt>
<dd>the number of seconds in between each refresh of a part of the
explicit read cache. Torrents take turns in refreshing and this is the
time in between each torrent refresh. Refreshing a torrent's explicit
read cache means scanning all pieces and picking a random set of the
rarest ones. There is an affinity to pick pieces that are already in
the cache, so that subsequent refreshes only swaps in pieces that are
rarer than whatever is in the cache at the time.</dd>
</dl>
<a name="disk_io_write_mode"></a>
<a name="disk_io_read_mode"></a><dl class="docutils">
<dt>disk_io_write_mode  disk_io_read_mode</dt>
<dd><p class="first">determines how files are opened when they're in read only mode versus
read and write mode. For options, see <a class="reference external" href="reference-Settings.html#io_buffer_mode_t">io_buffer_mode_t</a>.</p>
<p class="last">One reason to disable caching is that it may help the operating system
from growing its file cache indefinitely. Since some OSes only allow
aligned files to be opened in unbuffered mode, It is recommended to
make the largest file in a torrent the first file (with offset 0) or
use pad files to align all files to piece boundries.</p>
</dd>
</dl>
<a name="coalesce_reads"></a>
<a name="coalesce_writes"></a><dl class="docutils">
<dt>coalesce_reads  coalesce_writes</dt>
<dd>when set to true, instead of issuing multiple adjacent reads or writes
to the disk, allocate a larger buffer, copy all writes into it and
issue a single write. For reads, read into a larger buffer and copy
the buffer into the smaller individual read buffers afterwards. This
may save system calls, but will cost in additional memory allocation
and copying.</dd>
</dl>
<a name="outgoing_ports"></a><dl class="docutils">
<dt>outgoing_ports</dt>
<dd><p class="first">if set to something other than (0, 0) is a range of ports used to bind
outgoing sockets to. This may be useful for users whose router allows
them to assign QoS classes to traffic based on its local port. It is a
range instead of a single port because of the problems with failing to
reconnect to peers if a previous socket to that peer and port is in
<tt class="docutils literal">TIME_WAIT</tt> state.</p>
<div class="warning last">
<p class="first admonition-title">Warning</p>
<p class="last">setting outgoing ports will limit the ability to keep multiple
connections to the same client, even for different torrents. It is not
recommended to change this setting. Its main purpose is to use as an
escape hatch for cheap routers with QoS capability but can only
classify flows based on port numbers.</p>
</div>
</dd>
</dl>
<a name="peer_tos"></a><dl class="docutils">
<dt>peer_tos</dt>
<dd>determines the TOS byte set in the IP header of every packet sent to
peers (including web seeds). The default value for this is <tt class="docutils literal">0x0</tt> (no
marking). One potentially useful TOS mark is <tt class="docutils literal">0x20</tt>, this represents
the <em>QBone scavenger service</em>. For more details, see <a class="reference external" href="http://qbone.internet2.edu/qbss/">QBSS</a>.</dd>
</dl>
<a name="active_downloads"></a>
<a name="active_seeds"></a>
<a name="active_dht_limit"></a>
<a name="active_tracker_limit"></a>
<a name="active_lsd_limit"></a>
<a name="active_limit"></a><dl class="docutils">
<dt>active_downloads  active_seeds  active_dht_limit  active_tracker_limit  active_lsd_limit  active_limit</dt>
<dd><p class="first">for auto managed torrents, these are the limits they are subject to.
If there are too many torrents some of the auto managed ones will be
paused until some slots free up.</p>
<p><tt class="docutils literal">active_dht_limit</tt> and <tt class="docutils literal">active_tracker_limit</tt> limits the number of
torrents that will be active on the DHT and their tracker. If the
active limit is set higher than these numbers, some torrents will be
&quot;active&quot; in the sense that they will accept incoming connections, but
not announce on the DHT or their trackers.</p>
<p><tt class="docutils literal">active_lsd_limit</tt> is the max number of torrents to announce to the
local network over the local service discovery protocol. By default
this is 80, which is no more than one announce every 5 seconds
(assuming the default announce interval of 5 minutes).</p>
<p><tt class="docutils literal">active_limit</tt> is a hard limit on the number of active torrents.
This applies even to slow torrents.</p>
<p>You can have more torrents <em>active</em>, even though they are not
announced to the DHT, lsd or their tracker. If some peer knows about
you for any reason and tries to connect, it will still be accepted,
unless the torrent is paused, which means it won't accept any
connections.</p>
<p><tt class="docutils literal">active_downloads</tt> and <tt class="docutils literal">active_seeds</tt> controls how many active
seeding and downloading torrents the queuing mechanism allows. The
target number of active torrents is <tt class="docutils literal">min(active_downloads +
active_seeds, active_limit)</tt>. <tt class="docutils literal">active_downloads</tt> and
<tt class="docutils literal">active_seeds</tt> are upper limits on the number of downloading
torrents and seeding torrents respectively. Setting the value to -1
means unlimited.</p>
<p class="last">For example if there are 10 seeding torrents and 10 downloading
torrents, and <tt class="docutils literal">active_downloads</tt> is 4 and <tt class="docutils literal">active_seeds</tt> is 4,
there will be 4 seeds active and 4 downloading torrents. If the
settings are <tt class="docutils literal">active_downloads</tt> = 2 and <tt class="docutils literal">active_seeds</tt> = 4, then
there will be 2 downloading torrents and 4 seeding torrents active.
Torrents that are not auto managed are also counted against these
limits. If there are non-auto managed torrents that use up all the
slots, no auto managed torrent will be activated.</p>
</dd>
</dl>
<a name="auto_manage_prefer_seeds"></a><dl class="docutils">
<dt>auto_manage_prefer_seeds</dt>
<dd>prefer seeding torrents when determining which torrents to give active
slots to, the default is false which gives preference to downloading
torrents</dd>
</dl>
<a name="dont_count_slow_torrents"></a><dl class="docutils">
<dt>dont_count_slow_torrents</dt>
<dd>if true, torrents without any payload transfers are not subject to the
<tt class="docutils literal">active_seeds</tt> and <tt class="docutils literal">active_downloads</tt> limits. This is intended to
make it more likely to utilize all available bandwidth, and avoid
having torrents that don't transfer anything block the active slots.</dd>
</dl>
<a name="auto_manage_interval"></a><dl class="docutils">
<dt>auto_manage_interval</dt>
<dd>the number of seconds in between recalculating which torrents to
activate and which ones to queue</dd>
</dl>
<a name="share_ratio_limit"></a><dl class="docutils">
<dt>share_ratio_limit</dt>
<dd><p class="first">when a seeding torrent reaches either the share ratio (bytes up /
bytes down) or the seed time ratio (seconds as seed / seconds as
downloader) or the seed time limit (seconds as seed) it is considered
done, and it will leave room for other torrents the default value for
share ratio is 2 the default seed time ratio is 7, because that's a
common asymmetry ratio on connections</p>
<div class="note last">
<p class="first admonition-title">Note</p>
<p class="last">This is an out-dated option that doesn't make much sense. It will be
removed in future versions of libtorrent</p>
</div>
</dd>
</dl>
<a name="seed_time_ratio_limit"></a><dl class="docutils">
<dt>seed_time_ratio_limit</dt>
<dd>the seeding time / downloading time ratio limit for considering a
seeding torrent to have met the seed limit criteria. See <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</dd>
</dl>
<a name="seed_time_limit"></a><dl class="docutils">
<dt>seed_time_limit</dt>
<dd>the limit on the time a torrent has been an active seed (specified in
seconds) before it is considered having met the seed limit criteria.
See <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</dd>
</dl>
<a name="peer_turnover_interval"></a>
<a name="peer_turnover"></a>
<a name="peer_turnover_cutoff"></a><dl class="docutils">
<dt>peer_turnover_interval  peer_turnover  peer_turnover_cutoff</dt>
<dd><p class="first">controls a feature where libtorrent periodically can disconnect the
least useful peers in the hope of connecting to better ones.
<tt class="docutils literal">peer_turnover_interval</tt> controls the interval of this optimistic
disconnect. It defaults to every 5 minutes, and is specified in
seconds.</p>
<p><tt class="docutils literal">peer_turnover</tt> Is the fraction of the peers that are disconnected.
This is a float where 1.f represents all peers an 0 represents no
peers. It defaults to 4% (i.e. 0.04f)</p>
<p class="last"><tt class="docutils literal">peer_turnover_cutoff</tt> is the cut off trigger for optimistic
unchokes. If a torrent has more than this fraction of its connection
limit, the optimistic unchoke is triggered. This defaults to 90% (i.e.
0.9f).</p>
</dd>
</dl>
<a name="close_redundant_connections"></a><dl class="docutils">
<dt>close_redundant_connections</dt>
<dd>specifies whether libtorrent should close connections where both ends
have no utility in keeping the connection open. For instance if both
ends have completed their downloads, there's no point in keeping it
open. This defaults to <tt class="docutils literal">true</tt>.</dd>
</dl>
<a name="auto_scrape_interval"></a><dl class="docutils">
<dt>auto_scrape_interval</dt>
<dd>the number of seconds between scrapes of queued torrents (auto managed
and paused torrents). Auto managed torrents that are paused, are
scraped regularly in order to keep track of their downloader/seed
ratio. This ratio is used to determine which torrents to seed and
which to pause.</dd>
</dl>
<a name="auto_scrape_min_interval"></a><dl class="docutils">
<dt>auto_scrape_min_interval</dt>
<dd>the minimum number of seconds between any automatic scrape (regardless
of torrent). In case there are a large number of paused auto managed
torrents, this puts a limit on how often a scrape request is sent.</dd>
</dl>
<a name="max_peerlist_size"></a><dl class="docutils">
<dt>max_peerlist_size</dt>
<dd>the maximum number of peers in the list of known peers. These peers
are not necessarily connected, so this number should be much greater
than the maximum number of connected peers. Peers are evicted from the
cache when the list grows passed 90% of this limit, and once the size
hits the limit, peers are no longer added to the list. If this limit
is set to 0, there is no limit on how many peers we'll keep in the
peer list.</dd>
</dl>
<a name="max_paused_peerlist_size"></a><dl class="docutils">
<dt>max_paused_peerlist_size</dt>
<dd>the max peer list size used for torrents that are paused. This default
to the same as <tt class="docutils literal">max_peerlist_size</tt>, but can be used to save memory
for paused torrents, since it's not as important for them to keep a
large peer list.</dd>
</dl>
<a name="min_announce_interval"></a><dl class="docutils">
<dt>min_announce_interval</dt>
<dd>the minimum allowed announce interval for a tracker. This is specified
in seconds, defaults to 5 minutes and is used as a sanity check on
what is returned from a tracker. It mitigates hammering misconfigured
trackers.</dd>
</dl>
<a name="prioritize_partial_pieces"></a><dl class="docutils">
<dt>prioritize_partial_pieces</dt>
<dd>If true, partial pieces are picked before pieces that are more rare.
If false, rare pieces are always prioritized, unless the number of
partial pieces is growing out of proportion.</dd>
</dl>
<a name="auto_manage_startup"></a><dl class="docutils">
<dt>auto_manage_startup</dt>
<dd>the number of seconds a torrent is considered active after it was
started, regardless of upload and download speed. This is so that
newly started torrents are not considered inactive until they have a
fair chance to start downloading.</dd>
</dl>
<a name="rate_limit_ip_overhead"></a><dl class="docutils">
<dt>rate_limit_ip_overhead</dt>
<dd>if set to true, the estimated TCP/IP overhead is drained from the rate
limiters, to avoid exceeding the limits with the total traffic</dd>
</dl>
<a name="announce_to_all_trackers"></a><dl class="docutils">
<dt>announce_to_all_trackers</dt>
<dd>controls how multi tracker torrents are treated. If this is set to
true, all trackers in the same tier are announced to in parallel. If
all trackers in tier 0 fails, all trackers in tier 1 are announced as
well. If it's set to false, the behavior is as defined by the multi
tracker specification. It defaults to false, which is the same
behavior previous versions of libtorrent has had as well.</dd>
</dl>
<a name="announce_to_all_tiers"></a><dl class="docutils">
<dt>announce_to_all_tiers</dt>
<dd>controls how multi tracker torrents are treated. When this is set to
true, one tracker from each tier is announced to. This is the uTorrent
behavior. This is false by default in order to comply with the
multi-tracker specification.</dd>
</dl>
<a name="prefer_udp_trackers"></a><dl class="docutils">
<dt>prefer_udp_trackers</dt>
<dd>true by default. It means that trackers may be rearranged in a way
that udp trackers are always tried before http trackers for the same
hostname. Setting this to fails means that the trackers' tier is
respected and there's no preference of one protocol over another.</dd>
</dl>
<a name="strict_super_seeding"></a><dl class="docutils">
<dt>strict_super_seeding</dt>
<dd>when this is set to true, a piece has to have been forwarded to a
third peer before another one is handed out. This is the traditional
definition of super seeding.</dd>
</dl>
<a name="seeding_piece_quota"></a><dl class="docutils">
<dt>seeding_piece_quota</dt>
<dd>the number of pieces to send to a peer, when seeding, before rotating
in another peer to the unchoke set. It defaults to 3 pieces, which
means that when seeding, any peer we've sent more than this number of
pieces to will be unchoked in favour of a choked peer.</dd>
</dl>
<a name="max_sparse_regions"></a><dl class="docutils">
<dt>max_sparse_regions</dt>
<dd>is a limit of the number of <em>sparse regions</em> in a torrent. A sparse
region is defined as a hole of pieces we have not yet downloaded, in
between pieces that have been downloaded. This is used as a hack for
windows vista which has a bug where you cannot write files with more
than a certain number of sparse regions. This limit is not hard, it
will be exceeded. Once it's exceeded, pieces that will maintain or
decrease the number of sparse regions are prioritized. To disable this
functionality, set this to 0. It defaults to 0 on all platforms except
windows.</dd>
</dl>
<a name="lock_disk_cache"></a><dl class="docutils">
<dt>lock_disk_cache</dt>
<dd>if lock disk cache is set to true the disk cache that's in use, will
be locked in physical memory, preventing it from being swapped out.</dd>
</dl>
<a name="max_rejects"></a><dl class="docutils">
<dt>max_rejects</dt>
<dd>the number of piece requests we will reject in a row while a peer is
choked before the peer is considered abusive and is disconnected.</dd>
</dl>
<a name="recv_socket_buffer_size"></a>
<a name="send_socket_buffer_size"></a><dl class="docutils">
<dt>recv_socket_buffer_size  send_socket_buffer_size</dt>
<dd>specifies the buffer sizes set on peer sockets. 0 (which is the
default) means the OS default (i.e. don't change the buffer sizes).
The socket buffer sizes are changed using setsockopt() with
SOL_SOCKET/SO_RCVBUF and SO_SNDBUFFER.</dd>
</dl>
<a name="optimize_hashing_for_speed"></a><dl class="docutils">
<dt>optimize_hashing_for_speed</dt>
<dd>chooses between two ways of reading back piece data from disk when its
complete and needs to be verified against the piece hash. This happens
if some blocks were flushed to the disk out of order. Everything that
is flushed in order is hashed as it goes along. Optimizing for speed
will allocate space to fit all the the remaingin, unhashed, part of
the piece, reads the data into it in a single call and hashes it. This
is the default. If <tt class="docutils literal">optimizing_hashing_for_speed</tt> is false, a single
block will be allocated (16 kB), and the unhashed parts of the piece
are read, one at a time, and hashed in this single block. This is
appropriate on systems that are memory constrained.</dd>
</dl>
<a name="file_checks_delay_per_block"></a><dl class="docutils">
<dt>file_checks_delay_per_block</dt>
<dd>the number of milliseconds to sleep
in between disk read operations when checking torrents. This defaults
to 0, but can be set to higher numbers to slow down the rate at which
data is read from the disk while checking. This may be useful for
background tasks that doesn't matter if they take a bit longer, as long
as they leave disk I/O time for other processes.</dd>
</dl>
<a name="disk_cache_algorithm"></a><dl class="docutils">
<dt>disk_cache_algorithm</dt>
<dd>tells the disk I/O thread which cache flush algorithm to use.
This is specified by the <a class="reference external" href="reference-Settings.html#disk_cache_algo_t">disk_cache_algo_t</a> enum.</dd>
</dl>
<a name="read_cache_line_size"></a><dl class="docutils">
<dt>read_cache_line_size</dt>
<dd><p class="first">the number of blocks to read into the read cache when a read cache
miss occurs. Setting this to 0 is essentially the same thing as
disabling read cache. The number of blocks read into the read cache is
always capped by the piece boundry.</p>
<p class="last">When a piece in the write cache has <tt class="docutils literal">write_cache_line_size</tt>
contiguous blocks in it, they will be flushed. Setting this to 1
effectively disables the write cache.</p>
</dd>
</dl>
<a name="write_cache_line_size"></a><dl class="docutils">
<dt>write_cache_line_size</dt>
<dd>whenever a contiguous range of this many blocks is found in the write
cache, it is flushed immediately</dd>
</dl>
<a name="optimistic_disk_retry"></a><dl class="docutils">
<dt>optimistic_disk_retry</dt>
<dd><p class="first">the number of seconds from a disk write errors occur on a torrent
until libtorrent will take it out of the upload mode, to test if the
error condition has been fixed.</p>
<p>libtorrent will only do this automatically for auto managed torrents.</p>
<p class="last">You can explicitly take a torrent out of upload only mode using
<a class="reference external" href="reference-Core.html#set_upload_mode()">set_upload_mode()</a>.</p>
</dd>
</dl>
<a name="disable_hash_checks"></a><dl class="docutils">
<dt>disable_hash_checks</dt>
<dd>controls if downloaded pieces are verified against the piece hashes in
the torrent file or not. The default is false, i.e. to verify all
downloaded data. It may be useful to turn this off for performance
profiling and simulation scenarios. Do not disable the hash check for
regular bittorrent clients.</dd>
</dl>
<a name="allow_reordered_disk_operations"></a><dl class="docutils">
<dt>allow_reordered_disk_operations</dt>
<dd>if this is true, disk read operations may be re-ordered based on their
physical disk read offset. This greatly improves throughput when
uploading to many peers. This assumes a traditional hard drive with a
read head and spinning platters. If your storage medium is a solid
state drive, this optimization doesn't give you an benefits</dd>
</dl>
<a name="allow_i2p_mixed"></a><dl class="docutils">
<dt>allow_i2p_mixed</dt>
<dd>if this is true, i2p torrents are allowed to also get peers from other
sources than the tracker, and connect to regular IPs, not providing
any anonymization. This may be useful if the user is not interested in
the anonymization of i2p, but still wants to be able to connect to i2p
peers.</dd>
</dl>
<a name="max_suggest_pieces"></a><dl class="docutils">
<dt>max_suggest_pieces</dt>
<dd>the max number of suggested piece indices received from a peer that's
remembered. If a peer floods suggest messages, this limit prevents
libtorrent from using too much RAM. It defaults to 10.</dd>
</dl>
<a name="drop_skipped_requests"></a><dl class="docutils">
<dt>drop_skipped_requests</dt>
<dd>If set to true (it defaults to false), piece requests that have been
skipped enough times when piece messages are received, will be
considered lost. Requests are considered skipped when the returned
piece messages are re-ordered compared to the order of the requests.
This was an attempt to get out of dead-locks caused by BitComet peers
silently ignoring some requests. It may cause problems at high rates,
and high level of reordering in the uploading peer, that's why it's
disabled by default.</dd>
</dl>
<a name="low_prio_disk"></a><dl class="docutils">
<dt>low_prio_disk</dt>
<dd>determines if the disk I/O should use a normal
or low priority policy. This defaults to true, which means that
it's low priority by default. Other processes doing disk I/O will
normally take priority in this mode. This is meant to improve the
overall responsiveness of the system while downloading in the
background. For high-performance server setups, this might not
be desirable.</dd>
</dl>
<a name="local_service_announce_interval"></a><dl class="docutils">
<dt>local_service_announce_interval</dt>
<dd>the time between local
network announces for a torrent. By default, when local service
discovery is enabled a torrent announces itself every 5 minutes.
This interval is specified in seconds.</dd>
</dl>
<a name="dht_announce_interval"></a><dl class="docutils">
<dt>dht_announce_interval</dt>
<dd>the number of seconds between announcing
torrents to the distributed hash table (DHT). This is specified to
be 15 minutes which is its default.</dd>
</dl>
<a name="udp_tracker_token_expiry"></a><dl class="docutils">
<dt>udp_tracker_token_expiry</dt>
<dd>the number of seconds libtorrent
will keep UDP tracker connection tokens around for. This is specified
to be 60 seconds, and defaults to that. The higher this value is, the
fewer packets have to be sent to the UDP tracker. In order for higher
values to work, the tracker needs to be configured to match the
expiration time for tokens.</dd>
</dl>
<a name="volatile_read_cache"></a><dl class="docutils">
<dt>volatile_read_cache</dt>
<dd>if this is set to true, read cache blocks
that are hit by peer read requests are removed from the disk cache
to free up more space. This is useful if you don't expect the disk
cache to create any cache hits from other peers than the one who
triggered the cache line to be read into the cache in the first place.</dd>
</dl>
<a name="guided_read_cache"></a><dl class="docutils">
<dt>guided_read_cache</dt>
<dd>enables the disk cache to adjust the size
of a cache line generated by peers to depend on the upload rate
you are sending to that peer. The intention is to optimize the RAM
usage of the cache, to read ahead further for peers that you're
sending faster to.</dd>
</dl>
<a name="default_cache_min_age"></a><dl class="docutils">
<dt>default_cache_min_age</dt>
<dd>the minimum number of seconds any read cache line is kept in the
cache. This defaults to one second but may be greater if
<tt class="docutils literal">guided_read_cache</tt> is enabled. Having a lower bound on the time a
cache line stays in the cache is an attempt to avoid swapping the same
pieces in and out of the cache in case there is a shortage of spare
cache space.</dd>
</dl>
<a name="num_optimistic_unchoke_slots"></a><dl class="docutils">
<dt>num_optimistic_unchoke_slots</dt>
<dd>the number of optimistic unchoke slots to use. It defaults to 0, which
means automatic. Having a higher number of optimistic unchoke slots
mean you will find the good peers faster but with the trade-off to use
up more bandwidth. When this is set to 0, libtorrent opens up 20% of
your allowed upload slots as optimistic unchoke slots.</dd>
</dl>
<a name="no_atime_storage"></a><dl class="docutils">
<dt>no_atime_storage</dt>
<dd>this is a linux-only option and passes in the <tt class="docutils literal">O_NOATIME</tt> to
<tt class="docutils literal">open()</tt> when opening files. This may lead to some disk performance
improvements.</dd>
</dl>
<a name="default_est_reciprocation_rate"></a><dl class="docutils">
<dt>default_est_reciprocation_rate</dt>
<dd>the assumed reciprocation rate from peers when using the BitTyrant
choker. This defaults to 14 kiB/s. If set too high, you will
over-estimate your peers and be more altruistic while finding the true
reciprocation rate, if it's set too low, you'll be too stingy and
waste finding the true reciprocation rate.</dd>
</dl>
<a name="increase_est_reciprocation_rate"></a><dl class="docutils">
<dt>increase_est_reciprocation_rate</dt>
<dd>specifies how many percent the extimated reciprocation rate should be
increased by each unchoke interval a peer is still choking us back.
This defaults to 20%. This only applies to the BitTyrant choker.</dd>
</dl>
<a name="decrease_est_reciprocation_rate"></a><dl class="docutils">
<dt>decrease_est_reciprocation_rate</dt>
<dd>specifies how many percent the estimated reciprocation rate should be
decreased by each unchoke interval a peer unchokes us. This default to
3%. This only applies to the BitTyrant choker.</dd>
</dl>
<a name="incoming_starts_queued_torrents"></a><dl class="docutils">
<dt>incoming_starts_queued_torrents</dt>
<dd>defaults to false. If a torrent has been paused by the auto managed
feature in libtorrent, i.e. the torrent is paused and auto managed,
this feature affects whether or not it is automatically started on an
incoming connection. The main reason to queue torrents, is not to make
them unavailable, but to save on the overhead of announcing to the
trackers, the DHT and to avoid spreading one's unchoke slots too thin.
If a peer managed to find us, even though we're no in the torrent
anymore, this setting can make us start the torrent and serve it.</dd>
</dl>
<a name="report_true_downloaded"></a><dl class="docutils">
<dt>report_true_downloaded</dt>
<dd>when set to true, the downloaded counter sent to trackers will include
the actual number of payload bytes donwnloaded including redundant
bytes. If set to false, it will not include any redundany bytes</dd>
</dl>
<a name="strict_end_game_mode"></a><dl class="docutils">
<dt>strict_end_game_mode</dt>
<dd>defaults to true, and controls when a block may be requested twice. If
this is <tt class="docutils literal">true</tt>, a block may only be requested twice when there's ay
least one request to every piece that's left to download in the
torrent. This may slow down progress on some pieces sometimes, but it
may also avoid downloading a lot of redundant bytes. If this is
<tt class="docutils literal">false</tt>, libtorrent attempts to use each peer connection to its max,
by always requesting something, even if it means requesting something
that has been requested from another peer already.</dd>
</dl>
<a name="broadcast_lsd"></a><dl class="docutils">
<dt>broadcast_lsd</dt>
<dd>if set to true, the local peer discovery (or Local Service Discovery)
will not only use IP multicast, but also broadcast its messages. This
can be useful when running on networks that don't support multicast.
Since broadcast messages might be expensive and disruptive on
networks, only every 8th announce uses broadcast.</dd>
</dl>
<a name="enable_outgoing_utp"></a>
<a name="enable_incoming_utp"></a>
<a name="enable_outgoing_tcp"></a>
<a name="enable_incoming_tcp"></a><dl class="docutils">
<dt>enable_outgoing_utp  enable_incoming_utp  enable_outgoing_tcp  enable_incoming_tcp</dt>
<dd>these all determines if libtorrent should attempt to make outgoing
connections of the specific type, or allow incoming connection. By
default all of them are enabled.</dd>
</dl>
<a name="max_pex_peers"></a><dl class="docutils">
<dt>max_pex_peers</dt>
<dd>the max number of peers we accept from pex messages from a single peer.
this limits the number of concurrent peers any of our peers claims to
be connected to. If they clain to be connected to more than this, we'll
ignore any peer that exceeds this limit</dd>
</dl>
<a name="ignore_resume_timestamps"></a><dl class="docutils">
<dt>ignore_resume_timestamps</dt>
<dd>determines if the storage, when loading resume data files, should
verify that the file modification time with the timestamps in the
resume data. This defaults to false, which means timestamps are taken
into account, and resume data is less likely to accepted (torrents are
more likely to be fully checked when loaded). It might be useful to
set this to true if your network is faster than your disk, and it
would be faster to redownload potentially missed pieces than to go
through the whole storage to look for them.</dd>
</dl>
<a name="no_recheck_incomplete_resume"></a><dl class="docutils">
<dt>no_recheck_incomplete_resume</dt>
<dd>determines if the storage should check the whole files when resume
data is incomplete or missing or whether it should simply assume we
don't have any of the data. By default, this is determined by the
existance of any of the files. By setting this setting to true, the
files won't be checked, but will go straight to download mode.</dd>
</dl>
<a name="anonymous_mode"></a><dl class="docutils">
<dt>anonymous_mode</dt>
<dd><p class="first">defaults to false. When set to true, the client tries to hide its
identity to a certain degree. The peer-ID will no longer include the
client's fingerprint. The user-agent will be reset to an empty string.
It will also try to not leak other identifying information, such as
your local listen port, your IP etc.</p>
<p class="last">If you're using I2P, a VPN or a proxy, it might make sense to enable
anonymous mode.</p>
</dd>
</dl>
<a name="force_proxy"></a><dl class="docutils">
<dt>force_proxy</dt>
<dd>disables any communication that's not going over a proxy. Enabling
this requires a proxy to be configured as well, see
<tt class="docutils literal">set_proxy_settings</tt>. The listen sockets are closed, and incoming
connections will only be accepted through a SOCKS5 or I2P proxy (if a
peer proxy is set up and is run on the same machine as the tracker
proxy). This setting also disabled peer country lookups, since those
are done via DNS lookups that aren't supported by proxies.</dd>
</dl>
<a name="tick_interval"></a><dl class="docutils">
<dt>tick_interval</dt>
<dd>specifies the number of milliseconds between internal ticks. This is
the frequency with which bandwidth quota is distributed to peers. It
should not be more than one second (i.e. 1000 ms). Setting this to a
low value (around 100) means higher resolution bandwidth quota
distribution, setting it to a higher value saves CPU cycles.</dd>
</dl>
<a name="report_web_seed_downloads"></a><dl class="docutils">
<dt>report_web_seed_downloads</dt>
<dd>specifies whether downloads from web seeds is reported to the
tracker or not. Defaults to on</dd>
</dl>
<a name="share_mode_target"></a><dl class="docutils">
<dt>share_mode_target</dt>
<dd>specifies the target share ratio for share mode torrents. This
defaults to 3, meaning we'll try to upload 3 times as much as we
download. Setting this very high, will make it very conservative and
you might end up not downloading anything ever (and not affecting your
share ratio). It does not make any sense to set this any lower than 2.
For instance, if only 3 peers need to download the rarest piece, it's
impossible to download a single piece and upload it more than 3 times.
If the share_mode_target is set to more than 3, nothing is downloaded.</dd>
</dl>
<a name="upload_rate_limit"></a>
<a name="download_rate_limit"></a>
<a name="local_upload_rate_limit"></a>
<a name="local_download_rate_limit"></a><dl class="docutils">
<dt>upload_rate_limit  download_rate_limit  local_upload_rate_limit  local_download_rate_limit</dt>
<dd><p class="first">sets the session-global limits of upload and download rate limits, in
bytes per second. The local rates refer to peers on the local network.
By default peers on the local network are not rate limited.</p>
<p>These rate limits are only used for local peers (peers within the same
subnet as the client itself) and it is only used when
<tt class="docutils literal"><span class="pre">session_settings::ignore_limits_on_local_network</span></tt> is set to true
(which it is by default). These rate limits default to unthrottled,
but can be useful in case you want to treat local peers
preferentially, but not quite unthrottled.</p>
<p class="last">A value of 0 means unlimited.</p>
</dd>
</dl>
<a name="dht_upload_rate_limit"></a><dl class="docutils">
<dt>dht_upload_rate_limit</dt>
<dd>sets the rate limit on the DHT. This is specified in bytes per second
and defaults to 4000. For busy boxes with lots of torrents that
requires more DHT traffic, this should be raised.</dd>
</dl>
<a name="unchoke_slots_limit"></a><dl class="docutils">
<dt>unchoke_slots_limit</dt>
<dd>the max number of unchoked peers in the <a class="reference external" href="reference-Session.html#session">session</a>. The number of unchoke
slots may be ignored depending on what <tt class="docutils literal">choking_algorithm</tt> is set
to. A value of -1 means infinite.</dd>
</dl>
<a name="half_open_limit"></a><dl class="docutils">
<dt>half_open_limit</dt>
<dd>sets the maximum number of half-open connections libtorrent will have
when connecting to peers. A half-open connection is one where
connect() has been called, but the connection still hasn't been
established (nor failed). Windows XP Service Pack 2 sets a default,
system wide, limit of the number of half-open connections to 10. So,
this limit can be used to work nicer together with other network
applications on that system. The default is to have no limit, and
passing -1 as the limit, means to have no limit. When limiting the
number of simultaneous connection attempts, peers will be put in a
queue waiting for their turn to get connected.</dd>
</dl>
<a name="connections_limit"></a><dl class="docutils">
<dt>connections_limit</dt>
<dd>sets a global limit on the number of connections opened. The number of
connections is set to a hard minimum of at least two per torrent, so
if you set a too low connections limit, and open too many torrents,
the limit will not be met.</dd>
</dl>
<a name="connections_slack"></a><dl class="docutils">
<dt>connections_slack</dt>
<dd>the number of extra incoming connections allowed temporarily, in order
to support replacing peers</dd>
</dl>
<a name="utp_target_delay"></a><dl class="docutils">
<dt>utp_target_delay</dt>
<dd>the target delay for uTP sockets in milliseconds. A high value will
make uTP connections more aggressive and cause longer queues in the
upload bottleneck. It cannot be too low, since the noise in the
measurements would cause it to send too slow. The default is 50
milliseconds.</dd>
</dl>
<a name="utp_gain_factor"></a><dl class="docutils">
<dt>utp_gain_factor</dt>
<dd>the number of bytes the uTP congestion window can increase at the most
in one RTT. This defaults to 300 bytes. If this is set too high, the
congestion controller reacts too hard to noise and will not be stable,
if it's set too low, it will react slow to congestion and not back off
as fast.</dd>
</dl>
<a name="utp_min_timeout"></a><dl class="docutils">
<dt>utp_min_timeout</dt>
<dd><p class="first">the shortest allowed uTP socket timeout, specified in milliseconds.
This defaults to 500 milliseconds. The timeout depends on the RTT of
the connection, but is never smaller than this value. A connection
times out when every packet in a window is lost, or when a packet is
lost twice in a row (i.e. the resent packet is lost as well).</p>
<p class="last">The shorter the timeout is, the faster the connection will recover
from this situation, assuming the RTT is low enough.</p>
</dd>
</dl>
<a name="utp_syn_resends"></a><dl class="docutils">
<dt>utp_syn_resends</dt>
<dd>the number of SYN packets that are sent (and timed out) before
giving up and closing the socket.</dd>
</dl>
<a name="utp_fin_resends"></a><dl class="docutils">
<dt>utp_fin_resends</dt>
<dd>the number of resent packets sent on a closed socket before giving up</dd>
</dl>
<a name="utp_num_resends"></a><dl class="docutils">
<dt>utp_num_resends</dt>
<dd>the number of times a packet is sent (and lossed or timed out)
before giving up and closing the connection.</dd>
</dl>
<a name="utp_connect_timeout"></a><dl class="docutils">
<dt>utp_connect_timeout</dt>
<dd>the number of milliseconds of timeout for the initial SYN packet for
uTP connections. For each timed out packet (in a row), the timeout is
doubled.</dd>
</dl>
<a name="utp_dynamic_sock_buf"></a><dl class="docutils">
<dt>utp_dynamic_sock_buf</dt>
<dd>controls if the uTP socket manager is allowed to increase the socket
buffer if a network interface with a large MTU is used (such as
loopback or ethernet jumbo frames). This defaults to true and might
improve uTP throughput. For RAM constrained systems, disabling this
typically saves around 30kB in user space and probably around 400kB in
kernel socket buffers (it adjusts the send and receive buffer size on
the kernel socket, both for IPv4 and IPv6).</dd>
</dl>
<a name="utp_loss_multiplier"></a><dl class="docutils">
<dt>utp_loss_multiplier</dt>
<dd>controls how the congestion window is changed when a packet loss is
experienced. It's specified as a percentage multiplier for <tt class="docutils literal">cwnd</tt>.
By default it's set to 50 (i.e. cut in half). Do not change this value
unless you know what you're doing. Never set it higher than 100.</dd>
</dl>
<a name="mixed_mode_algorithm"></a><dl class="docutils">
<dt>mixed_mode_algorithm</dt>
<dd><p class="first">determines how to treat TCP connections when there are uTP
connections. Since uTP is designed to yield to TCP, there's an
inherent problem when using swarms that have both TCP and uTP
connections. If nothing is done, uTP connections would often be
starved out for bandwidth by the TCP connections. This mode is
<tt class="docutils literal">prefer_tcp</tt>. The <tt class="docutils literal">peer_proportional</tt> mode simply looks at the
current throughput and rate limits all TCP connections to their
proportional share based on how many of the connections are TCP. This
works best if uTP connections are not rate limited by the global rate
limiter, see rate_limit_utp.</p>
<p class="last">see <a class="reference external" href="reference-Settings.html#bandwidth_mixed_algo_t">bandwidth_mixed_algo_t</a> for options.</p>
</dd>
</dl>
<a name="rate_limit_utp"></a><dl class="docutils">
<dt>rate_limit_utp</dt>
<dd>determines if uTP connections should be throttled by the global rate
limiter or not. By default they are.</dd>
</dl>
<a name="listen_queue_size"></a><dl class="docutils">
<dt>listen_queue_size</dt>
<dd>the value passed in to listen() for the listen socket. It is the
number of outstanding incoming connections to queue up while we're not
actively waiting for a connection to be accepted. The default is 5
which should be sufficient for any normal client. If this is a high
performance server which expects to receive a lot of connections, or
used in a simulator or test, it might make sense to raise this number.
It will not take affect until <a class="reference external" href="reference-Session.html#listen_on()">listen_on()</a> is called again (or for the
first time).</dd>
</dl>
<a name="announce_double_nat"></a><dl class="docutils">
<dt>announce_double_nat</dt>
<dd>if true, the <tt class="docutils literal">&amp;ip=</tt> argument in tracker requests (unless otherwise
specified) will be set to the intermediate IP address, if the user is
double NATed. If ther user is not double NATed, this option has no
affect.</dd>
</dl>
<a name="torrent_connect_boost"></a><dl class="docutils">
<dt>torrent_connect_boost</dt>
<dd>the number of peers to try to connect to immediately when the first
tracker response is received for a torrent. This is a boost to given
to new torrents to accelerate them starting up. The normal connect
scheduler is run once every second, this allows peers to be connected
immediately instead of waiting for the <a class="reference external" href="reference-Session.html#session">session</a> tick to trigger
connections.</dd>
</dl>
<a name="seeding_outgoing_connections"></a><dl class="docutils">
<dt>seeding_outgoing_connections</dt>
<dd>determines if seeding (and finished) torrents should attempt to make
outgoing connections or not. By default this is true. It may be set to
false in very specific applications where the cost of making outgoing
connections is high, and there are no or small benefits of doing so.
For instance, if no nodes are behind a firewall or a NAT, seeds don't
need to make outgoing connections.</dd>
</dl>
<a name="no_connect_privileged_ports"></a><dl class="docutils">
<dt>no_connect_privileged_ports</dt>
<dd>if true (which is the default), libtorrent will not connect to any
peers on priviliged ports (&lt;= 1023). This can mitigate using
bittorrent swarms for certain DDoS attacks.</dd>
</dl>
<a name="alert_queue_size"></a><dl class="docutils">
<dt>alert_queue_size</dt>
<dd>the maximum number of alerts queued up internally. If alerts are not
popped, the queue will eventually fill up to this level. This defaults
to 1000.</dd>
</dl>
<a name="max_metadata_size"></a><dl class="docutils">
<dt>max_metadata_size</dt>
<dd>the maximum allowed size (in bytes) to be received
by the metadata extension, i.e. magnet links. It defaults to 1 MiB.</dd>
</dl>
<a name="smooth_connects"></a><dl class="docutils">
<dt>smooth_connects</dt>
<dd>true by default, which means the number of connection attempts per
second may be limited to below the <tt class="docutils literal">connection_speed</tt>, in case we're
close to bump up against the limit of number of connections. The
intention of this setting is to more evenly distribute our connection
attempts over time, instead of attempting to connectin in batches, and
timing them out in batches.</dd>
</dl>
<a name="always_send_user_agent"></a><dl class="docutils">
<dt>always_send_user_agent</dt>
<dd>defaults to false. When set to true, web connections will include a
user-agent with every request, as opposed to just the first request in
a connection.</dd>
</dl>
<a name="apply_ip_filter_to_trackers"></a><dl class="docutils">
<dt>apply_ip_filter_to_trackers</dt>
<dd>defaults to true. It determines whether the IP filter applies to
trackers as well as peers. If this is set to false, trackers are
exempt from the IP filter (if there is one). If no IP filter is set,
this setting is irrelevant.</dd>
</dl>
<a name="read_job_every"></a><dl class="docutils">
<dt>read_job_every</dt>
<dd>used to avoid starvation of read jobs in the disk I/O thread. By
default, read jobs are deferred, sorted by physical disk location and
serviced once all write jobs have been issued. In scenarios where the
download rate is enough to saturate the disk, there's a risk the read
jobs will never be serviced. With this setting, every <em>x</em> write job,
issued in a row, will instead pick one read job off of the sorted
queue, where <em>x</em> is <tt class="docutils literal">read_job_every</tt>.</dd>
</dl>
<a name="use_disk_read_ahead"></a><dl class="docutils">
<dt>use_disk_read_ahead</dt>
<dd>defaults to true and will attempt to optimize disk reads by giving the
operating system heads up of disk read requests as they are queued in
the disk job queue. This gives a significant performance boost for
seeding.</dd>
</dl>
<a name="lock_files"></a><dl class="docutils">
<dt>lock_files</dt>
<dd>determines whether or not to lock files which libtorrent is
downloading to or seeding from. This is implemented using
<tt class="docutils literal">fcntl(F_SETLK)</tt> on unix systems and by not passing in
<tt class="docutils literal">SHARE_READ</tt> and <tt class="docutils literal">SHARE_WRITE</tt> on windows. This might prevent 3rd
party processes from corrupting the files under libtorrent's feet.</dd>
</dl>
<a name="ssl_listen"></a><dl class="docutils">
<dt>ssl_listen</dt>
<dd><p class="first">sets the listen port for SSL connections. If this is set to 0, no SSL
listen port is opened. Otherwise a socket is opened on this port. This
setting is only taken into account when opening the regular listen
port, and won't re-open the listen socket simply by changing this
setting.</p>
<p>if this is 0, outgoing SSL connections are disabled</p>
<p class="last">It defaults to port 4433.</p>
</dd>
</dl>
<a name="tracker_backoff"></a><dl class="docutils">
<dt>tracker_backoff</dt>
<dd><p class="first"><tt class="docutils literal">tracker_backoff</tt> determines how aggressively to back off from
retrying failing trackers. This value determines <em>x</em> in the following
formula, determining the number of seconds to wait until the next
retry:</p>
<blockquote>
delay = 5 + 5 * x / 100 * fails^2</blockquote>
<p>It defaults to 250.</p>
<p class="last">This setting may be useful to make libtorrent more or less aggressive
in hitting trackers.</p>
</dd>
</dl>
<a name="ban_web_seeds"></a><dl class="docutils">
<dt>ban_web_seeds</dt>
<dd>enables banning web seeds. By default, web seeds that send corrupt
data are banned.</dd>
</dl>
<a name="max_http_recv_buffer_size"></a><dl class="docutils">
<dt>max_http_recv_buffer_size</dt>
<dd>specifies the max number of bytes to receive into RAM buffers when
downloading stuff over HTTP. Specifically when specifying a URL to a
.torrent file when adding a torrent or when announcing to an HTTP
tracker. The default is 2 MiB.</dd>
</dl>
<a name="support_share_mode"></a><dl class="docutils">
<dt>support_share_mode</dt>
<dd>enables or disables the share mode extension. This is enabled by
default.</dd>
</dl>
<a name="support_merkle_torrents"></a><dl class="docutils">
<dt>support_merkle_torrents</dt>
<dd>enables or disables the merkle tree torrent support. This is enabled
by default.</dd>
</dl>
<a name="report_redundant_bytes"></a><dl class="docutils">
<dt>report_redundant_bytes</dt>
<dd>enables or disables reporting redundant bytes to the tracker. This is
enabled by default.</dd>
</dl>
<a name="handshake_client_version"></a><dl class="docutils">
<dt>handshake_client_version</dt>
<dd>the version string to advertise for this client in the peer protocol
handshake. If this is empty the user_agent is used</dd>
</dl>
<a name="use_disk_cache_pool"></a><dl class="docutils">
<dt>use_disk_cache_pool</dt>
<dd>if this is true, the disk cache uses a pool allocator for disk cache
blocks. Enabling this improves performance of the disk cache with the
side effect that the disk cache is less likely and slower at returning
memory to the kernel when cache pressure is low.</dd>
</dl>
<a name="inactive_down_rate"></a>
<a name="inactive_up_rate"></a><dl class="docutils">
<dt>inactive_down_rate  inactive_up_rate</dt>
<dd>the download and upload rate limits for a torrent to be considered
active by the queuing mechanism. A torrent whose download rate is less
than <tt class="docutils literal">inactive_down_rate</tt> and whose upload rate is less than
<tt class="docutils literal">inactive_up_rate</tt> for <tt class="docutils literal">auto_manage_startup</tt> seconds, is
considered inactive, and another queued torrent may be startert.
This logic is disabled if <tt class="docutils literal">dont_count_slow_torrents</tt> is false.</dd>
</dl>
<a name="dht_settings"></a></div>
</div>
<div class="section" id="dht-settings">
<h1>dht_settings</h1>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<p>structure used to hold configuration options for the DHT</p>
<p>The <tt class="docutils literal">dht_settings</tt> struct used to contain a <tt class="docutils literal">service_port</tt> member to
control which port the DHT would listen on and send messages from. This
field is deprecated and ignored. libtorrent always tries to open the UDP
socket on the same port as the TCP socket.</p>
<pre class="literal-block">
struct dht_settings
{
   <strong>dht_settings</strong> ();

   int max_peers_reply;
   int search_branching;
   int max_fail_count;
   int max_torrents;
   int max_dht_items;
   int max_torrent_search_reply;
   bool restrict_routing_ips;
   bool restrict_search_ips;
   bool extended_routing_table;
   bool aggressive_lookups;
   bool privacy_lookups;
   bool enforce_node_id;
   bool ignore_dark_internet;
};
</pre>
<a name="dht_settings()"></a><div class="section" id="id34">
<h2>dht_settings()</h2>
<pre class="literal-block">
<strong>dht_settings</strong> ();
</pre>
<p>initialized <a class="reference external" href="reference-Settings.html#dht_settings">dht_settings</a> to the default values</p>
<a name="max_peers_reply"></a><dl class="docutils">
<dt>max_peers_reply</dt>
<dd>the maximum number of peers to send in a reply to <tt class="docutils literal">get_peers</tt></dd>
</dl>
<a name="search_branching"></a><dl class="docutils">
<dt>search_branching</dt>
<dd>the number of concurrent search request the node will send when
announcing and refreshing the routing table. This parameter is called
alpha in the kademlia paper</dd>
</dl>
<a name="max_fail_count"></a><dl class="docutils">
<dt>max_fail_count</dt>
<dd>the maximum number of failed tries to contact a node before it is
removed from the routing table. If there are known working nodes that
are ready to replace a failing node, it will be replaced immediately,
this limit is only used to clear out nodes that don't have any node
that can replace them.</dd>
</dl>
<a name="max_torrents"></a><dl class="docutils">
<dt>max_torrents</dt>
<dd>the total number of torrents to track from the DHT. This is simply an
upper limit to make sure malicious DHT nodes cannot make us allocate
an unbounded amount of memory.</dd>
</dl>
<a name="max_dht_items"></a><dl class="docutils">
<dt>max_dht_items</dt>
<dd>max number of items the DHT will store</dd>
</dl>
<a name="max_torrent_search_reply"></a><dl class="docutils">
<dt>max_torrent_search_reply</dt>
<dd>the max number of torrents to return in a torrent search query to the
DHT</dd>
</dl>
<a name="restrict_routing_ips"></a><dl class="docutils">
<dt>restrict_routing_ips</dt>
<dd><p class="first">determines if the routing table entries should restrict entries to one
per IP. This defaults to true, which helps mitigate some attacks on
the DHT. It prevents adding multiple nodes with IPs with a very close
CIDR distance.</p>
<p class="last">when set, nodes whose IP address that's in the same /24 (or /64 for
IPv6) range in the same routing table bucket. This is an attempt to
mitigate node ID spoofing attacks also restrict any IP to only have a
single <a class="reference external" href="reference-Bencoding.html#entry">entry</a> in the whole routing table</p>
</dd>
</dl>
<a name="restrict_search_ips"></a><dl class="docutils">
<dt>restrict_search_ips</dt>
<dd>determines if DHT searches should prevent adding nodes with IPs with
very close CIDR distance. This also defaults to true and helps
mitigate certain attacks on the DHT.</dd>
</dl>
<a name="extended_routing_table"></a><dl class="docutils">
<dt>extended_routing_table</dt>
<dd>makes the first buckets in the DHT routing table fit 128, 64, 32 and
16 nodes respectively, as opposed to the standard size of 8. All other
buckets have size 8 still.</dd>
</dl>
<a name="aggressive_lookups"></a><dl class="docutils">
<dt>aggressive_lookups</dt>
<dd>slightly changes the lookup behavior in terms of how many outstanding
requests we keep. Instead of having branch factor be a hard limit, we
always keep <em>branch factor</em> outstanding requests to the closest nodes.
i.e. every time we get results back with closer nodes, we query them
right away. It lowers the lookup times at the cost of more outstanding
queries.</dd>
</dl>
<a name="privacy_lookups"></a><dl class="docutils">
<dt>privacy_lookups</dt>
<dd>when set, perform lookups in a way that is slightly more expensive,
but which minimizes the amount of information leaked about you.</dd>
</dl>
<a name="enforce_node_id"></a><dl class="docutils">
<dt>enforce_node_id</dt>
<dd>when set, node's whose IDs that are not correctly generated based on
its external IP are ignored. When a query arrives from such node, an
error message is returned with a message saying &quot;invalid node ID&quot;.</dd>
</dl>
<a name="ignore_dark_internet"></a><dl class="docutils">
<dt>ignore_dark_internet</dt>
<dd>ignore DHT messages from parts of the internet we wouldn't expect to
see any traffic from</dd>
</dl>
<a name="pe_settings"></a></div>
</div>
<div class="section" id="pe-settings">
<h1>pe_settings</h1>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<p>The <tt class="docutils literal">pe_settings</tt> structure is used to control the settings related
to peer protocol encryption.</p>
<pre class="literal-block">
struct pe_settings
{
   <strong>pe_settings</strong> ();

   enum enc_policy
   {
      forced,
      enabled,
      disabled,
   };

   enum enc_level
   {
      plaintext,
      rc4,
      both,
   };

   boost::uint8_t out_enc_policy;
   boost::uint8_t in_enc_policy;
   boost::uint8_t allowed_enc_level;
   bool prefer_rc4;
};
</pre>
<a name="pe_settings()"></a><div class="section" id="id38">
<h2>pe_settings()</h2>
<pre class="literal-block">
<strong>pe_settings</strong> ();
</pre>
<p>initializes the encryption settings with the default vaues</p>
<a name="enc_policy"></a></div>
<div class="section" id="enum-enc-policy">
<h2>enum enc_policy</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="8%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>forced</td>
<td>0</td>
<td>Only encrypted connections are allowed. Incoming connections that
are not encrypted are closed and if the encrypted outgoing
connection fails, a non-encrypted retry will not be made.</td>
</tr>
<tr><td>enabled</td>
<td>1</td>
<td>encrypted connections are enabled, but non-encrypted connections
are allowed. An incoming non-encrypted connection will be accepted,
and if an outgoing encrypted connection fails, a non- encrypted
connection will be tried.</td>
</tr>
<tr><td>disabled</td>
<td>2</td>
<td>only non-encrypted connections are allowed.</td>
</tr>
</tbody>
</table>
<a name="enc_level"></a></div>
<div class="section" id="enum-enc-level">
<h2>enum enc_level</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session_settings.hpp">libtorrent/session_settings.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="14%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>plaintext</td>
<td>1</td>
<td>use only plaintext encryption</td>
</tr>
<tr><td>rc4</td>
<td>2</td>
<td>use only rc4 encryption</td>
</tr>
<tr><td>both</td>
<td>3</td>
<td>allow both</td>
</tr>
</tbody>
</table>
<a name="out_enc_policy"></a>
<a name="in_enc_policy"></a><dl class="docutils">
<dt>out_enc_policy  in_enc_policy</dt>
<dd>control the settings for incoming
and outgoing connections respectively.
see <a class="reference external" href="reference-Settings.html#enc_policy">enc_policy</a> enum for the available options.</dd>
</dl>
<a name="allowed_enc_level"></a><dl class="docutils">
<dt>allowed_enc_level</dt>
<dd>determines the encryption level of the
connections.  This setting will adjust which encryption scheme is
offered to the other peer, as well as which encryption scheme is
selected by the client. See <a class="reference external" href="reference-Settings.html#enc_level">enc_level</a> enum for options.</dd>
</dl>
<a name="prefer_rc4"></a><dl class="docutils">
<dt>prefer_rc4</dt>
<dd>if the allowed encryption level is both, setting this to
true will prefer rc4 if both methods are offered, plaintext
otherwise</dd>
</dl>
<a name="min_memory_usage()"></a>
<a name="high_performance_seed()"></a></div>
<div class="section" id="min-memory-usage-high-performance-seed">
<h2>min_memory_usage() high_performance_seed()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session.hpp">libtorrent/session.hpp</a>&quot;</p>
<pre class="literal-block">
session_settings <strong>min_memory_usage</strong> ();
session_settings <strong>high_performance_seed</strong> ();
</pre>
<p>The default values of the <a class="reference external" href="reference-Session.html#session">session</a> settings are set for a regular
bittorrent client running on a desktop system. There are functions that
can set the <a class="reference external" href="reference-Session.html#session">session</a> settings to pre set settings for other environments.
These can be used for the basis, and should be tweaked to fit your needs
better.</p>
<p><tt class="docutils literal">min_memory_usage</tt> returns settings that will use the minimal amount of
RAM, at the potential expense of upload and download performance. It
adjusts the socket buffer sizes, disables the disk cache, lowers the send
buffer watermarks so that each connection only has at most one block in
use at any one time. It lowers the outstanding blocks send to the disk
I/O thread so that connections only have one block waiting to be flushed
to disk at any given time. It lowers the max number of peers in the peer
list for torrents. It performs multiple smaller reads when it hashes
pieces, instead of reading it all into memory before hashing.</p>
<p>This configuration is inteded to be the starting point for embedded
devices. It will significantly reduce memory usage.</p>
<p><tt class="docutils literal">high_performance_seed</tt> returns settings optimized for a seed box,
serving many peers and that doesn't do any downloading. It has a 128 MB
disk cache and has a limit of 400 files in its file pool. It support fast
upload rates by allowing large send buffers.</p>
</div>
</div>
</div>
</body>
</html>
