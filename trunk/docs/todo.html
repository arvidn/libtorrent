<html><head>
<script type="text/javascript">
/* <![CDATA[ */
	var expanded = -1
	function expand(id) {
		if (expanded != -1) {
			var ctx = document.getElementById(expanded);
			ctx.style.display = "none";
			// if we're expanding the field that's already
			// expanded, just collapse it
			var no_expand = id == expanded;
			expanded = -1;
			if (no_expand) return;
		}
		var ctx = document.getElementById(id);
		ctx.style.display = "table-row";
		expanded = id;
	}
/* ]]> */
</script>

</head><body>
<h1>libtorrent todo-list</h1>
<span style="color: #f00">0 urgent</span>
<span style="color: #f77">6 important</span>
<span style="color: #3c3">50 relevant</span>
<span style="color: #77f">9 feasible</span>
<span style="color: #999">165 notes</span>
<table width="100%" border="1" style="border-collapse: collapse;"><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(0)">../src/file.cpp:481</a></td><td>find out what error code is reported when the filesystem does not support hard links.</td></tr><tr id="0" style="display: none;" colspan="3"><td colspan="3"><h2>find out what error code is reported when the filesystem
does not support hard links.</h2><h4>../src/file.cpp:481</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{
#ifdef TORRENT_WINDOWS

#if TORRENT_USE_WSTRING
#define CreateHardLink_ CreateHardLinkW
		std::wstring n_exist = convert_to_wstring(file);
		std::wstring n_link = convert_to_wstring(link);
#else
#define CreateHardLink_ CreateHardLinkA
		std::string n_exist = convert_to_native(file);
		std::string n_link = convert_to_native(link);
#endif
		BOOL ret = CreateHardLink(n_link.c_str(), n_exist.c_str(), NULL);
		if (ret)
		{
			ec.clear();
			return;
		}

		// something failed. Does the filesystem not support hard links?
<div style="background: #ffff00" width="100%">
</div>		// it's possible CreateHardLink will copy the file internally too,
		// if the filesystem does not support it.
		ec.assign(GetLastError(), system_category());
		return;

#else

		std::string n_exist = convert_to_native(file);
		std::string n_link = convert_to_native(link);

		// assume posix's link() function exists
		int ret = ::link(n_exist.c_str(), n_link.c_str());

		if (ret == 0)
		{
			ec.clear();
			return;
		}

		// most errors are passed through, except for the ones that indicate that
		// hard links are not supported and require a copy.
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(1)">../src/upnp.cpp:72</a></td><td>listen_interface is not used. It's meant to bind the broadcast socket</td></tr><tr id="1" style="display: none;" colspan="3"><td colspan="3"><h2>listen_interface is not used. It's meant to bind the broadcast socket</h2><h4>../src/upnp.cpp:72</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include &lt;asio/ip/multicast.hpp&gt;
#else
#include &lt;boost/asio/ip/host_name.hpp&gt;
#include &lt;boost/asio/ip/multicast.hpp&gt;
#endif
#include &lt;cstdlib&gt;

namespace libtorrent {

namespace upnp_errors
{
	boost::system::error_code make_error_code(error_code_enum e)
	{
		return error_code(e, get_upnp_category());
	}

} // upnp_errors namespace

static error_code ec;

<div style="background: #ffff00" width="100%">upnp::upnp(io_service&amp; ios
</div>	, address const&amp; listen_interface, std::string const&amp; user_agent
	, portmap_callback_t const&amp; cb, log_callback_t const&amp; lcb
	, bool ignore_nonrouters)
	: m_user_agent(user_agent)
	, m_callback(cb)
	, m_log_callback(lcb)
	, m_retry_count(0)
	, m_io_service(ios)
	, m_resolver(ios)
	, m_socket(udp::endpoint(address_v4::from_string("239.255.255.250", ec), 1900))
	, m_broadcast_timer(ios)
	, m_refresh_timer(ios)
	, m_map_timer(ios)
	, m_disabled(false)
	, m_closing(false)
	, m_ignore_non_routers(ignore_nonrouters)
	, m_last_if_update(min_time())
{
	TORRENT_ASSERT(cb);
}

void upnp::start(void* state)
{
	error_code ec;
	m_socket.open(boost::bind(&amp;upnp::on_reply, self(), _1, _2, _3)
		, m_refresh_timer.get_io_service(), ec);

	if (state)
	{
		upnp_state_t* s = (upnp_state_t*)state;
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(2)">../src/kademlia/get_item.cpp:220</a></td><td>we don't support CAS errors here! we need a custom observer</td></tr><tr id="2" style="display: none;" colspan="3"><td colspan="3"><h2>we don't support CAS errors here! we need a custom observer</h2><h4>../src/kademlia/get_item.cpp:220</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	TORRENT_LOG(node) &lt;&lt; "sending put [ v: \"" &lt;&lt; m_data.value()
		&lt;&lt; "\" seq: " &lt;&lt; (m_data.is_mutable() ? m_data.seq() : -1)
		&lt;&lt; " nodes: " &lt;&lt; v.size() &lt;&lt; " ]" ;
#endif

	// create a dummy traversal_algorithm
	boost::intrusive_ptr&lt;traversal_algorithm&gt; algo(
		new traversal_algorithm(m_node, (node_id::min)()));

	// store on the first k nodes
	for (std::vector&lt;std::pair&lt;node_entry, std::string&gt; &gt;::const_iterator i = v.begin()
		, end(v.end()); i != end; ++i)
	{
#ifdef TORRENT_DHT_VERBOSE_LOGGING
		TORRENT_LOG(node) &lt;&lt; "  put-distance: " &lt;&lt; (160 - distance_exp(m_target, i-&gt;first.id));
#endif

		void* ptr = m_node.m_rpc.allocate_observer();
		if (ptr == 0) return;

<div style="background: #ffff00" width="100%">		observer_ptr o(new (ptr) announce_observer(algo, i-&gt;first.ep(), i-&gt;first.id));
</div>#if TORRENT_USE_ASSERTS
		o-&gt;m_in_constructor = false;
#endif
		entry e;
		e["y"] = "q";
		e["q"] = "put";
		entry&amp; a = e["a"];
		a["v"] = m_data.value();
		a["token"] = i-&gt;second;
		if (m_data.is_mutable())
		{
			a["k"] = std::string(m_data.pk().data(), item_pk_len);
			a["seq"] = m_data.seq();
			a["sig"] = std::string(m_data.sig().data(), item_sig_len);
			if (!m_data.salt().empty())
			{
				a["salt"] = m_data.salt();
			}
		}
		m_node.m_rpc.invoke(e, i-&gt;first.ep(), o);
	}
}

void get_item_observer::reply(msg const&amp; m)
{
	char const* pk = NULL;
	char const* sig = NULL;
	boost::uint64_t seq = 0;

	bdecode_node r = m.message.dict_find_dict("r");
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(3)">../src/kademlia/logging.cpp:38</a></td><td>replace this logging with alerts</td></tr><tr id="3" style="display: none;" colspan="3"><td colspan="3"><h2>replace this logging with alerts</h2><h4>../src/kademlia/logging.cpp:38</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

*/

#include "libtorrent/kademlia/logging.hpp"
#include "libtorrent/time.hpp"

namespace libtorrent { namespace dht
{
<div style="background: #ffff00" width="100%">	log_event::log_event(log&amp; log) 
</div>		: log_(log) 
	{
		if (!log_.enabled()) return;

		static const time_point start = clock_type::now();
		char ret[200];
		snprintf(ret, sizeof(ret), "%" PRId64
			, total_microseconds(clock_type::now() - start));
		log_ &lt;&lt; ret &lt;&lt; " [" &lt;&lt; log.id() &lt;&lt; "] ";
	}

	log_event::~log_event()
	{
		if (log_.enabled())
		{
			log_ &lt;&lt; "\n";
			log_.flush();
		}
	}

}}

</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(4)">../include/libtorrent/http_tracker_connection.hpp:105</a></td><td>add a unit test for this function</td></tr><tr id="4" style="display: none;" colspan="3"><td colspan="3"><h2>add a unit test for this function</h2><h4>../include/libtorrent/http_tracker_connection.hpp:105</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		void on_filter(http_connection&amp; c, std::vector&lt;tcp::endpoint&gt;&amp; endpoints);
		void on_connect(http_connection&amp; c);
		void on_response(error_code const&amp; ec, http_parser const&amp; parser
			, char const* data, int size);

		virtual void on_timeout(error_code const&amp;) {}

		tracker_manager&amp; m_man;
		boost::shared_ptr&lt;http_connection&gt; m_tracker_connection;
		address m_tracker_ip;
#if TORRENT_USE_I2P
		i2p_connection* m_i2p_conn;
#endif
	};

	TORRENT_EXTRA_EXPORT tracker_response parse_tracker_response(
		char const* data, int size, error_code&amp; ec
		, bool scrape_request, sha1_hash scrape_ih);

<div style="background: #ffff00" width="100%">	TORRENT_EXTRA_EXPORT bool extract_peer_info(bdecode_node const&amp; info
</div>		, peer_entry&amp; ret, error_code&amp; ec);
}

#endif // TORRENT_HTTP_TRACKER_CONNECTION_HPP_INCLUDED

</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(5)">../include/libtorrent/kademlia/node.hpp:200</a></td><td>rename this to just node</td></tr><tr id="5" style="display: none;" colspan="3"><td colspan="3"><h2>rename this to just node</h2><h4>../include/libtorrent/kademlia/node.hpp:200</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
struct count_peers
{
	int&amp; count;
	count_peers(int&amp; c): count(c) {}
	void operator()(std::pair&lt;libtorrent::dht::node_id
		, libtorrent::dht::torrent_entry&gt; const&amp; t)
	{
		count += t.second.peers.size();
	}
};

struct udp_socket_interface
{
	virtual bool has_quota() = 0;
	virtual bool send_packet(entry&amp; e, udp::endpoint const&amp; addr, int flags) = 0;
protected:
	~udp_socket_interface() {}
};

<div style="background: #ffff00" width="100%">class TORRENT_EXTRA_EXPORT node : boost::noncopyable
</div>{
typedef std::map&lt;node_id, torrent_entry&gt; table_t;
typedef std::map&lt;node_id, dht_immutable_item&gt; dht_immutable_table_t;
typedef std::map&lt;node_id, dht_mutable_item&gt; dht_mutable_table_t;

public:
	node(udp_socket_interface* sock
		, libtorrent::dht_settings const&amp; settings, node_id nid
		, dht_observer* observer, counters&amp; cnt);

	virtual ~node() {}

	void tick();
	void bootstrap(std::vector&lt;udp::endpoint&gt; const&amp; nodes
		, find_data::nodes_callback const&amp; f);
	void add_router_node(udp::endpoint router);
		
	void unreachable(udp::endpoint const&amp; ep);
	void incoming(msg const&amp; m);

	int num_torrents() const { return m_map.size(); }
	int num_peers() const
	{
		int ret = 0;
		std::for_each(m_map.begin(), m_map.end(), count_peers(ret));
		return ret;
	}

	int bucket_size(int bucket);

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(6)">../src/alert.cpp:1444</a></td><td>the salt here is allocated on the heap. It would be nice to allocate in in the stack_allocator</td></tr><tr id="6" style="display: none;" colspan="3"><td colspan="3"><h2>the salt here is allocated on the heap. It would be nice to
allocate in in the stack_allocator</h2><h4>../src/alert.cpp:1444</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			, operation_names[op]
			, error.value()
			, convert_from_native(error.message()).c_str());
		return msg;
	}

	dht_immutable_item_alert::dht_immutable_item_alert(aux::stack_allocator&amp;
		, sha1_hash const&amp; t, entry const&amp; i)
		: target(t), item(i)
	{}
		
	std::string dht_immutable_item_alert::message() const
	{
		char msg[1050];
		snprintf(msg, sizeof(msg), "DHT immutable item %s [ %s ]"
			, to_hex(target.to_string()).c_str()
			, item.to_string().c_str());
		return msg;
	}

<div style="background: #ffff00" width="100%">	dht_mutable_item_alert::dht_mutable_item_alert(aux::stack_allocator&amp;
</div>		, boost::array&lt;char, 32&gt; k
		, boost::array&lt;char, 64&gt; sig
		, boost::uint64_t sequence
		, std::string const&amp; s
		, entry const&amp; i)
		: key(k), signature(sig), seq(sequence), salt(s), item(i)
	{}

	std::string dht_mutable_item_alert::message() const
	{
		char msg[1050];
		snprintf(msg, sizeof(msg), "DHT mutable item (key=%s salt=%s seq=%" PRId64 ") [ %s ]"
			, to_hex(std::string(&amp;key[0], 32)).c_str()
			, salt.c_str()
			, seq
			, item.to_string().c_str());
		return msg;
	}

	dht_put_alert::dht_put_alert(aux::stack_allocator&amp;, sha1_hash const&amp; t)
		: target(t)
		, seq(0)
	{}

	dht_put_alert::dht_put_alert(aux::stack_allocator&amp;
		, boost::array&lt;char, 32&gt; key
		, boost::array&lt;char, 64&gt; sig
		, std::string s
		, boost::uint64_t sequence_number)
		: target(0)
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(7)">../src/alert_manager.cpp:97</a></td><td>keep a count of the number of threads waiting. Only if it's > 0 notify them</td></tr><tr id="7" style="display: none;" colspan="3"><td colspan="3"><h2>keep a count of the number of threads waiting. Only if it's
> 0 notify them</h2><h4>../src/alert_manager.cpp:97</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		for (ses_extension_list_t::iterator i = m_ses_extensions.begin()
			, end(m_ses_extensions.end()); i != end; ++i)
		{
			(*i)-&gt;on_alert(a);
		}
#endif
		if (a-&gt;type() == save_resume_data_failed_alert::alert_type
			|| a-&gt;type() == save_resume_data_alert::alert_type)
			++m_num_queued_resume;

		if (m_alerts[m_generation].size() == 1)
		{
			lock.unlock();

			// we just posted to an empty queue. If anyone is waiting for
			// alerts, we need to notify them. Also (potentially) call the
			// user supplied m_notify callback to let the client wake up its
			// message loop to poll for alerts.
			if (m_notify) m_notify();

<div style="background: #ffff00" width="100%">			m_condition.notify_all();
</div>		}
	}

#ifndef TORRENT_NO_DEPRECATE

	bool alert_manager::maybe_dispatch(alert const&amp; a)
	{
		if (m_dispatch)
		{
			m_dispatch(a.clone());
			return true;
		}
		return false;
	}

	void alert_manager::set_dispatch_function(
		boost::function&lt;void(std::auto_ptr&lt;alert&gt;)&gt; const&amp; fun)
	{
		mutex::scoped_lock lock(m_mutex);

		m_dispatch = fun;

		heterogeneous_queue&lt;alert&gt; storage;
		m_alerts[m_generation].swap(storage);
		lock.unlock();

		std::vector&lt;alert*&gt; alerts;
		storage.get_pointers(alerts);

		for (std::vector&lt;alert*&gt;::iterator i = alerts.begin()
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(8)">../src/block_cache.cpp:1690</a></td><td>turn these return values into enums returns -1: block not in cache -2: out of memory</td></tr><tr id="8" style="display: none;" colspan="3"><td colspan="3"><h2>turn these return values into enums
returns
-1: block not in cache
-2: out of memory</h2><h4>../src/block_cache.cpp:1690</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			{
				TORRENT_PIECE_ASSERT(!p.blocks[k].dirty, &amp;p);
				TORRENT_PIECE_ASSERT(!p.blocks[k].pending, &amp;p);
				TORRENT_PIECE_ASSERT(p.blocks[k].refcount == 0, &amp;p);
			}
			TORRENT_PIECE_ASSERT(p.blocks[k].refcount &gt;= 0, &amp;p);
			num_refcount += p.blocks[k].refcount;
		}
		TORRENT_PIECE_ASSERT(num_blocks == p.num_blocks, &amp;p);
		TORRENT_PIECE_ASSERT(num_pending &lt;= p.refcount, &amp;p);
		TORRENT_PIECE_ASSERT(num_refcount == p.refcount, &amp;p);
		TORRENT_PIECE_ASSERT(num_dirty == p.num_dirty, &amp;p);
	}
	TORRENT_ASSERT(m_read_cache_size == cached_read_blocks);
	TORRENT_ASSERT(m_write_cache_size == cached_write_blocks);
	TORRENT_ASSERT(m_pinned_blocks == num_pinned);
	TORRENT_ASSERT(m_write_cache_size + m_read_cache_size &lt;= in_use());
}
#endif

<div style="background: #ffff00" width="100%">
</div>int block_cache::copy_from_piece(cached_piece_entry* pe, disk_io_job* j
	, bool expect_no_fail)
{
	INVARIANT_CHECK;
	TORRENT_UNUSED(expect_no_fail);

	TORRENT_PIECE_ASSERT(j-&gt;buffer == 0, pe);
	TORRENT_PIECE_ASSERT(pe-&gt;in_use, pe);

	// copy from the cache and update the last use timestamp
	int block = j-&gt;d.io.offset / block_size();
	int block_offset = j-&gt;d.io.offset &amp; (block_size()-1);
	int buffer_offset = 0;
	int size = j-&gt;d.io.buffer_size;
	int blocks_to_read = block_offset &gt; 0 &amp;&amp; (size &gt; block_size() - block_offset) ? 2 : 1;
	TORRENT_PIECE_ASSERT(size &lt;= block_size(), pe);
	const int start_block = block;

#ifdef TORRENT_DEBUG	
	int piece_size = j-&gt;storage-&gt;files()-&gt;piece_size(j-&gt;piece);
	int blocks_in_piece = (piece_size + block_size() - 1) / block_size();
	TORRENT_PIECE_ASSERT(start_block &lt; blocks_in_piece, pe);
#endif

	// if there's no buffer, we don't have this block in
	// the cache, and we're not currently reading it in either
	// since it's not pending

	if (inc_block_refcount(pe, start_block, ref_reading) == false) 
	{
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(9)">../src/escape_string.cpp:209</a></td><td>this should probably be moved into string_util.cpp</td></tr><tr id="9" style="display: none;" colspan="3"><td colspan="3"><h2>this should probably be moved into string_util.cpp</h2><h4>../src/escape_string.cpp:209</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		}
		return false;
	}
	
	void convert_path_to_posix(std::string&amp; path)
	{
		for (std::string::iterator i = path.begin()
			, end(path.end()); i != end; ++i)
			if (*i == '\\') *i = '/';
	}

#ifdef TORRENT_WINDOWS
	void convert_path_to_windows(std::string&amp; path)
	{
		for (std::string::iterator i = path.begin()
			, end(path.end()); i != end; ++i)
			if (*i == '/') *i = '\\';
	}
#endif

<div style="background: #ffff00" width="100%">	std::string read_until(char const*&amp; str, char delim, char const* end)
</div>	{
		TORRENT_ASSERT(str &lt;= end);

		std::string ret;
		while (str != end &amp;&amp; *str != delim)
		{
			ret += *str;
			++str;
		}
		// skip the delimiter as well
		while (str != end &amp;&amp; *str == delim) ++str;
		return ret;
	}

	std::string maybe_url_encode(std::string const&amp; url)
	{
		std::string protocol, host, auth, path;
		int port;
		error_code ec;
		boost::tie(protocol, auth, host, port, path) = parse_url_components(url, ec);
		if (ec) return url;
		
		// first figure out if this url contains unencoded characters
		if (!need_encoding(path.c_str(), path.size()))
			return url;

		char msg[TORRENT_MAX_PATH*4];
		snprintf(msg, sizeof(msg), "%s://%s%s%s%s%s%s", protocol.c_str(), auth.c_str()
			, auth.empty()?"":"@", host.c_str()
			, port == -1 ? "" : ":"
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(10)">../src/file.cpp:505</a></td><td>test this on a FAT volume to see what error we get!</td></tr><tr id="10" style="display: none;" colspan="3"><td colspan="3"><h2>test this on a FAT volume to see what error we get!</h2><h4>../src/file.cpp:505</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// if the filesystem does not support it.
		ec.assign(GetLastError(), system_category());
		return;

#else

		std::string n_exist = convert_to_native(file);
		std::string n_link = convert_to_native(link);

		// assume posix's link() function exists
		int ret = ::link(n_exist.c_str(), n_link.c_str());

		if (ret == 0)
		{
			ec.clear();
			return;
		}

		// most errors are passed through, except for the ones that indicate that
		// hard links are not supported and require a copy.
<div style="background: #ffff00" width="100%">		if (errno != EMLINK || errno != EXDEV)
</div>		{
			// some error happened, report up to the caller
			ec.assign(errno, generic_category());
			return;
		}
#endif

		// if we get here, we should copy the file
		copy_file(file, link, ec);
	}

	bool is_directory(std::string const&amp; f, error_code&amp; ec)
	{
		ec.clear();
		error_code e;
		file_status s;
		stat_file(f, &amp;s, e);
		if (!e &amp;&amp; s.mode &amp; file_status::directory) return true;
		ec = e;
		return false;
	}

	void recursive_copy(std::string const&amp; old_path, std::string const&amp; new_path, error_code&amp; ec)
	{
		TORRENT_ASSERT(!ec);
		if (is_directory(old_path, ec))
		{
			create_directory(new_path, ec);
			if (ec) return;
			for (directory i(old_path, ec); !i.done(); i.next(ec))
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(11)">../src/peer_connection.cpp:2338</a></td><td>this should probably be based on time instead of number of request messages. For a very high throughput connection, 300 may be a legitimate number of requests to have in flight when getting choked</td></tr><tr id="11" style="display: none;" colspan="3"><td colspan="3"><h2>this should probably be based on time instead of number
of request messages. For a very high throughput connection, 300
may be a legitimate number of requests to have in flight when
getting choked</h2><h4>../src/peer_connection.cpp:2338</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				, "piece: %d s: %d l: %d invalid request"
				, r.piece , r.start , r.length);
#endif

			write_reject_request(r);
			++m_num_invalid_requests;

			if (t-&gt;alerts().should_post&lt;invalid_request_alert&gt;())
			{
				// msvc 12 appears to deduce the rvalue reference template
				// incorrectly for bool temporaries. So, create a dummy instance
				bool peer_interested = bool(m_peer_interested);
				t-&gt;alerts().emplace_alert&lt;invalid_request_alert&gt;(
					t-&gt;get_handle(), m_remote, m_peer_id, r
					, t-&gt;has_piece_passed(r.piece), peer_interested, false);
			}

			// every ten invalid request, remind the peer that it's choked
			if (!m_peer_interested &amp;&amp; m_num_invalid_requests % 10 == 0 &amp;&amp; m_choked)
			{
<div style="background: #ffff00" width="100%">				if (m_num_invalid_requests &gt; 300 &amp;&amp; !m_peer_choked
</div>					&amp;&amp; can_disconnect(error_code(errors::too_many_requests_when_choked
						, get_libtorrent_category())))
				{
					disconnect(errors::too_many_requests_when_choked, op_bittorrent, 2);
					return;
				}
#ifndef TORRENT_DISABLE_LOGGING
				peer_log(peer_log_alert::outgoing_message, "CHOKE");
#endif
				write_choke();
			}

			return;
		}

		// if we have choked the client
		// ignore the request
		const int blocks_per_piece = static_cast&lt;int&gt;(
			(t-&gt;torrent_file().piece_length() + t-&gt;block_size() - 1) / t-&gt;block_size());

		// disconnect peers that downloads more than foo times an allowed
		// fast piece
		if (m_choked &amp;&amp; fast_idx != -1 &amp;&amp; m_accept_fast_piece_cnt[fast_idx] &gt;= 3 * blocks_per_piece
			&amp;&amp; can_disconnect(error_code(errors::too_many_requests_when_choked, get_libtorrent_category())))
		{
			disconnect(errors::too_many_requests_when_choked, op_bittorrent, 2);
			return;
		}

		if (m_choked &amp;&amp; fast_idx == -1)
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(12)">../src/peer_connection.cpp:3045</a></td><td>since we throw away the queue entry once we issue the disk job, this may happen. Instead, we should keep the queue entry around, mark it as having been requested from disk and once the disk job comes back, discard it if it has been cancelled. Maybe even be able to cancel disk jobs?</td></tr><tr id="12" style="display: none;" colspan="3"><td colspan="3"><h2>since we throw away the queue entry once we issue
the disk job, this may happen. Instead, we should keep the
queue entry around, mark it as having been requested from
disk and once the disk job comes back, discard it if it has
been cancelled. Maybe even be able to cancel disk jobs?</h2><h4>../src/peer_connection.cpp:3045</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		std::vector&lt;peer_request&gt;::iterator i
			= std::find(m_requests.begin(), m_requests.end(), r);

		if (i != m_requests.end())
		{
			m_counters.inc_stats_counter(counters::cancelled_piece_requests);
			m_requests.erase(i);

			if (m_requests.empty())
				m_counters.inc_stats_counter(counters::num_peers_up_requests, -1);

#ifndef TORRENT_DISABLE_LOGGING
			peer_log(peer_log_alert::outgoing_message, "REJECT_PIECE", "piece: %d s: %x l: %x cancelled"
				, r.piece , r.start , r.length);
#endif
			write_reject_request(r);
		}
		else
		{
<div style="background: #ffff00" width="100%">#ifndef TORRENT_DISABLE_LOGGING
</div>			peer_log(peer_log_alert::info, "INVALID_CANCEL", "got cancel not in the queue");
#endif
		}
	}

	// -----------------------------
	// --------- DHT PORT ----------
	// -----------------------------

	void peer_connection::incoming_dht_port(int listen_port)
	{
		TORRENT_ASSERT(is_single_thread());
		INVARIANT_CHECK;

#ifndef TORRENT_DISABLE_LOGGING
		peer_log(peer_log_alert::incoming_message, "DHT_PORT", "p: %d", listen_port);
#endif
#ifndef TORRENT_DISABLE_DHT
		m_ses.add_dht_node(udp::endpoint(
			m_remote.address(), listen_port));
#endif
	}

	// -----------------------------
	// --------- HAVE ALL ----------
	// -----------------------------

	void peer_connection::incoming_have_all()
	{
		TORRENT_ASSERT(is_single_thread());
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(13)">../src/peer_connection.cpp:4695</a></td><td>use a deadline_timer for timeouts. Don't rely on second_tick()! Hook this up to connect timeout as well. This would improve performance because of less work in second_tick(), and might let use remove ticking entirely eventually</td></tr><tr id="13" style="display: none;" colspan="3"><td colspan="3"><h2>use a deadline_timer for timeouts. Don't rely on second_tick()!
Hook this up to connect timeout as well. This would improve performance
because of less work in second_tick(), and might let use remove ticking
entirely eventually</h2><h4>../src/peer_connection.cpp:4695</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				connect_timeout += 20;
#endif

			if (d &gt; seconds(connect_timeout)
				&amp;&amp; can_disconnect(error_code(errors::timed_out, get_libtorrent_category())))
			{
#ifndef TORRENT_DISABLE_LOGGING
				peer_log(peer_log_alert::info, "CONNECT_FAILED", "waited %d seconds"
					, int(total_seconds(d)));
#endif
				connect_failed(errors::timed_out);
				return;
			}
		}

		// if we can't read, it means we're blocked on the rate-limiter
		// or the disk, not the peer itself. In this case, don't blame
		// the peer and disconnect it
		bool may_timeout = (m_channel_state[download_channel] &amp; peer_info::bw_network) != 0;

<div style="background: #ffff00" width="100%">		if (may_timeout &amp;&amp; d &gt; seconds(timeout()) &amp;&amp; !m_connecting &amp;&amp; m_reading_bytes == 0
</div>			&amp;&amp; can_disconnect(error_code(errors::timed_out_inactivity, get_libtorrent_category())))
		{
#ifndef TORRENT_DISABLE_LOGGING
			peer_log(peer_log_alert::info, "LAST_ACTIVITY", "%d seconds ago"
				, int(total_seconds(d)));
#endif
			disconnect(errors::timed_out_inactivity, op_bittorrent);
			return;
		}

		// do not stall waiting for a handshake
		if (may_timeout
			&amp;&amp; !m_connecting
			&amp;&amp; in_handshake()
			&amp;&amp; d &gt; seconds(m_settings.get_int(settings_pack::handshake_timeout)))
		{
#ifndef TORRENT_DISABLE_LOGGING
			peer_log(peer_log_alert::info, "NO_HANDSHAKE", "waited %d seconds"
				, int(total_seconds(d)));
#endif
			disconnect(errors::timed_out_no_handshake, op_bittorrent);
			return;
		}

		// disconnect peers that we unchoked, but
		// they didn't send a request within 60 seconds.
		// but only if we're a seed
		d = now - (std::max)(m_last_unchoke, m_last_incoming_request);
		if (may_timeout
			&amp;&amp; !m_connecting
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(14)">../src/peer_list.cpp:495</a></td><td>it would be nice if there was a way to iterate over these torrent_peer objects in the order they are allocated in the pool instead. It would probably be more efficient</td></tr><tr id="14" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice if there was a way to iterate over these
torrent_peer objects in the order they are allocated in the pool
instead. It would probably be more efficient</h2><h4>../src/peer_list.cpp:495</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		, int session_time, torrent_state* state)
	{
		TORRENT_ASSERT(is_single_thread());
		INVARIANT_CHECK;

		const int candidate_count = 10;
		peers.reserve(candidate_count);

		int erase_candidate = -1;

		if (m_finished != state-&gt;is_finished)
			recalculate_connect_candidates(state);

		external_ip const&amp; external = *state-&gt;ip;
		int external_port = state-&gt;port;

		if (m_round_robin &gt;= int(m_peers.size())) m_round_robin = 0;

		int max_peerlist_size = state-&gt;max_peerlist_size;

<div style="background: #ffff00" width="100%">		for (int iterations = (std::min)(int(m_peers.size()), 300);
</div>			iterations &gt; 0; --iterations)
		{
			++state-&gt;loop_counter;

			if (m_round_robin &gt;= int(m_peers.size())) m_round_robin = 0;

			torrent_peer&amp; pe = *m_peers[m_round_robin];
			TORRENT_ASSERT(pe.in_use);
			int current = m_round_robin;

			// if the number of peers is growing large
			// we need to start weeding.

			if (int(m_peers.size()) &gt;= max_peerlist_size * 0.95
				&amp;&amp; max_peerlist_size &gt; 0)
			{
				if (is_erase_candidate(pe)
					&amp;&amp; (erase_candidate == -1
						|| !compare_peer_erase(*m_peers[erase_candidate], pe)))
				{
					if (should_erase_immediately(pe))
					{
						if (erase_candidate &gt; current) --erase_candidate;
						erase_peer(m_peers.begin() + current, state);
						continue;
					}
					else
					{
						erase_candidate = current;
					}
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(15)">../src/piece_picker.cpp:1996</a></td><td>make the 2048 limit configurable</td></tr><tr id="15" style="display: none;" colspan="3"><td colspan="3"><h2>make the 2048 limit configurable</h2><h4>../src/piece_picker.cpp:1996</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// only one of rarest_first or sequential can be set

	void piece_picker::pick_pieces(bitfield const&amp; pieces
		, std::vector&lt;piece_block&gt;&amp; interesting_blocks, int num_blocks
		, int prefer_contiguous_blocks, void* peer
		, int options, std::vector&lt;int&gt; const&amp; suggested_pieces
		, int num_peers
		, counters&amp; pc
		) const
	{
		TORRENT_ASSERT(peer == 0 || static_cast&lt;torrent_peer*&gt;(peer)-&gt;in_use);

		// prevent the number of partial pieces to grow indefinitely
		// make this scale by the number of peers we have. For large
		// scale clients, we would have more peers, and allow a higher
		// threshold for the number of partials
		// deduct pad files because they case partial pieces which are OK
		// the second condition is to make sure we cap the number of partial
		// _bytes_. The larger the pieces are, the fewer partial pieces we want.
		// 2048 corresponds to 32 MiB
<div style="background: #ffff00" width="100%">		const int num_partials = int(m_downloads[piece_pos::piece_downloading].size())
</div>			- m_num_pad_files;
		if (num_partials &gt; num_peers * 3 / 2
			|| num_partials * m_blocks_per_piece &gt; 2048)
		{
			// if we have too many partial pieces, prioritize completing
			// them. In order for this to have an affect, also disable
			// prefer whole pieces (otherwise partial pieces would be de-prioritized)
			options |= prioritize_partials;
			prefer_contiguous_blocks = 0;
		}

		// only one of rarest_first and sequential can be set.
		TORRENT_ASSERT(((options &amp; rarest_first) ? 1 : 0)
			+ ((options &amp; sequential) ? 1 : 0) &lt;= 1);
#ifdef TORRENT_EXPENSIVE_INVARIANT_CHECKS
		TORRENT_PIECE_PICKER_INVARIANT_CHECK;
#endif
		TORRENT_ASSERT(num_blocks &gt; 0);
		TORRENT_ASSERT(pieces.size() == m_piece_map.size());

		TORRENT_ASSERT(!m_priority_boundries.empty()
			|| m_dirty);

		// this will be filled with blocks that we should not request
		// unless we can't find num_blocks among the other ones.
		std::vector&lt;piece_block&gt; backup_blocks;
		std::vector&lt;piece_block&gt; backup_blocks2;
		const std::vector&lt;int&gt; empty_vector;
	
		// When prefer_contiguous_blocks is set (usually set when downloading from
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(16)">../src/piece_picker.cpp:2605</a></td><td>the first_block returned here is the largest free range, not the first-fit range, which would be better</td></tr><tr id="16" style="display: none;" colspan="3"><td colspan="3"><h2>the first_block returned here is the largest free range, not
the first-fit range, which would be better</h2><h4>../src/piece_picker.cpp:2605</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			, end(m_block_info.end()); i != end; ++i)
		{
			TORRENT_ASSERT(i-&gt;peer == 0 || static_cast&lt;torrent_peer*&gt;(i-&gt;peer)-&gt;in_use);
		}
	}
#endif

	void piece_picker::clear_peer(void* peer)
	{
		for (std::vector&lt;block_info&gt;::iterator i = m_block_info.begin()
			, end(m_block_info.end()); i != end; ++i)
		{
			if (i-&gt;peer == peer) i-&gt;peer = 0;
		}
	}

	// the first bool is true if this is the only peer that has requested and downloaded
	// blocks from this piece.
	// the second bool is true if this is the only active peer that is requesting
	// and downloading blocks from this piece. Active means having a connection.
<div style="background: #ffff00" width="100%">	boost::tuple&lt;bool, bool, int, int&gt; piece_picker::requested_from(
</div>		piece_picker::downloading_piece const&amp; p
		, int num_blocks_in_piece, void* peer) const
	{
		bool exclusive = true;
		bool exclusive_active = true;
		int contiguous_blocks = 0;
		int max_contiguous = 0;
		int first_block = 0;
		block_info const* binfo = blocks_for_piece(p);
		for (int j = 0; j &lt; num_blocks_in_piece; ++j)
		{
			piece_picker::block_info const&amp; info = binfo[j];
			TORRENT_ASSERT(info.peer == 0 || static_cast&lt;torrent_peer*&gt;(info.peer)-&gt;in_use);
			TORRENT_ASSERT(info.piece_index == p.index);
			if (info.state == piece_picker::block_info::state_none)
			{
				++contiguous_blocks;
				continue;
			}
			if (contiguous_blocks &gt; max_contiguous)
			{
				max_contiguous = contiguous_blocks;
				first_block = j - contiguous_blocks;
			}
			contiguous_blocks = 0;
			if (info.peer != peer)
			{
				exclusive = false;
				if (info.state == piece_picker::block_info::state_requested
					&amp;&amp; info.peer != 0)
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(17)">../src/piece_picker.cpp:3390</a></td><td>it would be nice if this could be folded into lock_piece() the main distinction is that this also maintains the m_num_passed counter and the passed_hash_check member Is there ever a case where we call write filed without also locking the piece? Perhaps write_failed() should imply locking it.</td></tr><tr id="17" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice if this could be folded into lock_piece()
the main distinction is that this also maintains the m_num_passed
counter and the passed_hash_check member
Is there ever a case where we call write filed without also locking
the piece? Perhaps write_failed() should imply locking it.</h2><h4>../src/piece_picker.cpp:3390</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		int state = m_piece_map[piece].download_queue();
		if (state == piece_pos::piece_open) return;
		std::vector&lt;downloading_piece&gt;::iterator i = find_dl_piece(state, piece);
		if (i == m_downloads[state].end()) return;

		TORRENT_ASSERT(i-&gt;passed_hash_check == false);
		if (i-&gt;passed_hash_check)
		{
			// it's not clear why this would happen,
			// but it seems reasonable to not break the
			// accounting over it.
			i-&gt;passed_hash_check = false;
			TORRENT_ASSERT(m_num_passed &gt; 0);
			--m_num_passed;
		}

		// prevent this piece from being picked until it's restored
		i-&gt;locked = true;
	}

<div style="background: #ffff00" width="100%">	void piece_picker::write_failed(piece_block block)
</div>	{
		TORRENT_PIECE_PICKER_INVARIANT_CHECK;

#if TORRENT_USE_INVARIANT_CHECKS
		check_piece_state();
#endif

#ifdef TORRENT_PICKER_LOG
		std::cerr &lt;&lt; "[" &lt;&lt; this &lt;&lt; "] " &lt;&lt; "write_failed( {" &lt;&lt; block.piece_index &lt;&lt; ", " &lt;&lt; block.block_index &lt;&lt; "} )" &lt;&lt; std::endl;
#endif

		int state = m_piece_map[block.piece_index].download_queue();
		if (state == piece_pos::piece_open) return;
		std::vector&lt;downloading_piece&gt;::iterator i = find_dl_piece(state, block.piece_index);
		if (i == m_downloads[state].end()) return;

		block_info* binfo = blocks_for_piece(*i);
		block_info&amp; info = binfo[block.block_index];
		TORRENT_ASSERT(&amp;info &gt;= &amp;m_block_info[0]);
		TORRENT_ASSERT(&amp;info &lt; &amp;m_block_info[0] + m_block_info.size());
		TORRENT_ASSERT(info.piece_index == block.piece_index);
		TORRENT_ASSERT(info.state == block_info::state_writing);
		TORRENT_ASSERT(info.num_peers == 0);

		TORRENT_ASSERT(i-&gt;writing &gt; 0);
		TORRENT_ASSERT(info.state == block_info::state_writing);

		if (info.state == block_info::state_finished) return;
		if (info.state == block_info::state_writing) --i-&gt;writing;

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(18)">../src/session_impl.cpp:214</a></td><td>find a better place for this function</td></tr><tr id="18" style="display: none;" colspan="3"><td colspan="3"><h2>find a better place for this function</h2><h4>../src/session_impl.cpp:214</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			*j.vec, j.peer-&gt;make_write_handler(boost::bind(
				&amp;peer_connection::on_send_data, j.peer, _1, _2)));
	}
	else
	{
		if (j.recv_buf)
		{
			j.peer-&gt;get_socket()-&gt;async_read_some(asio::buffer(j.recv_buf, j.buf_size)
				, j.peer-&gt;make_read_handler(boost::bind(
				&amp;peer_connection::on_receive_data, j.peer, _1, _2)));
		}
		else
		{
			j.peer-&gt;get_socket()-&gt;async_read_some(j.read_vec
				, j.peer-&gt;make_read_handler(boost::bind(
				&amp;peer_connection::on_receive_data, j.peer, _1, _2)));
		}
	}
}

<div style="background: #ffff00" width="100%">proxy_settings::proxy_settings(aux::session_settings const&amp; sett)
</div>{
	hostname = sett.get_str(settings_pack::proxy_hostname);
	username = sett.get_str(settings_pack::proxy_username);
	password = sett.get_str(settings_pack::proxy_password);
	type = sett.get_int(settings_pack::proxy_type);
	port = sett.get_int(settings_pack::proxy_port);
	proxy_hostnames = sett.get_bool(settings_pack::proxy_hostnames);
	proxy_peer_connections = sett.get_bool(
		settings_pack::proxy_peer_connections);
}

namespace aux {

	void session_impl::init_peer_class_filter(bool unlimited_local)
	{
		// set the default peer_class_filter to use the local peer class
		// for peers on local networks
		boost::uint32_t lfilter = 1 &lt;&lt; m_local_peer_class;
		boost::uint32_t gfilter = 1 &lt;&lt; m_global_class;

		struct class_mapping
		{
			char const* first;
			char const* last;
			boost::uint32_t filter;
		};

		static const class_mapping v4_classes[] =
		{
			// everything
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(19)">../src/session_impl.cpp:821</a></td><td>if the DHT is enabled, it should probably be restarted here. maybe it should even be deferred to not be started until the client has had a chance to pass in the dht state</td></tr><tr id="19" style="display: none;" colspan="3"><td colspan="3"><h2>if the DHT is enabled, it should probably be restarted here.
maybe it should even be deferred to not be started until the client
has had a chance to pass in the dht state</h2><h4>../src/session_impl.cpp:821</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			if (val) m_settings.set_int(settings_pack::allowed_enc_level, val.int_value());
		}
#endif
		
		settings = e-&gt;dict_find_dict("settings");
		if (settings)
		{
			settings_pack* pack = load_pack_from_dict(settings);
			apply_settings_pack(pack);
		}

		// in case we just set a socks proxy, we might have to
		// open the socks incoming connection
		if (!m_socks_listen_socket) open_new_incoming_socks_connection();
		m_udp_socket.set_proxy_settings(proxy());

#ifndef TORRENT_DISABLE_DHT
		settings = e-&gt;dict_find_dict("dht state");
		if (settings)
		{
<div style="background: #ffff00" width="100%">			m_dht_state = settings;
</div>		}
#endif

#ifndef TORRENT_NO_DEPRECATE
		settings = e-&gt;dict_find_list("feeds");
		if (settings)
		{
			m_feeds.reserve(settings.list_size());
			for (int i = 0; i &lt; settings.list_size(); ++i)
			{
				if (settings.list_at(i).type() != bdecode_node::dict_t) continue;
				boost::shared_ptr&lt;feed&gt; f(new_feed(*this, feed_settings()));
				f-&gt;load_state(settings.list_at(i));
				f-&gt;update_feed();
				m_feeds.push_back(f);
			}
			update_rss_feeds();
		}
#endif

#ifndef TORRENT_DISABLE_EXTENSIONS
		for (ses_extension_list_t::iterator i = m_ses_extensions.begin()
			, end(m_ses_extensions.end()); i != end; ++i)
		{
			TORRENT_TRY {
				(*i)-&gt;load_state(*e);
			} TORRENT_CATCH(std::exception&amp;) {}
		}
#endif
	}
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(20)">../src/session_impl.cpp:1817</a></td><td>the udp socket(s) should be using the same generic mechanism and not be restricted to a single one we should open a one listen socket for each entry in the listen_interfaces list</td></tr><tr id="20" style="display: none;" colspan="3"><td colspan="3"><h2>the udp socket(s) should be using the same generic
mechanism and not be restricted to a single one
we should open a one listen socket for each entry in the
listen_interfaces list</h2><h4>../src/session_impl.cpp:1817</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				}
#endif // TORRENT_USE_OPENSSL
			}
#endif // TORRENT_USE_IPV6

			// set our main IPv4 and IPv6 interfaces
			// used to send to the tracker
			std::vector&lt;ip_interface&gt; ifs = enum_net_interfaces(m_io_service, ec);
			for (std::vector&lt;ip_interface&gt;::const_iterator i = ifs.begin()
					, end(ifs.end()); i != end; ++i)
			{
				address const&amp; addr = i-&gt;interface_address;
				if (addr.is_v6() &amp;&amp; !is_local(addr) &amp;&amp; !is_loopback(addr))
					m_ipv6_interface = tcp::endpoint(addr, m_listen_interface.port());
				else if (addr.is_v4() &amp;&amp; !is_local(addr) &amp;&amp; !is_loopback(addr))
					m_ipv4_interface = tcp::endpoint(addr, m_listen_interface.port());
			}
		}
		else
		{
<div style="background: #ffff00" width="100%">			for (int i = 0; i &lt; m_listen_interfaces.size(); ++i)
</div>			{
				std::string const&amp; device = m_listen_interfaces[i].first;
				int port = m_listen_interfaces[i].second;

				int num_device_fails = 0;
				
#if TORRENT_USE_IPV6
				const int first_family = 0;
#else
				const int first_family = 1;
#endif
				for (int address_family = first_family; address_family &lt; 2; ++address_family)
				{
					error_code err;
					address test_family = address::from_string(device.c_str(), err);
					if (!err &amp;&amp; test_family.is_v4() != address_family)
						continue;

					listen_socket_t s = setup_listener(device, address_family, port
						, m_listen_port_retries, flags, ec);

					if (ec == error_code(boost::system::errc::no_such_device, generic_category()))
					{
						++num_device_fails;
						continue;
					}

					if (s.sock)
					{
						TORRENT_ASSERT(!m_abort);
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(21)">../src/session_impl.cpp:1919</a></td><td>use bind_to_device in udp_socket</td></tr><tr id="21" style="display: none;" colspan="3"><td colspan="3"><h2>use bind_to_device in udp_socket</h2><h4>../src/session_impl.cpp:1919</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			if (m_listen_port_retries &gt; 0)
			{
				m_listen_interface.port(m_listen_interface.port() + 1);
				--m_listen_port_retries;
				goto retry;
			}
			if (m_alerts.should_post&lt;listen_failed_alert&gt;())
				m_alerts.emplace_alert&lt;listen_failed_alert&gt;(print_endpoint(m_listen_interface)
					, listen_failed_alert::bind, ec, listen_failed_alert::udp);
			return;
		}

#ifdef TORRENT_USE_OPENSSL
		int ssl_port = m_settings.get_int(settings_pack::ssl_listen);

		// if ssl port is 0, we don't want to listen on an SSL port
		if (ssl_port != 0)
		{
			udp::endpoint ssl_bind_if(m_listen_interface.address(), ssl_port);

<div style="background: #ffff00" width="100%">			m_ssl_udp_socket.bind(ssl_bind_if, ec);
</div>			if (ec)
			{
#ifndef TORRENT_DISABLE_LOGGING
				session_log("SSL: cannot bind to UDP interface \"%s\": %s"
					, print_endpoint(m_listen_interface).c_str(), ec.message().c_str());
#endif
				if (m_alerts.should_post&lt;listen_failed_alert&gt;())
				{
					error_code err;
					m_alerts.emplace_alert&lt;listen_failed_alert&gt;(print_endpoint(ssl_bind_if)
							, listen_failed_alert::bind, ec, listen_failed_alert::utp_ssl);
				}
				ec.clear();
			}
			else
			{
				if (m_alerts.should_post&lt;listen_succeeded_alert&gt;())
					m_alerts.emplace_alert&lt;listen_succeeded_alert&gt;(
							tcp::endpoint(ssl_bind_if.address(), ssl_bind_if.port())
							, listen_succeeded_alert::utp_ssl);
			}
		}
#endif // TORRENT_USE_OPENSSL

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(22)">../src/session_impl.cpp:1945</a></td><td>use bind_to_device in udp_socket</td></tr><tr id="22" style="display: none;" colspan="3"><td colspan="3"><h2>use bind_to_device in udp_socket</h2><h4>../src/session_impl.cpp:1945</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">					, print_endpoint(m_listen_interface).c_str(), ec.message().c_str());
#endif
				if (m_alerts.should_post&lt;listen_failed_alert&gt;())
				{
					error_code err;
					m_alerts.emplace_alert&lt;listen_failed_alert&gt;(print_endpoint(ssl_bind_if)
							, listen_failed_alert::bind, ec, listen_failed_alert::utp_ssl);
				}
				ec.clear();
			}
			else
			{
				if (m_alerts.should_post&lt;listen_succeeded_alert&gt;())
					m_alerts.emplace_alert&lt;listen_succeeded_alert&gt;(
							tcp::endpoint(ssl_bind_if.address(), ssl_bind_if.port())
							, listen_succeeded_alert::utp_ssl);
			}
		}
#endif // TORRENT_USE_OPENSSL

<div style="background: #ffff00" width="100%">		m_udp_socket.bind(udp::endpoint(m_listen_interface.address(), m_listen_interface.port()), ec);
</div>		if (ec)
		{
#ifndef TORRENT_DISABLE_LOGGING
			session_log("cannot bind to UDP interface \"%s\": %s"
				, print_endpoint(m_listen_interface).c_str(), ec.message().c_str());
#endif
			if (m_listen_port_retries &gt; 0)
			{
				m_listen_interface.port(m_listen_interface.port() + 1);
				--m_listen_port_retries;
				goto retry;
			}
			if (m_alerts.should_post&lt;listen_failed_alert&gt;())
			{
				error_code err;
				m_alerts.emplace_alert&lt;listen_failed_alert&gt;(print_endpoint(m_listen_interface)
					, listen_failed_alert::bind, ec, listen_failed_alert::udp);
			}
			return;
		}
		else
		{
			m_external_udp_port = m_udp_socket.local_port();
			maybe_update_udp_mapping(0, m_listen_interface.port(), m_listen_interface.port());
			maybe_update_udp_mapping(1, m_listen_interface.port(), m_listen_interface.port());
			if (m_alerts.should_post&lt;listen_succeeded_alert&gt;())
				m_alerts.emplace_alert&lt;listen_succeeded_alert&gt;(m_listen_interface, listen_succeeded_alert::udp);
		}

		if (m_settings.get_int(settings_pack::peer_tos) != 0)
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(23)">../src/session_impl.cpp:3391</a></td><td>make a list for torrents that want to be announced on the DHT so we don't have to loop over all torrents, just to find the ones that want to announce</td></tr><tr id="23" style="display: none;" colspan="3"><td colspan="3"><h2>make a list for torrents that want to be announced on the DHT so we
don't have to loop over all torrents, just to find the ones that want to announce</h2><h4>../src/session_impl.cpp:3391</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (!m_dht_torrents.empty())
		{
			boost::shared_ptr&lt;torrent&gt; t;
			do
			{
		  		t = m_dht_torrents.front().lock();
				m_dht_torrents.pop_front();
			} while (!t &amp;&amp; !m_dht_torrents.empty());

			if (t)
			{
				t-&gt;dht_announce();
				return;
			}
		}
		if (m_torrents.empty()) return;

		if (m_next_dht_torrent == m_torrents.end())
			m_next_dht_torrent = m_torrents.begin();
		m_next_dht_torrent-&gt;second-&gt;dht_announce();
<div style="background: #ffff00" width="100%">		++m_next_dht_torrent;
</div>		if (m_next_dht_torrent == m_torrents.end())
			m_next_dht_torrent = m_torrents.begin();
  	}
#endif

	void session_impl::on_lsd_announce(error_code const&amp; e)
	{
#if defined TORRENT_ASIO_DEBUGGING
		complete_async("session_impl::on_lsd_announce");
#endif
		m_stats_counters.inc_stats_counter(counters::on_lsd_counter);
		TORRENT_ASSERT(is_single_thread());
		if (e) return;

		if (m_abort) return;

#if defined TORRENT_ASIO_DEBUGGING
		add_outstanding_async("session_impl::on_lsd_announce");
#endif
		// announce on local network every 5 minutes
		int delay = (std::max)(m_settings.get_int(settings_pack::local_service_announce_interval)
			/ (std::max)(int(m_torrents.size()), 1), 1);
		error_code ec;
		m_lsd_announce_timer.expires_from_now(seconds(delay), ec);
		m_lsd_announce_timer.async_wait(
			bind(&amp;session_impl::on_lsd_announce, this, _1));

		if (m_torrents.empty()) return;

		if (m_next_lsd_torrent == m_torrents.end())
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(24)">../src/storage.cpp:921</a></td><td>is this risky? The upper layer will assume we have the whole file. Perhaps we should verify that at least the size of the file is correct</td></tr><tr id="24" style="display: none;" colspan="3"><td colspan="3"><h2>is this risky? The upper layer will assume we have the
whole file. Perhaps we should verify that at least the size
of the file is correct</h2><h4>../src/storage.cpp:921</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (links)
		{
			// if this is a mutable torrent, and we need to pick up some files
			// from other torrents, do that now. Note that there is an inherent
			// race condition here. We checked if the files existed on a different
			// thread a while ago. These files may no longer exist or may have been
			// moved. If so, we just fail. The user is responsible to not touch
			// other torrents until a new mutable torrent has been completely
			// added.
			int idx = 0;
			for (std::vector&lt;std::string&gt;::const_iterator i = links-&gt;begin();
				i != links-&gt;end(); ++i, ++idx)
			{
				if (i-&gt;empty()) continue;

				error_code err;
				std::string file_path = fs.file_path(idx, m_save_path);
				hard_link(*i, file_path, err);

				// if the file already exists, that's not an error
<div style="background: #ffff00" width="100%">				if (!err || err == boost::system::errc::file_exists)
</div>					continue;

				ec.ec = err;
				ec.file = idx;
				ec.operation = storage_error::hard_link;
				return false;
			}
		}
#endif // TORRENT_DISABLE_MUTABLE_TORRENTS

		return true;
	}

	int default_storage::move_storage(std::string const&amp; sp, int flags, storage_error&amp; ec)
	{
		int ret = piece_manager::no_error;
		std::string save_path = complete(sp);

		// check to see if any of the files exist
		error_code e;
		file_storage const&amp; f = files();

		file_status s;
		if (flags == fail_if_exist)
		{
			stat_file(save_path, &amp;s, e);
			if (e != boost::system::errc::no_such_file_or_directory)
			{
				// the directory exists, check all the files
				for (int i = 0; i &lt; f.num_files(); ++i)
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(25)">../src/torrent.cpp:726</a></td><td>post alert</td></tr><tr id="25" style="display: none;" colspan="3"><td colspan="3"><h2>post alert</h2><h4>../src/torrent.cpp:726</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		state_updated();

		set_state(torrent_status::downloading);

		m_override_resume_data = true;
		init();
	}

#endif // if 0

	void torrent::leave_seed_mode(bool seed)
	{
		if (!m_seed_mode) return;

		if (!seed)
		{
			// this means the user promised we had all the
			// files, but it turned out we didn't. This is
			// an error.

<div style="background: #ffff00" width="100%">		
</div>#ifndef TORRENT_DISABLE_LOGGING
			debug_log("*** FAILED SEED MODE, rechecking");
#endif
		}

#ifndef TORRENT_DISABLE_LOGGING
		debug_log("*** LEAVING SEED MODE (%s)", seed ? "as seed" : "as non-seed");
#endif
		m_seed_mode = false;
		// seed is false if we turned out not
		// to be a seed after all
		if (!seed)
		{
			m_have_all = false;
			set_state(torrent_status::downloading);
			force_recheck();
		}
		m_num_verified = 0;
		m_verified.clear();
		m_verifying.clear();

		m_need_save_resume_data = true;
	}

	void torrent::verified(int piece)
	{
		TORRENT_ASSERT(piece &lt; int(m_verified.size()));
		TORRENT_ASSERT(piece &gt;= 0);
		TORRENT_ASSERT(m_verified.get_bit(piece) == false);
		++m_num_verified;
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(26)">../src/torrent.cpp:4807</a></td><td>abort lookups this torrent has made via the session host resolver interface</td></tr><tr id="26" style="display: none;" colspan="3"><td colspan="3"><h2>abort lookups this torrent has made via the
session host resolver interface</h2><h4>../src/torrent.cpp:4807</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// files belonging to the torrents
		disconnect_all(errors::torrent_aborted, op_bittorrent);

		// post a message to the main thread to destruct
		// the torrent object from there
		if (m_storage.get())
		{
			inc_refcount("release_files");
			m_ses.disk_thread().async_stop_torrent(m_storage.get()
				, boost::bind(&amp;torrent::on_cache_flushed, shared_from_this(), _1));
		}
		else
		{
			TORRENT_ASSERT(m_abort);
			if (alerts().should_post&lt;cache_flushed_alert&gt;())
				alerts().emplace_alert&lt;cache_flushed_alert&gt;(get_handle());
		}
		
		m_storage.reset();

<div style="background: #ffff00" width="100%">
</div>		if (!m_apply_ip_filter)
		{
			inc_stats_counter(counters::non_filter_torrents, -1);
			m_apply_ip_filter = true;
		}

		m_allow_peers = false;
		m_auto_managed = false;
		for (int i = 0; i &lt; aux::session_interface::num_torrent_lists; ++i)
		{
			if (!m_links[i].in_list()) continue;
			m_links[i].unlink(m_ses.torrent_list(i), i);
		}
		// don't re-add this torrent to the state-update list
		m_state_subscription = false;
	}

	void torrent::super_seeding(bool on)
	{
		if (on == m_super_seeding) return;

		m_super_seeding = on;
		m_need_save_resume_data = true;

		if (m_super_seeding) return;

		// disable super seeding for all peers
		for (peer_iterator i = begin(); i != end(); ++i)
		{
			(*i)-&gt;superseed_piece(-1, -1);
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(27)">../src/torrent.cpp:4951</a></td><td>the tracker login feature should probably be deprecated</td></tr><tr id="27" style="display: none;" colspan="3"><td colspan="3"><h2>the tracker login feature should probably be deprecated</h2><h4>../src/torrent.cpp:4951</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			if (alerts().should_post&lt;file_renamed_alert&gt;())
				alerts().emplace_alert&lt;file_renamed_alert&gt;(get_handle(), j-&gt;buffer, j-&gt;piece);
			m_torrent_file-&gt;rename_file(j-&gt;piece, j-&gt;buffer);
		}
		else
		{
			if (alerts().should_post&lt;file_rename_failed_alert&gt;())
				alerts().emplace_alert&lt;file_rename_failed_alert&gt;(get_handle()
					, j-&gt;piece, j-&gt;error.ec);
		}
	}

	void torrent::on_torrent_paused(disk_io_job const*)
	{
		TORRENT_ASSERT(is_single_thread());

		if (alerts().should_post&lt;torrent_paused_alert&gt;())
			alerts().emplace_alert&lt;torrent_paused_alert&gt;(get_handle());
	}

<div style="background: #ffff00" width="100%">	std::string torrent::tracker_login() const
</div>	{
		if (m_username.empty() &amp;&amp; m_password.empty()) return "";
		return m_username + ":" + m_password;
	}

	boost::uint32_t torrent::tracker_key() const
	{
		uintptr_t self = (uintptr_t)this;
		uintptr_t ses = (uintptr_t)&amp;m_ses;
		sha1_hash h = hasher((char*)&amp;self, sizeof(self))
			.update((char*)&amp;m_storage, sizeof(m_storage))
			.update((char*)&amp;ses, sizeof(ses))
			.final();
		unsigned char const* ptr = &amp;h[0];
		return detail::read_uint32(ptr);
	}

	void torrent::cancel_non_critical()
	{
		std::set&lt;int&gt; time_critical;
		for (std::vector&lt;time_critical_piece&gt;::iterator i = m_time_critical_pieces.begin()
			, end(m_time_critical_pieces.end()); i != end; ++i)
		{
			time_critical.insert(i-&gt;piece);
		}

		for (std::vector&lt;peer_connection*&gt;::iterator i
			= m_connections.begin(), end(m_connections.end()); i != end; ++i)
		{
			// for each peer, go through its download and request queue
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(28)">../src/torrent.cpp:7808</a></td><td>if peer is a really good peer, maybe we shouldn't disconnect it</td></tr><tr id="28" style="display: none;" colspan="3"><td colspan="3"><h2>if peer is a really good peer, maybe we shouldn't disconnect it</h2><h4>../src/torrent.cpp:7808</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#ifndef TORRENT_DISABLE_LOGGING
		debug_log("incoming peer (%d)", int(m_connections.size()));
#endif

#ifdef TORRENT_DEBUG
		error_code ec;
		TORRENT_ASSERT(p-&gt;remote() == p-&gt;get_socket()-&gt;remote_endpoint(ec) || ec);
#endif

		TORRENT_ASSERT(p-&gt;peer_info_struct() != NULL);

		// we need to do this after we've added the peer to the peer_list
		// since that's when the peer is assigned its peer_info object,
		// which holds the rank
		if (maybe_replace_peer)
		{
			// now, find the lowest rank peer and disconnect that
			// if it's lower rank than the incoming connection
			peer_connection* peer = find_lowest_ranking_peer();

<div style="background: #ffff00" width="100%">			if (peer &amp;&amp; peer-&gt;peer_rank() &lt; p-&gt;peer_rank())
</div>			{
				peer-&gt;disconnect(errors::too_many_connections, op_bittorrent);
				p-&gt;peer_disconnected_other();
			}
			else
			{
				p-&gt;disconnect(errors::too_many_connections, op_bittorrent);
				// we have to do this here because from the peer's point of
				// it wasn't really attached to the torrent, but we do need
				// to let peer_list know we're removing it
				remove_peer(p);
				return false;
			}
		}

#if TORRENT_USE_INVARIANT_CHECKS
		if (m_peer_list) m_peer_list-&gt;check_invariant();
#endif

		if (m_share_mode)
			recalc_share_mode();

		return true;
	}

	bool torrent::want_tick() const
	{
		if (m_abort) return false;

		if (!m_connections.empty()) return true;
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(29)">../src/tracker_manager.cpp:200</a></td><td>some of these arguments could probably be moved to the tracker request itself. like the ip_filter and settings</td></tr><tr id="29" style="display: none;" colspan="3"><td colspan="3"><h2>some of these arguments could probably be moved to the
tracker request itself. like the ip_filter and settings</h2><h4>../src/tracker_manager.cpp:200</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			, interval == 0 ? min_interval : interval);
		close();
	}

	void tracker_connection::sent_bytes(int bytes)
	{
		m_man.sent_bytes(bytes);
	}

	void tracker_connection::received_bytes(int bytes)
	{
		m_man.received_bytes(bytes);
	}

	void tracker_connection::close()
	{
		cancel();
		m_man.remove_request(this);
	}

<div style="background: #ffff00" width="100%">	tracker_manager::tracker_manager(class udp_socket&amp; sock
</div>		, counters&amp; stats_counters
		, resolver_interface&amp; resolver
		, struct ip_filter&amp; ipf
		, aux::session_settings const&amp; sett
#if !defined TORRENT_DISABLE_LOGGING || TORRENT_USE_ASSERTS
		, aux::session_logger&amp; ses
#endif
		)
		: m_ip_filter(ipf)
		, m_udp_socket(sock)
		, m_host_resolver(resolver)
		, m_settings(sett)
		, m_stats_counters(stats_counters)
#if !defined TORRENT_DISABLE_LOGGING || TORRENT_USE_ASSERTS
		, m_ses(ses)
#endif
		, m_abort(false)
	{}

	tracker_manager::~tracker_manager()
	{
		TORRENT_ASSERT(m_abort);
		abort_all_requests(true);
	}

	void tracker_manager::sent_bytes(int bytes)
	{
		TORRENT_ASSERT(m_ses.is_single_thread());
		m_stats_counters.inc_stats_counter(counters::sent_tracker_bytes, bytes);
	}
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(30)">../src/udp_tracker_connection.cpp:83</a></td><td>support authentication here. tracker_req().auth</td></tr><tr id="30" style="display: none;" colspan="3"><td colspan="3"><h2>support authentication here. tracker_req().auth</h2><h4>../src/udp_tracker_connection.cpp:83</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		udp_tracker_connection::m_connection_cache;

	mutex udp_tracker_connection::m_cache_mutex;

	udp_tracker_connection::udp_tracker_connection(
		io_service&amp; ios
		, tracker_manager&amp; man
		, tracker_request const&amp; req
		, boost::weak_ptr&lt;request_callback&gt; c)
		: tracker_connection(man, req, ios, c)
		, m_transaction_id(0)
		, m_attempts(0)
		, m_state(action_error)
		, m_abort(false)
	{
		update_transaction_id();
	}

	void udp_tracker_connection::start()
	{
<div style="background: #ffff00" width="100%">		std::string hostname;
</div>		std::string protocol;
		int port;
		error_code ec;

		using boost::tuples::ignore;
		boost::tie(protocol, ignore, hostname, port, ignore)
			= parse_url_components(tracker_req().url, ec);
		if (port == -1) port = protocol == "http" ? 80 : 443;

		if (ec)
		{
			tracker_connection::fail(ec);
			return;
		}
		
		aux::session_settings const&amp; settings = m_man.settings();

		if (settings.get_bool(settings_pack::proxy_hostnames)
			&amp;&amp; (settings.get_int(settings_pack::proxy_type) == settings_pack::socks5
				|| settings.get_int(settings_pack::proxy_type) == settings_pack::socks5_pw))
		{
			m_hostname = hostname;
			m_target.port(port);
			start_announce();
		}
		else
		{
#if defined TORRENT_ASIO_DEBUGGING
			add_outstanding_async("udp_tracker_connection::name_lookup");
#endif
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(31)">../src/ut_metadata.cpp:120</a></td><td>if we were to initialize m_metadata_size lazily instead, we would probably be more efficient initialize m_metadata_size</td></tr><tr id="31" style="display: none;" colspan="3"><td colspan="3"><h2>if we were to initialize m_metadata_size lazily instead,
we would probably be more efficient
initialize m_metadata_size</h2><h4>../src/ut_metadata.cpp:120</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				metadata();
		}

		bool need_loaded()
		{ return m_torrent.need_loaded(); }

		virtual void on_unload()
		{
			m_metadata.reset();
		}

		virtual void on_load()
		{
			// initialize m_metadata_size
			TORRENT_ASSERT(m_torrent.is_loaded());
			metadata();
		}

		virtual void on_files_checked()
		{
<div style="background: #ffff00" width="100%">			metadata();
</div>		}

		virtual boost::shared_ptr&lt;peer_plugin&gt; new_connection(
			peer_connection* pc);
		
		int get_metadata_size() const
		{
			TORRENT_ASSERT(m_metadata_size &gt; 0);
			return m_metadata_size;
		}

		buffer::const_interval metadata() const
		{
			if (!m_torrent.need_loaded()) return buffer::const_interval(NULL, NULL);
			TORRENT_ASSERT(m_torrent.valid_metadata());
			if (!m_metadata)
			{
				m_metadata = m_torrent.torrent_file().metadata();
				m_metadata_size = m_torrent.torrent_file().metadata_size();
				TORRENT_ASSERT(hasher(m_metadata.get(), m_metadata_size).final()
					== m_torrent.torrent_file().info_hash());
			}
			return buffer::const_interval(m_metadata.get(), m_metadata.get()
				+ m_metadata_size);
		}

		bool received_metadata(ut_metadata_peer_plugin&amp; source
			, char const* buf, int size, int piece, int total_size);

		// returns a piece of the metadata that
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(32)">../src/utp_stream.cpp:351</a></td><td>it would be nice if not everything would have to be public here</td></tr><tr id="32" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice if not everything would have to be public here</h2><h4>../src/utp_stream.cpp:351</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	void incoming(boost::uint8_t const* buf, int size, packet* p, time_point now);
	void do_ledbat(int acked_bytes, int delay, int in_flight);
	int packet_timeout() const;
	bool test_socket_state();
	void maybe_trigger_receive_callback();
	void maybe_trigger_send_callback();
	bool cancel_handlers(error_code const&amp; ec, bool kill);
	bool consume_incoming_data(
		utp_header const* ph, boost::uint8_t const* ptr, int payload_size, time_point now);
	void update_mtu_limits();
	void experienced_loss(int seq_nr);

	void set_state(int s);

private:

	// non-copyable
	utp_socket_impl(utp_socket_impl const&amp;);
	utp_socket_impl const&amp; operator=(utp_socket_impl const&amp;);

<div style="background: #ffff00" width="100%">public:
</div>
	void check_receive_buffers() const;

#if TORRENT_USE_INVARIANT_CHECKS
	void check_invariant() const;
#endif

	utp_socket_manager* m_sm;

	// userdata pointer passed along
	// with any callback. This is initialized to 0
	// then set to point to the utp_stream when
	// hooked up, and then reset to 0 once the utp_stream
	// detaches. This is used to know whether or not
	// the socket impl is still attached to a utp_stream
	// object. When it isn't, we'll never be able to
	// signal anything back to the client, and in case
	// of errors, we just have to delete ourselves
	// i.e. transition to the UTP_STATE_DELETED state
	void* m_userdata;

	// This is a platform-independent replacement
	// for the regular iovec type in posix. Since
	// it's not used in any system call, we might as
	// well define our own type instead of wrapping
	// the system's type.
	struct iovec_t
	{
		iovec_t(void* b, size_t l): buf(b), len(l) {}
		void* buf;
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(33)">../src/web_peer_connection.cpp:632</a></td><td>just make this peer not have the pieces associated with the file we just requested. Only when it doesn't have any of the file do the following</td></tr><tr id="33" style="display: none;" colspan="3"><td colspan="3"><h2>just make this peer not have the pieces
associated with the file we just requested. Only
when it doesn't have any of the file do the following</h2><h4>../src/web_peer_connection.cpp:632</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			++m_num_responses;

			if (m_parser.connection_close())
			{
				incoming_choke();
				if (m_num_responses == 1)
					m_web-&gt;supports_keepalive = false;
			}

#ifndef TORRENT_DISABLE_LOGGING
			peer_log(peer_log_alert::info, "STATUS"
				, "%d %s", m_parser.status_code(), m_parser.message().c_str());
			std::multimap&lt;std::string, std::string&gt; const&amp; headers = m_parser.headers();
			for (std::multimap&lt;std::string, std::string&gt;::const_iterator i = headers.begin()
				, end(headers.end()); i != end; ++i)
				peer_log(peer_log_alert::info, "STATUS", "   %s: %s", i-&gt;first.c_str(), i-&gt;second.c_str());
#endif
			// if the status code is not one of the accepted ones, abort
			if (!is_ok_status(m_parser.status_code()))
			{
<div style="background: #ffff00" width="100%">				int retry_time = atoi(m_parser.header("retry-after").c_str());
</div>				if (retry_time &lt;= 0) retry_time = m_settings.get_int(settings_pack::urlseed_wait_retry);
				// temporarily unavailable, retry later
				t-&gt;retry_web_seed(this, retry_time);
				std::string error_msg = to_string(m_parser.status_code()).elems
					+ (" " + m_parser.message());
				if (t-&gt;alerts().should_post&lt;url_seed_alert&gt;())
				{
					t-&gt;alerts().emplace_alert&lt;url_seed_alert&gt;(t-&gt;get_handle(), m_url
						, error_msg);
				}
				received_bytes(0, bytes_transferred);
				disconnect(error_code(m_parser.status_code(), get_http_category()), op_bittorrent, 1);
#ifdef TORRENT_DEBUG
				TORRENT_ASSERT(statistics().last_payload_downloaded()
					+ statistics().last_protocol_downloaded()
					== dl_target);
#endif
				return;
			}
			if (is_redirect(m_parser.status_code()))
			{
				// this means we got a redirection request
				// look for the location header
				std::string location = m_parser.header("location");
				received_bytes(0, bytes_transferred);

				if (location.empty())
				{
					// we should not try this server again.
					t-&gt;remove_web_seed(this, errors::missing_location, op_bittorrent, 2);
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(34)">../src/web_peer_connection.cpp:691</a></td><td>create a mapping of file-index to redirection URLs. Use that to form URLs instead. Support to reconnect to a new server without destructing this peer_connection</td></tr><tr id="34" style="display: none;" colspan="3"><td colspan="3"><h2>create a mapping of file-index to redirection URLs. Use that to form
URLs instead. Support to reconnect to a new server without destructing this
peer_connection</h2><h4>../src/web_peer_connection.cpp:691</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">						== dl_target);
#endif
					return;
				}
				
				bool single_file_request = false;
				if (!m_path.empty() &amp;&amp; m_path[m_path.size() - 1] != '/')
					single_file_request = true;

				// add the redirected url and remove the current one
				if (!single_file_request)
				{
					TORRENT_ASSERT(!m_file_requests.empty());
					int file_index = m_file_requests.front();

						if (!t-&gt;need_loaded())
						{
							disconnect(errors::torrent_aborted, op_bittorrent);
							return;
						}
<div style="background: #ffff00" width="100%">						torrent_info const&amp; info = t-&gt;torrent_file();
</div>						std::string path = info.orig_files().file_path(file_index);
#ifdef TORRENT_WINDOWS
						convert_path_to_posix(path);
#endif
						path = escape_path(path.c_str(), path.length());
						size_t i = location.rfind(path);
						if (i == std::string::npos)
						{
							t-&gt;remove_web_seed(this, errors::invalid_redirection, op_bittorrent, 2);
							m_web = NULL;
							TORRENT_ASSERT(is_disconnecting());
#ifdef TORRENT_DEBUG
							TORRENT_ASSERT(statistics().last_payload_downloaded()
								+ statistics().last_protocol_downloaded()
								== dl_target);
#endif
							return;
						}
						location.resize(i);
					}
					else
					{
						location = resolve_redirect_location(m_url, location);
					}

#ifndef TORRENT_DISABLE_LOGGING
					peer_log(peer_log_alert::info, "LOCATION", "%s", location.c_str());
#endif
					t-&gt;add_web_seed(location, web_seed_entry::url_seed, m_external_auth, m_extra_headers);
					t-&gt;remove_web_seed(this, errors::redirecting, op_bittorrent, 2);
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(35)">../src/kademlia/node.cpp:69</a></td><td>make this configurable in dht_settings</td></tr><tr id="35" style="display: none;" colspan="3"><td colspan="3"><h2>make this configurable in dht_settings</h2><h4>../src/kademlia/node.cpp:69</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include "libtorrent/kademlia/node_id.hpp"
#include "libtorrent/kademlia/rpc_manager.hpp"
#include "libtorrent/kademlia/routing_table.hpp"
#include "libtorrent/kademlia/node.hpp"
#include "libtorrent/kademlia/dht_observer.hpp"

#include "libtorrent/kademlia/refresh.hpp"
#include "libtorrent/kademlia/get_peers.hpp"
#include "libtorrent/kademlia/get_item.hpp"
#include "libtorrent/performance_counters.hpp" // for counters

#ifdef TORRENT_USE_VALGRIND
#include &lt;valgrind/memcheck.h&gt;
#endif

namespace libtorrent { namespace dht
{

using detail::write_endpoint;

<div style="background: #ffff00" width="100%">enum { announce_interval = 30 };
</div>
#ifdef TORRENT_DHT_VERBOSE_LOGGING
TORRENT_DEFINE_LOG(node)
#endif

namespace {

// remove peers that have timed out
void purge_peers(std::set&lt;peer_entry&gt;&amp; peers)
{
	for (std::set&lt;peer_entry&gt;::iterator i = peers.begin()
		  , end(peers.end()); i != end;)
	{
		// the peer has timed out
		if (i-&gt;added + minutes(int(announce_interval * 1.5f)) &lt; aux::time_now())
		{
#ifdef TORRENT_DHT_VERBOSE_LOGGING
			TORRENT_LOG(node) &lt;&lt; "peer timed out at: " &lt;&lt; i-&gt;addr;
#endif
			peers.erase(i++);
		}
		else
			++i;
	}
}

void nop() {}

node_id calculate_node_id(node_id const&amp; nid, dht_observer* observer)
{
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(36)">../src/kademlia/node.cpp:497</a></td><td>it would be nice to have a bias towards node-id prefixes that are missing in the bucket</td></tr><tr id="36" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to have a bias towards node-id prefixes that
are missing in the bucket</h2><h4>../src/kademlia/node.cpp:497</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// this shouldn't happen
	TORRENT_ASSERT(m_id != ne-&gt;id);
	if (ne-&gt;id == m_id) return;

	int bucket = 159 - distance_exp(m_id, ne-&gt;id);
	TORRENT_ASSERT(bucket &lt; 160);
	send_single_refresh(ne-&gt;ep(), bucket, ne-&gt;id);
}

void node::send_single_refresh(udp::endpoint const&amp; ep, int bucket
	, node_id const&amp; id)
{
	TORRENT_ASSERT(id != m_id);
	void* ptr = m_rpc.allocate_observer();
	if (ptr == 0) return;

	TORRENT_ASSERT(bucket &gt;= 0);
	TORRENT_ASSERT(bucket &lt;= 159);

	// generate a random node_id within the given bucket
<div style="background: #ffff00" width="100%">	node_id mask = generate_prefix_mask(bucket + 1);
</div>	node_id target = generate_secret_id() &amp; ~mask;
	target |= m_id &amp; mask;

	// create a dummy traversal_algorithm		
	// this is unfortunately necessary for the observer
	// to free itself from the pool when it's being released
	boost::intrusive_ptr&lt;traversal_algorithm&gt; algo(
		new traversal_algorithm(*this, (node_id::min)()));
	observer_ptr o(new (ptr) ping_observer(algo, ep, id));
#if defined TORRENT_DEBUG || TORRENT_RELEASE_ASSERTS
	o-&gt;m_in_constructor = false;
#endif
	entry e;
	e["y"] = "q";
	entry&amp; a = e["a"];

	// use get_peers instead of find_node. We'll get nodes in the response
	// either way.
	e["q"] = "get_peers";
	a["info_hash"] = target.to_string();
	m_counters.inc_stats_counter(counters::dht_get_peers_out);

//	e["q"] = "find_node";
//	a["target"] = target.to_string();
	m_rpc.invoke(e, ep, o);
}

time_duration node::connection_timeout()
{
	time_duration d = m_rpc.tick();
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(37)">../src/kademlia/node.cpp:587</a></td><td>use the non deprecated function instead of this one</td></tr><tr id="37" style="display: none;" colspan="3"><td colspan="3"><h2>use the non deprecated function instead of this one</h2><h4>../src/kademlia/node.cpp:587</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	return d;
}

void node::status(std::vector&lt;dht_routing_bucket&gt;&amp; table
	, std::vector&lt;dht_lookup&gt;&amp; requests)
{
	mutex_t::scoped_lock l(m_mutex);

	m_table.status(table);

	for (std::set&lt;traversal_algorithm*&gt;::iterator i = m_running_requests.begin()
		, end(m_running_requests.end()); i != end; ++i)
	{
		requests.push_back(dht_lookup());
		dht_lookup&amp; l = requests.back();
		(*i)-&gt;status(l);
	}
}

#ifndef TORRENT_NO_DEPRECATE
<div style="background: #ffff00" width="100%">void node::status(session_status&amp; s)
</div>{
	mutex_t::scoped_lock l(m_mutex);

	m_table.status(s);
	s.dht_torrents = int(m_map.size());
	s.active_requests.clear();
	s.dht_total_allocations = m_rpc.num_allocated_observers();
	for (std::set&lt;traversal_algorithm*&gt;::iterator i = m_running_requests.begin()
		, end(m_running_requests.end()); i != end; ++i)
	{
		s.active_requests.push_back(dht_lookup());
		dht_lookup&amp; l = s.active_requests.back();
		(*i)-&gt;status(l);
	}
}
#endif

void node::lookup_peers(sha1_hash const&amp; info_hash, entry&amp; reply
	, bool noseed, bool scrape) const
{
	if (m_observer)
		m_observer-&gt;get_peers(info_hash);

	table_t::const_iterator i = m_map.lower_bound(info_hash);
	if (i == m_map.end()) return;
	if (i-&gt;first != info_hash) return;

	torrent_entry const&amp; v = i-&gt;second;

	if (!v.name.empty()) reply["n"] = v.name;
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(38)">../src/kademlia/node.cpp:919</a></td><td>find_node should write directly to the response entry</td></tr><tr id="38" style="display: none;" colspan="3"><td colspan="3"><h2>find_node should write directly to the response entry</h2><h4>../src/kademlia/node.cpp:919</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			TORRENT_LOG(node) &lt;&lt; " values: " &lt;&lt; reply["values"].list().size();
		}
#endif
	}
	else if (query_len == 9 &amp;&amp; memcmp(query, "find_node", 9) == 0)
	{
		key_desc_t msg_desc[] = {
			{"target", bdecode_node::string_t, 20, 0},
		};

		bdecode_node msg_keys[1];
		if (!verify_message(arg_ent, msg_desc, msg_keys, 1, error_string, sizeof(error_string)))
		{
			incoming_error(e, error_string);
			return;
		}

		m_counters.inc_stats_counter(counters::dht_find_node_in);
		sha1_hash target(msg_keys[0].string_ptr());

<div style="background: #ffff00" width="100%">		nodes_t n;
</div>		m_table.find_node(target, n, 0);
		write_nodes_entry(reply, n);
	}
	else if (query_len == 13 &amp;&amp; memcmp(query, "announce_peer", 13) == 0)
	{
		key_desc_t msg_desc[] = {
			{"info_hash", bdecode_node::string_t, 20, 0},
			{"port", bdecode_node::int_t, 0, 0},
			{"token", bdecode_node::string_t, 0, 0},
			{"n", bdecode_node::string_t, 0, key_desc_t::optional},
			{"seed", bdecode_node::int_t, 0, key_desc_t::optional},
			{"implied_port", bdecode_node::int_t, 0, key_desc_t::optional},
		};

		bdecode_node msg_keys[6];
		if (!verify_message(arg_ent, msg_desc, msg_keys, 6, error_string, sizeof(error_string)))
		{
			m_counters.inc_stats_counter(counters::dht_invalid_announce);
			incoming_error(e, error_string);
			return;
		}

		int port = int(msg_keys[1].int_value());

		// is the announcer asking to ignore the explicit
		// listen port and instead use the source port of the packet?
		if (msg_keys[5] &amp;&amp; msg_keys[5].int_value() != 0)
			port = m.addr.port();

		if (port &lt; 0 || port &gt;= 65536)
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(39)">../src/kademlia/routing_table.cpp:114</a></td><td>use the non deprecated function instead of this one</td></tr><tr id="39" style="display: none;" colspan="3"><td colspan="3"><h2>use the non deprecated function instead of this one</h2><h4>../src/kademlia/routing_table.cpp:114</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	static const int size_exceptions[] = {16, 8, 4, 2};
	if (bucket &lt; int(sizeof(size_exceptions)/sizeof(size_exceptions[0])))
		return m_bucket_size * size_exceptions[bucket];
	return m_bucket_size;
}

void routing_table::status(std::vector&lt;dht_routing_bucket&gt;&amp; s) const
{
	for (table_t::const_iterator i = m_buckets.begin()
		, end(m_buckets.end()); i != end; ++i)
	{
		dht_routing_bucket b;
		b.num_nodes = i-&gt;live_nodes.size();
		b.num_replacements = i-&gt;replacements.size();
		s.push_back(b);
	}
}

#ifndef TORRENT_NO_DEPRECATE
<div style="background: #ffff00" width="100%">void routing_table::status(session_status&amp; s) const
</div>{
	int ignore;
	boost::tie(s.dht_nodes, s.dht_node_cache, ignore) = size();
	s.dht_global_nodes = num_global_nodes();

	for (table_t::const_iterator i = m_buckets.begin()
		, end(m_buckets.end()); i != end; ++i)
	{
		dht_routing_bucket b;
		b.num_nodes = i-&gt;live_nodes.size();
		b.num_replacements = i-&gt;replacements.size();
#ifndef TORRENT_NO_DEPRECATE
		b.last_active = 0;
#endif
		s.dht_routing_table.push_back(b);
	}
}
#endif

boost::tuple&lt;int, int, int&gt; routing_table::size() const
{
	int nodes = 0;
	int replacements = 0;
	int confirmed = 0;
	for (table_t::const_iterator i = m_buckets.begin()
		, end(m_buckets.end()); i != end; ++i)
	{
		nodes += i-&gt;live_nodes.size();
		for (bucket_t::const_iterator k = i-&gt;live_nodes.begin()
			, end(i-&gt;live_nodes.end()); k != end; ++k)
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(40)">../src/kademlia/routing_table.cpp:946</a></td><td>move the lowest priority nodes to the replacement bucket</td></tr><tr id="40" style="display: none;" colspan="3"><td colspan="3"><h2>move the lowest priority nodes to the replacement bucket</h2><h4>../src/kademlia/routing_table.cpp:946</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	bucket_t&amp; b = m_buckets[bucket_index].live_nodes;
	bucket_t&amp; rb = m_buckets[bucket_index].replacements;

	// move any node whose (160 - distane_exp(m_id, id)) &gt;= (i - m_buckets.begin())
	// to the new bucket
	int new_bucket_size = bucket_limit(bucket_index + 1);
	for (bucket_t::iterator j = b.begin(); j != b.end();)
	{
		if (distance_exp(m_id, j-&gt;id) &gt;= 159 - bucket_index)
		{
			++j;
			continue;
		}
		// this entry belongs in the new bucket
		new_bucket.push_back(*j);
		j = b.erase(j);
	}

	if (b.size() &gt; bucket_size_limit)
	{
<div style="background: #ffff00" width="100%">		for (bucket_t::iterator i = b.begin() + bucket_size_limit
</div>			, end(b.end()); i != end; ++i)
		{
			rb.push_back(*i);
		}

		b.resize(bucket_size_limit);
	}

	// split the replacement bucket as well. If the live bucket
	// is not full anymore, also move the replacement entries
	// into the main bucket
	for (bucket_t::iterator j = rb.begin(); j != rb.end();)
	{
		if (distance_exp(m_id, j-&gt;id) &gt;= 159 - bucket_index)
		{
			if (int(b.size()) &gt;= bucket_size_limit)
			{
				++j;
				continue;
			}
			b.push_back(*j);
		}
		else
		{
			// this entry belongs in the new bucket
			if (int(new_bucket.size()) &lt; new_bucket_size)
				new_bucket.push_back(*j);
			else
				new_replacement_bucket.push_back(*j);
		}
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(41)">../include/libtorrent/alert_types.hpp:1428</a></td><td>should the alert baseclass have this object instead?</td></tr><tr id="41" style="display: none;" colspan="3"><td colspan="3"><h2>should the alert baseclass have this object instead?</h2><h4>../include/libtorrent/alert_types.hpp:1428</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{
		// internal
		portmap_log_alert(aux::stack_allocator&amp; alloc, int t, const char* m);

		TORRENT_DEFINE_ALERT(portmap_log_alert, 52)

		static const int static_category = alert::port_mapping_notification;
		virtual std::string message() const;

		int map_type;

#ifndef TORRENT_NO_DEPRECATE
		std::string msg;
#endif

		// the message associated with this log line
		char const* log_message() const;

	private:

<div style="background: #ffff00" width="100%">		aux::stack_allocator const&amp; m_alloc;
</div>
		int m_log_idx;
	};

	// This alert is generated when a fastresume file has been passed to
	// add_torrent() but the files on disk did not match the fastresume file.
	// The error_code explains the reason why the resume file was rejected.
	struct TORRENT_EXPORT fastresume_rejected_alert: torrent_alert
	{
		// internal
		fastresume_rejected_alert(aux::stack_allocator&amp; alloc
			, torrent_handle const&amp; h
			, error_code const&amp; ec
			, std::string const&amp; file
			, char const* op);

		TORRENT_DEFINE_ALERT(fastresume_rejected_alert, 53)

		static const int static_category = alert::status_notification
			| alert::error_notification;
		virtual std::string message() const;

		error_code error;

#ifndef TORRENT_NO_DEPRECATE
		// If the error happend to a specific file, ``file`` is the path to it.
		std::string file;
#endif

		// If the error happend to a specific file, this returns the path to it.
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(42)">../include/libtorrent/build_config.hpp:40</a></td><td>instead of using a dummy function to cause link errors when incompatible build configurations are used, make the namespace name depend on the configuration, and have a using declaration in the headers to pull it into libtorrent.</td></tr><tr id="42" style="display: none;" colspan="3"><td colspan="3"><h2>instead of using a dummy function to cause link errors when
incompatible build configurations are used, make the namespace name
depend on the configuration, and have a using declaration in the headers
to pull it into libtorrent.</h2><h4>../include/libtorrent/build_config.hpp:40</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

*/

#ifndef TORRENT_BUILD_CONFIG_HPP_INCLUDED
#define TORRENT_BUILD_CONFIG_HPP_INCLUDED

#include "libtorrent/config.hpp"
#include &lt;boost/preprocessor/cat.hpp&gt;
#include &lt;boost/preprocessor/stringize.hpp&gt;

<div style="background: #ffff00" width="100%">#if TORRENT_USE_IPV6
</div>#define TORRENT_CFG_IPV6 ipv6_
#else
#define TORRENT_CFG_IPV6 noipv6_
#endif

#ifdef TORRENT_NO_DEPRECATE
#define TORRENT_CFG_DEPR nodeprecate_
#else
#define TORRENT_CFG_DEPR deprecated_
#endif

#define TORRENT_CFG \
	BOOST_PP_CAT(TORRENT_CFG_IPV6, \
	TORRENT_CFG_DEPR)

#define TORRENT_CFG_STRING BOOST_PP_STRINGIZE(TORRENT_CFG)

#endif

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(43)">../include/libtorrent/enum_net.hpp:143</a></td><td>this could be done more efficiently by just looking up the interface with the given name, maybe even with if_nametoindex()</td></tr><tr id="43" style="display: none;" colspan="3"><td colspan="3"><h2>this could be done more efficiently by just looking up
the interface with the given name, maybe even with if_nametoindex()</h2><h4>../include/libtorrent/enum_net.hpp:143</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		address ip = address::from_string(device_name, ec);
		if (!ec)
		{
			bind_ep.address(ip);
			// it appears to be an IP. Just bind to that address
			sock.bind(bind_ep, ec);
			return bind_ep.address();
		}

		ec.clear();

#ifdef SO_BINDTODEVICE
		// try to use SO_BINDTODEVICE here, if that exists. If it fails,
		// fall back to the mechanism we have below
		sock.set_option(bind_to_device_opt(device_name), ec);
		if (ec)
#endif
		{
			ec.clear();
<div style="background: #ffff00" width="100%">			std::vector&lt;ip_interface&gt; ifs = enum_net_interfaces(ios, ec);
</div>			if (ec) return bind_ep.address();

			bool found = false;

			for (int i = 0; i &lt; int(ifs.size()); ++i)
			{
				// we're looking for a specific interface, and its address
				// (which must be of the same family as the address we're
				// connecting to)
				if (strcmp(ifs[i].name, device_name) != 0) continue;
				if (ifs[i].interface_address.is_v4() != ipv4)
					continue;

				bind_ep.address(ifs[i].interface_address);
				found = true;
				break;
			}

			if (!found)
			{
				ec = error_code(boost::system::errc::no_such_device, generic_category());
				return bind_ep.address();
			}
		}
		sock.bind(bind_ep, ec);
		return bind_ep.address();
	}

	// returns true if the given device exists
	TORRENT_EXTRA_EXPORT bool has_interface(char const* name, io_service&amp; ios
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(44)">../include/libtorrent/heterogeneous_queue.hpp:56</a></td><td>add emplace_back() version</td></tr><tr id="44" style="display: none;" colspan="3"><td colspan="3"><h2>add emplace_back() version</h2><h4>../include/libtorrent/heterogeneous_queue.hpp:56</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include &lt;vector&gt;

#include &lt;boost/cstdint.hpp&gt;
#include &lt;boost/utility/enable_if.hpp&gt;
#include &lt;boost/type_traits/is_base_of.hpp&gt;

#include "libtorrent/assert.hpp"

namespace libtorrent {

	template &lt;class T&gt;
	struct heterogeneous_queue
	{
		heterogeneous_queue()
			: m_storage(NULL)
			, m_capacity(0)
			, m_size(0)
			, m_num_items(0)
		{}

<div style="background: #ffff00" width="100%">		template &lt;class U&gt;
</div>		typename boost::enable_if&lt;boost::is_base_of&lt;T, U&gt; &gt;::type
		push_back(U const&amp; a)
		{
			// the size of the type rounded up to pointer alignment
			const int object_size = (sizeof(U) + sizeof(*m_storage) - 1)
				/ sizeof(*m_storage);

			// +1 for the length prefix
			if (m_size + object_size + header_size &gt; m_capacity)
				grow_capacity(object_size);

			uintptr_t* ptr = m_storage + m_size;

			// length prefix
			header_t* hdr = reinterpret_cast&lt;header_t*&gt;(ptr);
			hdr-&gt;len = object_size;
			hdr-&gt;move = &amp;move&lt;U&gt;;
			ptr += header_size;

			// construct in-place
			new (ptr) U(a);

			// if we constructed the object without throwing any exception
			// update counters to indicate the new item is in there
			++m_num_items;
			m_size += header_size + object_size;
		}

		void get_pointers(std::vector&lt;T*&gt;&amp; out)
		{
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(45)">../include/libtorrent/piece_picker.hpp:600</a></td><td>having 8 priority levels is probably excessive. It should probably be changed to 3 levels + dont-download</td></tr><tr id="45" style="display: none;" colspan="3"><td colspan="3"><h2>having 8 priority levels is probably excessive. It should
probably be changed to 3 levels + dont-download</h2><h4>../include/libtorrent/piece_picker.hpp:600</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// the number of peers that has this piece
			// (availability)
#ifdef TORRENT_OPTIMIZE_MEMORY_USAGE
			boost::uint32_t peer_count : 9;
#else
			boost::uint32_t peer_count : 16;
#endif

			// one of the enums from state_t. This indicates whether this piece
			// is currently being downloaded or not, and what state it's in if
			// it is. Specifically, as an optimization, pieces that have all blocks
			// requested from them are separated out into separate lists to make
			// lookups quicker. The main oddity is that whether a downloading piece
			// has only been requested from peers that are reverse, that's
			// recorded as piece_downloading_reverse, which really means the same
			// as piece_downloading, it just saves space to also indicate that it
			// has a bit lower priority. The reverse bit is only relevant if the
			// state is piece_downloadin.
			boost::uint32_t download_state : 3;

<div style="background: #ffff00" width="100%">
</div>			// is 0 if the piece is filtered (not to be downloaded)
			// 1 is low priority
			// 2 is low priority
			// 3 is mid priority
			// 4 is default priority
			// 5 is mid priority
			// 6 is high priority
			// 7 is high priority
			boost::uint32_t piece_priority : 3;

			// index in to the piece_info vector
#ifdef TORRENT_OPTIMIZE_MEMORY_USAGE
			boost::uint32_t index : 17;
#else
			boost::uint32_t index;
#endif

#ifdef TORRENT_DEBUG_REFCOUNTS
			// all the peers that have this piece
			std::set&lt;const void*&gt; have_peers;
#endif

			enum
			{
				// index is set to this to indicate that we have the
				// piece. There is no entry for the piece in the
				// buckets if this is the case.
#ifdef TORRENT_OPTIMIZE_MEMORY_USAGE
				we_have_index = 0x3ffff,
#else
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(46)">../include/libtorrent/proxy_base.hpp:259</a></td><td>use the resolver interface that has a built-in cache</td></tr><tr id="46" style="display: none;" colspan="3"><td colspan="3"><h2>use the resolver interface that has a built-in cache</h2><h4>../include/libtorrent/proxy_base.hpp:259</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		return m_sock.lowest_layer();
	}

	next_layer_type&amp; next_layer()
	{
		return m_sock;
	}

	bool is_open() const { return m_sock.is_open(); }
	
protected:

	bool handle_error(error_code const&amp; e, boost::shared_ptr&lt;handler_type&gt; const&amp; h);

	stream_socket m_sock;
	std::string m_hostname;
	int m_port;

	endpoint_type m_remote_endpoint;

<div style="background: #ffff00" width="100%">	tcp::resolver m_resolver;
</div>};

}

#endif

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(47)">../include/libtorrent/session.hpp:198</a></td><td>the two second constructors here should probably be deprecated in favor of the more generic one that just takes a settings_pack and a string</td></tr><tr id="47" style="display: none;" colspan="3"><td colspan="3"><h2>the two second constructors here should probably
be deprecated in favor of the more generic one that just
takes a settings_pack and a string</h2><h4>../include/libtorrent/session.hpp:198</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// nat-pmp) and default plugins (ut_metadata, ut_pex and smart_ban). The
		// default is to start those features. If you do not want them to start,
		// pass 0 as the flags parameter.
		// 
		// The ``alert_mask`` is the same mask that you would send to
		// set_alert_mask().

		session(settings_pack const&amp; pack
			, int flags = start_default_features | add_default_plugins)
		{
			TORRENT_CFG();
			start(flags, pack);
		}
		session(fingerprint const&amp; print = fingerprint("LT"
			, LIBTORRENT_VERSION_MAJOR, LIBTORRENT_VERSION_MINOR, 0, 0)
			, int flags = start_default_features | add_default_plugins
			, boost::uint32_t alert_mask = alert::error_notification)
		{
			TORRENT_CFG();
			settings_pack pack;
<div style="background: #ffff00" width="100%">			pack.set_int(settings_pack::alert_mask, alert_mask);
</div>			pack.set_str(settings_pack::peer_fingerprint, print.to_string());
			if ((flags &amp; start_default_features) == 0)
			{
				pack.set_bool(settings_pack::enable_upnp, false);
				pack.set_bool(settings_pack::enable_natpmp, false);
				pack.set_bool(settings_pack::enable_lsd, false);
				pack.set_bool(settings_pack::enable_dht, false);
			}

			start(flags, pack);
		}
		session(fingerprint const&amp; print
			, std::pair&lt;int, int&gt; listen_port_range
			, char const* listen_interface = "0.0.0.0"
			, int flags = start_default_features | add_default_plugins
			, int alert_mask = alert::error_notification)
		{
			TORRENT_CFG();
			TORRENT_ASSERT(listen_port_range.first &gt; 0);
			TORRENT_ASSERT(listen_port_range.first &lt;= listen_port_range.second);

			settings_pack pack;
			pack.set_int(settings_pack::alert_mask, alert_mask);
			pack.set_int(settings_pack::max_retry_port_bind, listen_port_range.second - listen_port_range.first);
			pack.set_str(settings_pack::peer_fingerprint, print.to_string());
			char if_string[100];
			snprintf(if_string, sizeof(if_string), "%s:%d", listen_interface, listen_port_range.first);
			pack.set_str(settings_pack::listen_interfaces, if_string);

			if ((flags &amp; start_default_features) == 0)
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(48)">../include/libtorrent/session.hpp:249</a></td><td>the ip filter should probably be saved here too</td></tr><tr id="48" style="display: none;" colspan="3"><td colspan="3"><h2>the ip filter should probably be saved here too</h2><h4>../include/libtorrent/session.hpp:249</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			pack.set_str(settings_pack::listen_interfaces, if_string);

			if ((flags &amp; start_default_features) == 0)
			{
				pack.set_bool(settings_pack::enable_upnp, false);
				pack.set_bool(settings_pack::enable_natpmp, false);
				pack.set_bool(settings_pack::enable_lsd, false);
				pack.set_bool(settings_pack::enable_dht, false);
			}
			start(flags, pack);
		}
			
		// The destructor of session will notify all trackers that our torrents
		// have been shut down. If some trackers are down, they will time out.
		// All this before the destructor of session returns. So, it's advised
		// that any kind of interface (such as windows) are closed before
		// destructing the session object. Because it can take a few second for
		// it to finish. The timeout can be set with apply_settings().
		~session();

<div style="background: #ffff00" width="100%">
</div>		// flags that determines which aspects of the session should be
		// saved when calling save_state().
		enum save_state_flags_t
		{
			// saves settings (i.e. the session_settings)
			save_settings =     0x001,

			// saves dht_settings
			save_dht_settings = 0x002,

			// saves dht state such as nodes and node-id, possibly accelerating
			// joining the DHT if provided at next session startup.
			save_dht_state =    0x004,

			// save pe_settings
			save_encryption_settings = 0x020,

			// internal
			save_as_map =       0x040

#ifndef TORRENT_NO_DEPRECATE
			,
			// saves RSS feeds
			save_feeds =        0x080,
			save_proxy =        0x008,
			save_i2p_proxy =    0x010,
			save_dht_proxy = save_proxy,
			save_peer_proxy = save_proxy,
			save_web_proxy = save_proxy,
			save_tracker_proxy = save_proxy
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(49)">../include/libtorrent/session_settings.hpp:55</a></td><td>this type is only used internally now. move it to an internal header and make this type properly deprecated.</td></tr><tr id="49" style="display: none;" colspan="3"><td colspan="3"><h2>this type is only used internally now. move it to an internal
header and make this type properly deprecated.</h2><h4>../include/libtorrent/session_settings.hpp:55</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
#include "libtorrent/version.hpp"
#include "libtorrent/config.hpp"

#include &lt;boost/cstdint.hpp&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;

namespace libtorrent
{

#ifndef TORRENT_NO_DEPRECATE
#define TORRENT_EXPORT_DEPRECATED TORRENT_EXPORT
#else
#define TORRENT_EXPORT_DEPRECATED
#endif

	namespace aux { struct session_settings; }

<div style="background: #ffff00" width="100%">
</div>	// The ``proxy_settings`` structs contains the information needed to
	// direct certain traffic to a proxy.
	struct TORRENT_EXPORT_DEPRECATED proxy_settings
	{
		// defaults constructs proxy settings, initializing it to the default
		// settings.
		proxy_settings() : type(0)
			, port(0), proxy_hostnames(true)
			, proxy_peer_connections(true)
		{}

		// construct the proxy_settings object from the settings
		// this constructor is implemented in session_impl.cpp
		proxy_settings(aux::session_settings const&amp; sett);

		// the name or IP of the proxy server. ``port`` is the port number the
		// proxy listens to. If required, ``username`` and ``password`` can be
		// set to authenticate with the proxy.
		std::string hostname;

		// when using a proy type that requires authentication, the username
		// and password fields must be set to the credentials for the proxy.
		std::string username;
		std::string password;

#ifndef TORRENT_NO_DEPRECATE
		// the type of proxy to use. Assign one of these to the
		// proxy_settings::type field.
		enum proxy_type
		{
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(50)">../include/libtorrent/socket_type.hpp:321</a></td><td>it would be nice to use aligned_storage here when building on c++11</td></tr><tr id="50" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to use aligned_storage here when
building on c++11</h2><h4>../include/libtorrent/socket_type.hpp:321</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			sizeof(stream_socket)
			, sizeof(socks5_stream)
			, sizeof(http_stream)
			, sizeof(utp_stream)
#if TORRENT_USE_I2P
			, sizeof(i2p_stream)
#else
			, 0
#endif
#ifdef TORRENT_USE_OPENSSL
			, sizeof(ssl_stream&lt;stream_socket&gt;)
			, sizeof(ssl_stream&lt;socks5_stream&gt;)
			, sizeof(ssl_stream&lt;http_stream&gt;)
			, sizeof(ssl_stream&lt;utp_stream&gt;)
#else
			, 0, 0, 0, 0
#endif
			&gt;::value
		};

<div style="background: #ffff00" width="100%">		boost::int64_t m_data[(storage_size + sizeof(boost::int64_t) - 1)
</div>			/ sizeof(boost::int64_t)];
	};

	// returns true if this socket is an SSL socket
	bool is_ssl(socket_type const&amp; s);

	// returns true if this is a uTP socket
	bool is_utp(socket_type const&amp; s);

#if TORRENT_USE_I2P
	// returns true if this is an i2p socket
	bool is_i2p(socket_type const&amp; s);
#endif

	// assuming the socket_type s is an ssl socket, make sure it
	// verifies the hostname in its SSL handshake
	void setup_ssl_hostname(socket_type&amp; s, std::string const&amp; hostname, error_code&amp; ec);

	// properly shuts down SSL sockets. holder keeps s alive
	void async_shutdown(socket_type&amp; s, boost::shared_ptr&lt;void&gt; holder);
}

#endif

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(51)">../include/libtorrent/socks5_stream.hpp:135</a></td><td>add async_connect() that takes a hostname and port as well</td></tr><tr id="51" style="display: none;" colspan="3"><td colspan="3"><h2>add async_connect() that takes a hostname and port as well</h2><h4>../include/libtorrent/socks5_stream.hpp:135</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (m_dst_name.size() &gt; 255)
			m_dst_name.resize(255);
	}

	void close(error_code&amp; ec)
	{
		m_hostname.clear();
		m_dst_name.clear();
		proxy_base::close(ec);
	}

#ifndef BOOST_NO_EXCEPTIONS
	void close()
	{
		m_hostname.clear();
		m_dst_name.clear();
		proxy_base::close();
	}
#endif

<div style="background: #ffff00" width="100%">	template &lt;class Handler&gt;
</div>	void async_connect(endpoint_type const&amp; endpoint, Handler const&amp; handler)
	{
		// make sure we don't try to connect to INADDR_ANY. binding is fine,
		// and using a hostname is fine on SOCKS version 5.
		TORRENT_ASSERT(m_command == socks5_bind
			|| endpoint.address() != address()
			|| (!m_dst_name.empty() &amp;&amp; m_version == 5));

		m_remote_endpoint = endpoint;

		// the connect is split up in the following steps:
		// 1. resolve name of proxy server
		// 2. connect to proxy server
		// 3. if version == 5:
		//   3.1 send SOCKS5 authentication method message
		//   3.2 read SOCKS5 authentication response
		//   3.3 send username+password
		// 4. send SOCKS command message

		// to avoid unnecessary copying of the handler,
		// store it in a shaed_ptr
		boost::shared_ptr&lt;handler_type&gt; h(new handler_type(handler));

#if defined TORRENT_ASIO_DEBUGGING
		add_outstanding_async("socks5_stream::name_lookup");
#endif
		tcp::resolver::query q(m_hostname, to_string(m_port).elems);
		m_resolver.async_resolve(q, boost::bind(
			&amp;socks5_stream::name_lookup, this, _1, _2, h));
	}
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(52)">../include/libtorrent/tracker_manager.hpp:280</a></td><td>this class probably doesn't need to have virtual functions.</td></tr><tr id="52" style="display: none;" colspan="3"><td colspan="3"><h2>this class probably doesn't need to have virtual functions.</h2><h4>../include/libtorrent/tracker_manager.hpp:280</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		int m_completion_timeout;

		typedef mutex mutex_t;
		mutable mutex_t m_mutex;

		// used for timeouts
		// this is set when the request has been sent
		time_point m_start_time;

		// this is set every time something is received
		time_point m_read_time;

		// the asio async operation
		deadline_timer m_timeout;
		
		int m_read_timeout;

		bool m_abort;
	};

<div style="background: #ffff00" width="100%">	struct TORRENT_EXTRA_EXPORT tracker_connection
</div>		: timeout_handler
	{
		tracker_connection(tracker_manager&amp; man
			, tracker_request const&amp; req
			, io_service&amp; ios
			, boost::weak_ptr&lt;request_callback&gt; r);

		void update_transaction_id(boost::shared_ptr&lt;udp_tracker_connection&gt; c
			, boost::uint64_t tid);

		boost::shared_ptr&lt;request_callback&gt; requester() const;
		virtual ~tracker_connection() {}

		tracker_request const&amp; tracker_req() const { return m_req; }

		void fail(error_code const&amp; ec, int code = -1, char const* msg = ""
			, int interval = 0, int min_interval = 0);
		virtual void start() = 0;
		virtual void close();
		address const&amp; bind_interface() const { return m_req.bind_ip; }
		void sent_bytes(int bytes);
		void received_bytes(int bytes);
		virtual bool on_receive(error_code const&amp;, udp::endpoint const&amp;
			, char const* /* buf */, int /* size */) { return false; }
		virtual bool on_receive_hostname(error_code const&amp;
			, char const* /* hostname */
			, char const* /* buf */, int /* size */) { return false; }

		boost::shared_ptr&lt;tracker_connection&gt; shared_from_this()
		{
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(53)">../include/libtorrent/aux_/session_interface.hpp:146</a></td><td>the IP voting mechanism should be factored out to its own class, not part of the session</td></tr><tr id="53" style="display: none;" colspan="3"><td colspan="3"><h2>the IP voting mechanism should be factored out
to its own class, not part of the session</h2><h4>../include/libtorrent/aux_/session_interface.hpp:146</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#if TORRENT_USE_ASSERTS
		virtual bool is_single_thread() const = 0;
		virtual bool has_peer(peer_connection const* p) const = 0;
		virtual bool any_torrent_has_peer(peer_connection const* p) const = 0;
		virtual bool is_posting_torrent_updates() const = 0;
#endif
	protected:
		~session_logger() {}
	};
#endif // TORRENT_DISABLE_LOGGING || TORRENT_USE_ASSERTS

	// TOOD: 2 make this interface a lot smaller. It could be split up into
	// several smaller interfaces. Each subsystem could then limit the size
	// of the mock object to test it.
	struct session_interface
		: buffer_allocator_interface
#if !defined TORRENT_DISABLE_LOGGING || TORRENT_USE_ASSERTS
		, session_logger
#endif
	{
<div style="background: #ffff00" width="100%">		enum
</div>		{
			source_dht = 1,
			source_peer = 2,
			source_tracker = 4,
			source_router = 8
		};

		virtual void set_external_address(address const&amp; ip
			, int source_type, address const&amp; source) = 0;
		virtual external_ip const&amp; external_address() const = 0;

		virtual disk_interface&amp; disk_thread() = 0;

		virtual alert_manager&amp; alerts() = 0;

		virtual torrent_peer_allocator_interface* get_peer_allocator() = 0;
		virtual io_service&amp; get_io_service() = 0;
		virtual resolver_interface&amp; get_resolver() = 0;

		typedef boost::function&lt;void(error_code const&amp;, std::vector&lt;address&gt; const&amp;)&gt;
			callback_t;

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(54)">../include/libtorrent/aux_/session_interface.hpp:171</a></td><td>remove this. There's already get_resolver()</td></tr><tr id="54" style="display: none;" colspan="3"><td colspan="3"><h2>remove this. There's already get_resolver()</h2><h4>../include/libtorrent/aux_/session_interface.hpp:171</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			source_peer = 2,
			source_tracker = 4,
			source_router = 8
		};

		virtual void set_external_address(address const&amp; ip
			, int source_type, address const&amp; source) = 0;
		virtual external_ip const&amp; external_address() const = 0;

		virtual disk_interface&amp; disk_thread() = 0;

		virtual alert_manager&amp; alerts() = 0;

		virtual torrent_peer_allocator_interface* get_peer_allocator() = 0;
		virtual io_service&amp; get_io_service() = 0;
		virtual resolver_interface&amp; get_resolver() = 0;

		typedef boost::function&lt;void(error_code const&amp;, std::vector&lt;address&gt; const&amp;)&gt;
			callback_t;

<div style="background: #ffff00" width="100%">		virtual void async_resolve(std::string const&amp; host, int flags
</div>			, callback_t const&amp; h) = 0;

		virtual bool has_connection(peer_connection* p) const = 0;
		virtual void insert_peer(boost::shared_ptr&lt;peer_connection&gt; const&amp; c) = 0;
		
		virtual void queue_async_resume_data(boost::shared_ptr&lt;torrent&gt; const&amp; t) = 0;
		virtual void done_async_resume() = 0;
		virtual void evict_torrent(torrent* t) = 0;

		virtual void remove_torrent(torrent_handle const&amp; h, int options = 0) = 0;
		virtual void remove_torrent_impl(boost::shared_ptr&lt;torrent&gt; tptr, int options) = 0;

		// ip and port filter
		virtual ip_filter&amp; get_ip_filter() = 0;
		virtual port_filter const&amp; get_port_filter() const = 0;

		virtual boost::int64_t session_time() const = 0;
	
		virtual bool is_paused() const = 0;
		virtual bool is_aborted() const = 0;
		virtual int num_uploads() const = 0;
		virtual bool preemptive_unchoke() const = 0;
		virtual void trigger_optimistic_unchoke() = 0;
		virtual void trigger_unchoke() = 0;

		virtual boost::weak_ptr&lt;torrent&gt; find_torrent(sha1_hash const&amp; info_hash) const = 0;
		virtual boost::weak_ptr&lt;torrent&gt; find_disconnect_candidate_torrent() const = 0;
		virtual boost::shared_ptr&lt;torrent&gt; delay_load_torrent(sha1_hash const&amp; info_hash
			, peer_connection* pc) = 0;
		virtual void insert_torrent(sha1_hash const&amp; ih, boost::shared_ptr&lt;torrent&gt; const&amp; t
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(55)">../include/libtorrent/aux_/session_interface.hpp:226</a></td><td>factor out the thread pool for socket jobs into a separate class used to (potentially) issue socket write calls onto multiple threads</td></tr><tr id="55" style="display: none;" colspan="3"><td colspan="3"><h2>factor out the thread pool for socket jobs into a separate
class
used to (potentially) issue socket write calls onto multiple threads</h2><h4>../include/libtorrent/aux_/session_interface.hpp:226</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		virtual int num_torrents() const = 0;

		virtual peer_id const&amp; get_peer_id() const = 0;

		// cork a peer and schedule a delayed uncork
		// does nothing if the peer is already corked
		virtual void cork_burst(peer_connection* p) = 0;

		virtual void close_connection(peer_connection* p, error_code const&amp; ec) = 0;
		virtual int num_connections() const = 0;

		virtual char* allocate_buffer() = 0;
		virtual void free_buffer(char* buf) = 0;
		virtual int send_buffer_size() const = 0;

		virtual void deferred_submit_jobs() = 0;

		virtual boost::uint16_t listen_port() const = 0;
		virtual boost::uint16_t ssl_listen_port() const = 0;

<div style="background: #ffff00" width="100%">		virtual void post_socket_job(socket_job&amp; j) = 0;
</div>
		// load the specified torrent. also evict one torrent, except
		// for the one specified, if we are at the limit of loaded torrents
		virtual bool load_torrent(torrent* t) = 0;

		// bump the specified torrent to make it the most recently used one
		// in the torrent LRU (i.e. the least likely to get unloaded)
		virtual void bump_torrent(torrent* t, bool back = true) = 0;

		// ask for which interface and port to bind outgoing peer connections on
		virtual tcp::endpoint bind_outgoing_socket(socket_type&amp; s, address const&amp;
			remote_address, error_code&amp; ec) const = 0;
		virtual bool verify_bound_address(address const&amp; addr, bool utp
			, error_code&amp; ec) = 0;

#ifndef TORRENT_DISABLE_MUTABLE_TORRENTS
		virtual std::vector&lt;boost::shared_ptr&lt;torrent&gt; &gt; find_collection(
			std::string const&amp; collection) const = 0;
#endif

</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(56)">../src/disk_io_thread.cpp:206</a></td><td>it would be nice to have the number of threads be set dynamically</td></tr><tr id="56" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to have the number of threads be set dynamically</h2><h4>../src/disk_io_thread.cpp:206</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		std::pair&lt;block_cache::iterator, block_cache::iterator&gt; pieces
			= m_disk_cache.all_pieces();
		TORRENT_ASSERT(pieces.first == pieces.second);
#endif

#ifdef TORRENT_DISK_STATS
		if (g_access_log)
		{
			FILE* f = g_access_log;
			g_access_log = NULL;
			fclose(f);
		}
#endif

		TORRENT_ASSERT(m_magic == 0x1337);
#if TORRENT_USE_ASSERTS
		m_magic = 0xdead;
#endif
	}

<div style="background: #ffff00" width="100%">	void disk_io_thread::set_num_threads(int i, bool wait)
</div>	{
		TORRENT_ASSERT(m_magic == 0x1337);
		if (i == m_num_threads) return;

		if (i &gt; m_num_threads)
		{
			while (m_num_threads &lt; i)
			{
				int thread_id = (++m_num_threads) - 1;
				thread_type_t type = generic_thread;

				// the magic number 3 is also used in add_job()
				// every 4:th thread is a hasher thread
				if ((thread_id &amp; 0x3) == 3) type = hasher_thread;
				m_threads.push_back(boost::shared_ptr&lt;thread&gt;(
					new thread(boost::bind(&amp;disk_io_thread::thread_fun, this, thread_id, type))));
			}
		}
		else
		{
			while (m_num_threads &gt; i) { --m_num_threads; }
			mutex::scoped_lock l(m_job_mutex);
			m_job_cond.notify_all();
			m_hash_job_cond.notify_all();
			l.unlock();
			if (wait) for (int i = m_num_threads; i &lt; m_threads.size(); ++i) m_threads[i]-&gt;join();
			// this will detach the threads
			m_threads.resize(m_num_threads);
		}
	}
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(57)">../src/http_seed_connection.cpp:123</a></td><td>in chunked encoding mode, this assert won't hold. the chunk headers should be subtracted from the receive_buffer_size</td></tr><tr id="57" style="display: none;" colspan="3"><td colspan="3"><h2>in chunked encoding mode, this assert won't hold.
the chunk headers should be subtracted from the receive_buffer_size</h2><h4>../src/http_seed_connection.cpp:123</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	boost::optional&lt;piece_block_progress&gt;
	http_seed_connection::downloading_piece_progress() const
	{
		if (m_requests.empty())
			return boost::optional&lt;piece_block_progress&gt;();

		boost::shared_ptr&lt;torrent&gt; t = associated_torrent().lock();
		TORRENT_ASSERT(t);

		piece_block_progress ret;

		peer_request const&amp; pr = m_requests.front();
		ret.piece_index = pr.piece;
		if (!m_parser.header_finished())
		{
			ret.bytes_downloaded = 0;
		}
		else
		{
			int receive_buffer_size = m_recv_buffer.get().left() - m_parser.body_start();
<div style="background: #ffff00" width="100%">			TORRENT_ASSERT_VAL(receive_buffer_size &lt;= t-&gt;block_size(), receive_buffer_size);
</div>			ret.bytes_downloaded = t-&gt;block_size() - receive_buffer_size;
		}
		// this is used to make sure that the block_index stays within
		// bounds. If the entire piece is downloaded, the block_index
		// would otherwise point to one past the end
		int correction = ret.bytes_downloaded ? -1 : 0;
		ret.block_index = (pr.start + ret.bytes_downloaded + correction) / t-&gt;block_size();
		ret.full_block_bytes = t-&gt;block_size();
		const int last_piece = t-&gt;torrent_file().num_pieces() - 1;
		if (ret.piece_index == last_piece &amp;&amp; ret.block_index
			== t-&gt;torrent_file().piece_size(last_piece) / t-&gt;block_size())
			ret.full_block_bytes = t-&gt;torrent_file().piece_size(last_piece) % t-&gt;block_size();
		return ret;
	}

	void http_seed_connection::write_request(peer_request const&amp; r)
	{
		INVARIANT_CHECK;

		boost::shared_ptr&lt;torrent&gt; t = associated_torrent().lock();
		TORRENT_ASSERT(t);

		TORRENT_ASSERT(t-&gt;valid_metadata());
		// http_seeds don't support requesting more than one piece
		// at a time
		TORRENT_ASSERT(r.length &lt;= t-&gt;torrent_file().piece_size(r.piece));

		std::string request;
		request.reserve(400);

</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(58)">../src/session_impl.cpp:5227</a></td><td>report the proper address of the router as the source IP of this understanding of our external address, instead of the empty address</td></tr><tr id="58" style="display: none;" colspan="3"><td colspan="3"><h2>report the proper address of the router as the source IP of
this understanding of our external address, instead of the empty address</h2><h4>../src/session_impl.cpp:5227</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	void session_impl::on_port_mapping(int mapping, address const&amp; ip, int port
		, error_code const&amp; ec, int map_transport)
	{
		TORRENT_ASSERT(is_single_thread());

		TORRENT_ASSERT(map_transport &gt;= 0 &amp;&amp; map_transport &lt;= 1);

		if (mapping == m_udp_mapping[map_transport] &amp;&amp; port != 0)
		{
			m_external_udp_port = port;
			if (m_alerts.should_post&lt;portmap_alert&gt;())
				m_alerts.emplace_alert&lt;portmap_alert&gt;(mapping, port
					, map_transport);
			return;
		}

		if (mapping == m_tcp_mapping[map_transport] &amp;&amp; port != 0)
		{
			if (ip != address())
			{
<div style="background: #ffff00" width="100%">				set_external_address(ip, source_router, address());
</div>			}

			if (!m_listen_sockets.empty()) {
				m_listen_sockets.front().external_address = ip;
				m_listen_sockets.front().external_port = port;
			}
			if (m_alerts.should_post&lt;portmap_alert&gt;())
				m_alerts.emplace_alert&lt;portmap_alert&gt;(mapping, port
					, map_transport);
			return;
		}

		if (ec)
		{
			if (m_alerts.should_post&lt;portmap_error_alert&gt;())
				m_alerts.emplace_alert&lt;portmap_error_alert&gt;(mapping
					, map_transport, ec);
		}
		else
		{
			if (m_alerts.should_post&lt;portmap_alert&gt;())
				m_alerts.emplace_alert&lt;portmap_alert&gt;(mapping, port
					, map_transport);
		}
	}

#ifndef TORRENT_NO_DEPRECATE
	session_status session_impl::status() const
	{
//		INVARIANT_CHECK;
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(59)">../src/session_impl.cpp:6497</a></td><td>we only need to do this if our global IPv4 address has changed since the DHT (currently) only supports IPv4. Since restarting the DHT is kind of expensive, it would be nice to not do it unnecessarily</td></tr><tr id="59" style="display: none;" colspan="3"><td colspan="3"><h2>we only need to do this if our global IPv4 address has changed
since the DHT (currently) only supports IPv4. Since restarting the DHT
is kind of expensive, it would be nice to not do it unnecessarily</h2><h4>../src/session_impl.cpp:6497</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#endif

		if (!m_external_ip.cast_vote(ip, source_type, source)) return;

#ifndef TORRENT_DISABLE_LOGGING
		session_log("  external IP updated");
#endif

		if (m_alerts.should_post&lt;external_ip_alert&gt;())
			m_alerts.emplace_alert&lt;external_ip_alert&gt;(ip);

		for (torrent_map::iterator i = m_torrents.begin()
			, end(m_torrents.end()); i != end; ++i)
		{
			i-&gt;second-&gt;new_external_ip();
		}

		// since we have a new external IP now, we need to
		// restart the DHT with a new node ID
#ifndef TORRENT_DISABLE_DHT
<div style="background: #ffff00" width="100%">		if (m_dht)
</div>		{
			entry s = m_dht-&gt;state();
			int cur_state = 0;
			int prev_state = 0;
			entry* nodes1 = s.find_key("nodes");
			if (nodes1 &amp;&amp; nodes1-&gt;type() == entry::list_t) cur_state = nodes1-&gt;list().size();
			entry* nodes2 = m_dht_state.find_key("nodes");
			if (nodes2 &amp;&amp; nodes2-&gt;type() == entry::list_t) prev_state = nodes2-&gt;list().size();
			if (cur_state &gt; prev_state) m_dht_state = s;
			start_dht(m_dht_state);
		}
#endif
	}

	// decrement the refcount of the block in the disk cache
	// since the network thread doesn't need it anymore
	void session_impl::reclaim_block(block_cache_reference ref)
	{
		m_disk_thread.reclaim_block(ref);
	}

	char* session_impl::allocate_disk_buffer(char const* category)
	{
		return m_disk_thread.allocate_disk_buffer(category);
	}

	char* session_impl::async_allocate_disk_buffer(char const* category
		, boost::function&lt;void(char*)&gt; const&amp; handler)
	{
		return m_disk_thread.async_allocate_disk_buffer(category, handler);
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(60)">../src/torrent.cpp:1168</a></td><td>make this depend on the error and on the filesystem the files are being downloaded to. If the error is no_space_left_on_device and the filesystem doesn't support sparse files, only zero the priorities of the pieces that are at the tails of all files, leaving everything up to the highest written piece in each file</td></tr><tr id="60" style="display: none;" colspan="3"><td colspan="3"><h2>make this depend on the error and on the filesystem the
files are being downloaded to. If the error is no_space_left_on_device
and the filesystem doesn't support sparse files, only zero the priorities
of the pieces that are at the tails of all files, leaving everything
up to the highest written piece in each file</h2><h4>../src/torrent.cpp:1168</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			alerts().emplace_alert&lt;file_error_alert&gt;(j-&gt;error.ec
				, resolve_filename(j-&gt;error.file), j-&gt;error.operation_str(), get_handle());

		// put the torrent in an error-state
		set_error(j-&gt;error.ec, j-&gt;error.file);

		// if a write operation failed, and future writes are likely to
		// fail, while reads may succeed, just set the torrent to upload mode
		// if we make an incorrect assumption here, it's not the end of the
		// world, if we ever issue a read request and it fails as well, we
		// won't get in here and we'll actually end up pausing the torrent
		if (j-&gt;action == disk_io_job::write
			&amp;&amp; (j-&gt;error.ec == boost::system::errc::read_only_file_system
			|| j-&gt;error.ec == boost::system::errc::permission_denied
			|| j-&gt;error.ec == boost::system::errc::operation_not_permitted
			|| j-&gt;error.ec == boost::system::errc::no_space_on_device
			|| j-&gt;error.ec == boost::system::errc::file_too_large))
		{
			// if we failed to write, stop downloading and just
			// keep seeding.
<div style="background: #ffff00" width="100%">			set_upload_mode(true);
</div>			return;
		}

		// if the error appears to be more serious than a full disk, just pause the torrent
		pause();
	}

	void torrent::on_piece_fail_sync(disk_io_job const* j, piece_block b)
	{
		TORRENT_UNUSED(j);
		TORRENT_UNUSED(b);

		update_gauge();
		// some peers that previously was no longer interesting may
		// now have become interesting, since we lack this one piece now.
		for (peer_iterator i = begin(); i != end();)
		{
			peer_connection* p = *i;
			// update_interest may disconnect the peer and
			// invalidate the iterator
			++i;
			// no need to do anything with peers that
			// already are interested. Gaining a piece may
			// only make uninteresting peers interesting again.
			if (p-&gt;is_interesting()) continue;
			p-&gt;update_interest();
			if (!m_abort)
			{
				if (request_a_block(*this, *p))
					inc_stats_counter(counters::hash_fail_piece_picks);
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(61)">../src/torrent.cpp:6956</a></td><td>save the send_stats state instead of throwing them away it may pose an issue when downgrading though</td></tr><tr id="61" style="display: none;" colspan="3"><td colspan="3"><h2>save the send_stats state instead of throwing them away
it may pose an issue when downgrading though</h2><h4>../src/torrent.cpp:6956</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">					for (int k = 0; k &lt; bits; ++k)
						v |= (info[j*8+k].state == piece_picker::block_info::state_finished)
						? (1 &lt;&lt; k) : 0;
					bitmask.append(1, v);
					TORRENT_ASSERT(bits == 8 || j == num_bitmask_bytes - 1);
				}
				piece_struct["bitmask"] = bitmask;
				// push the struct onto the unfinished-piece list
				up.push_back(piece_struct);
			}
		}

		// save trackers
		entry::list_type&amp; tr_list = ret["trackers"].list();
		tr_list.push_back(entry::list_type());
		int tier = 0;
		for (std::vector&lt;announce_entry&gt;::const_iterator i = m_trackers.begin()
			, end(m_trackers.end()); i != end; ++i)
		{
			// don't save trackers we can't trust
<div style="background: #ffff00" width="100%">			if (i-&gt;send_stats == false) continue;
</div>			if (i-&gt;tier == tier)
			{
				tr_list.back().list().push_back(i-&gt;url);
			}
			else
			{
				tr_list.push_back(entry::list_t);
				tr_list.back().list().push_back(i-&gt;url);
				tier = i-&gt;tier;
			}
		}

		// save web seeds
		if (!m_web_seeds.empty())
		{
			entry::list_type&amp; url_list = ret["url-list"].list();
			entry::list_type&amp; httpseed_list = ret["httpseeds"].list();
			for (std::list&lt;web_seed_t&gt;::const_iterator i = m_web_seeds.begin()
				, end(m_web_seeds.end()); i != end; ++i)
			{
				if (i-&gt;type == web_seed_entry::url_seed)
					url_list.push_back(i-&gt;url);
				else if (i-&gt;type == web_seed_entry::http_seed)
					httpseed_list.push_back(i-&gt;url);
			}
		}

		// write have bitmask
		// the pieces string has one byte per piece. Each
		// byte is a bitmask representing different properties
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(62)">../src/torrent.cpp:8057</a></td><td>should disconnect all peers that have the pieces we have not just seeds. It would be pretty expensive to check all pieces for all peers though</td></tr><tr id="62" style="display: none;" colspan="3"><td colspan="3"><h2>should disconnect all peers that have the pieces we have
not just seeds. It would be pretty expensive to check all pieces
for all peers though</h2><h4>../src/torrent.cpp:8057</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		set_state(torrent_status::finished);
		set_queue_position(-1);

		m_became_finished = m_ses.session_time();

		// we have to call completed() before we start
		// disconnecting peers, since there's an assert
		// to make sure we're cleared the piece picker
		if (is_seed()) completed();

		send_upload_only();

		state_updated();

		if (m_completed_time == 0)
			m_completed_time = time(0);

		// disconnect all seeds
		if (settings().get_bool(settings_pack::close_redundant_connections))
		{
<div style="background: #ffff00" width="100%">			std::vector&lt;peer_connection*&gt; seeds;
</div>			for (peer_iterator i = m_connections.begin();
				i != m_connections.end(); ++i)
			{
				peer_connection* p = *i;
				TORRENT_ASSERT(p-&gt;associated_torrent().lock().get() == this);
				if (p-&gt;upload_only())
				{
#ifndef TORRENT_DISABLE_LOGGING
					p-&gt;peer_log(peer_log_alert::info, "SEED", "CLOSING CONNECTION");
#endif
					seeds.push_back(p);
				}
			}
			std::for_each(seeds.begin(), seeds.end()
				, boost::bind(&amp;peer_connection::disconnect, _1, errors::torrent_finished
				, op_bittorrent, 0));
		}

		if (m_abort) return;

		update_want_peers();

		TORRENT_ASSERT(m_storage);

		// we need to keep the object alive during this operation
		inc_refcount("release_files");
		m_ses.disk_thread().async_release_files(m_storage.get()
			, boost::bind(&amp;torrent::on_cache_flushed, shared_from_this(), _1));
		
		// this torrent just completed downloads, which means it will fall
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(63)">../include/libtorrent/ip_voter.hpp:124</a></td><td>instead, have one instance per possible subnet, global IPv4, global IPv6, loopback, 192.168.x.x, 10.x.x.x, etc.</td></tr><tr id="63" style="display: none;" colspan="3"><td colspan="3"><h2>instead, have one instance per possible subnet, global IPv4, global IPv6, loopback, 192.168.x.x, 10.x.x.x, etc.</h2><h4>../include/libtorrent/ip_voter.hpp:124</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// away all the votes and started from scratch, in case
		// our IP has changed
		time_point m_last_rotate;
	};

	// this keeps track of multiple external IPs (for now, just IPv6 and IPv4, but
	// it could be extended to deal with loopback and local network addresses as well)
	struct TORRENT_EXTRA_EXPORT external_ip
	{
		// returns true if a different IP is the top vote now
		// i.e. we changed our idea of what our external IP is
		bool cast_vote(address const&amp; ip, int source_type, address const&amp; source);

		// the external IP as it would be observed from `ip`
		address external_address(address const&amp; ip) const;

	private:

		// for now, assume one external IPv4 and one external IPv6 address
		// 0 = IPv4 1 = IPv6
<div style="background: #ffff00" width="100%">		ip_voter m_vote_group[2];
</div>	};

}

#endif

</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(64)">../include/libtorrent/web_peer_connection.hpp:120</a></td><td>if we make this be a disk_buffer_holder instead we would save a copy sometimes use allocate_disk_receive_buffer and release_disk_receive_buffer</td></tr><tr id="64" style="display: none;" colspan="3"><td colspan="3"><h2>if we make this be a disk_buffer_holder instead
we would save a copy sometimes
use allocate_disk_receive_buffer and release_disk_receive_buffer</h2><h4>../include/libtorrent/web_peer_connection.hpp:120</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// returns the block currently being
		// downloaded. And the progress of that
		// block. If the peer isn't downloading
		// a piece for the moment, the boost::optional
		// will be invalid.
		boost::optional&lt;piece_block_progress&gt; downloading_piece_progress() const TORRENT_OVERRIDE;

		void handle_padfile(buffer::const_interval&amp; recv_buffer);

		// this has one entry per http-request
		// (might be more than the bt requests)
		std::deque&lt;int&gt; m_file_requests;

		std::string m_url;
	
		web_seed_t* m_web;
			
		// this is used for intermediate storage of pieces
		// that are received in more than one HTTP response
<div style="background: #ffff00" width="100%">		std::vector&lt;char&gt; m_piece;
</div>		
		// the number of bytes received in the current HTTP
		// response. used to know where in the buffer the
		// next response starts
		boost::int64_t m_received_body;

		// position in the current range response
		boost::int64_t m_range_pos;

		// this is the offset inside the current receive
		// buffer where the next chunk header will be.
		// this is updated for each chunk header that's
		// parsed. It does not necessarily point to a valid
		// offset in the receive buffer, if we haven't received
		// it yet. This offset never includes the HTTP header
		boost::int64_t m_chunk_pos;

		// the position in the current block
		int m_block_pos;

		// this is the number of bytes we've already received
		// from the next chunk header we're waiting for
		int m_partial_chunk_header;

		// the number of responses we've received so far on
		// this connection
		int m_num_responses;
	};
}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(65)">../test/test_block_cache.cpp:469</a></td><td>test try_evict_blocks</td></tr><tr id="65" style="display: none;" colspan="3"><td colspan="3"><h2>test try_evict_blocks</h2><h4>../test/test_block_cache.cpp:469</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(66)">../test/test_block_cache.cpp:470</a></td><td>test evicting volatile pieces, to see them be removed</td></tr><tr id="66" style="display: none;" colspan="3"><td colspan="3"><h2>test evicting volatile pieces, to see them be removed</h2><h4>../test/test_block_cache.cpp:470</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(67)">../test/test_block_cache.cpp:471</a></td><td>test evicting dirty pieces</td></tr><tr id="67" style="display: none;" colspan="3"><td colspan="3"><h2>test evicting dirty pieces</h2><h4>../test/test_block_cache.cpp:471</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(68)">../test/test_block_cache.cpp:472</a></td><td>test free_piece</td></tr><tr id="68" style="display: none;" colspan="3"><td colspan="3"><h2>test free_piece</h2><h4>../test/test_block_cache.cpp:472</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(69)">../test/test_block_cache.cpp:473</a></td><td>test abort_dirty</td></tr><tr id="69" style="display: none;" colspan="3"><td colspan="3"><h2>test abort_dirty</h2><h4>../test/test_block_cache.cpp:473</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(70)">../test/test_block_cache.cpp:474</a></td><td>test unaligned reads</td></tr><tr id="70" style="display: none;" colspan="3"><td colspan="3"><h2>test unaligned reads</h2><h4>../test/test_block_cache.cpp:474</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// it's supposed to be a cache hit
	TEST_CHECK(ret &gt;= 0);
	// return the reference to the buffer we just read
	RETURN_BUFFER;

	tailqueue jobs;
	bc.clear(jobs);
}

int test_main()
{
	test_write();
	test_flush();
	test_insert();
	test_evict();
	test_arc_promote();
	test_arc_unghost();
	test_iovec();
	test_unaligned_read();

<div style="background: #ffff00" width="100%">	return 0;
</div>}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(71)">../test/test_dht.cpp:438</a></td><td>test obfuscated_get_peers</td></tr><tr id="71" style="display: none;" colspan="3"><td colspan="3"><h2>test obfuscated_get_peers</h2><h4>../test/test_dht.cpp:438</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	}
	return false;
}

struct obs : dht::dht_observer
{
	virtual void set_external_address(address const&amp; addr
		, address const&amp; source) TORRENT_OVERRIDE
	{}

	virtual address external_address() TORRENT_OVERRIDE
	{
		return address_v4::from_string("236.0.0.1");
	}
	virtual void get_peers(sha1_hash const&amp; ih) TORRENT_OVERRIDE {}
	virtual void outgoing_get_peers(sha1_hash const&amp; target
		, sha1_hash const&amp; sent_target, udp::endpoint const&amp; ep) TORRENT_OVERRIDE {}
	virtual void announce(sha1_hash const&amp; ih, address const&amp; addr, int port) TORRENT_OVERRIDE {}
};

<div style="background: #ffff00" width="100%">int test_main()
</div>{
	dht_settings sett;
	sett.max_torrents = 4;
	sett.max_dht_items = 4;
	sett.enforce_node_id = false;
	mock_socket s;
	obs observer;
	counters cnt;
	dht::node node(&amp;s, sett, node_id(0), &amp;observer, cnt);

	// DHT should be running on port 48199 now
	bdecode_node response;
	bdecode_node parsed[11];
	char error_string[200];
	bool ret;

	// ====== ping ======
	udp::endpoint source(address::from_string("10.0.0.1"), 20);
	send_dht_request(node, "ping", source, &amp;response, "10");

	dht::key_desc_t pong_desc[] = {
		{"y", bdecode_node::string_t, 1, 0},
		{"t", bdecode_node::string_t, 2, 0},
		{"r", bdecode_node::dict_t, 0, key_desc_t::parse_children},
			{"id", bdecode_node::string_t, 20, key_desc_t::last_child},
	};

	fprintf(stderr, "msg: %s\n", print_entry(response).c_str());
	ret = dht::verify_message(response, pong_desc, parsed, 4, error_string
		, sizeof(error_string));
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(72)">../test/test_file_storage.cpp:210</a></td><td>test file_storage::optimize too</td></tr><tr id="72" style="display: none;" colspan="3"><td colspan="3"><h2>test file_storage::optimize too</h2><h4>../test/test_file_storage.cpp:210</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(73)">../test/test_file_storage.cpp:211</a></td><td>test map_block</td></tr><tr id="73" style="display: none;" colspan="3"><td colspan="3"><h2>test map_block</h2><h4>../test/test_file_storage.cpp:211</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(74)">../test/test_file_storage.cpp:212</a></td><td>test piece_size(int piece)</td></tr><tr id="74" style="display: none;" colspan="3"><td colspan="3"><h2>test piece_size(int piece)</h2><h4>../test/test_file_storage.cpp:212</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(75)">../test/test_file_storage.cpp:213</a></td><td>test file_index_at_offset</td></tr><tr id="75" style="display: none;" colspan="3"><td colspan="3"><h2>test file_index_at_offset</h2><h4>../test/test_file_storage.cpp:213</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(76)">../test/test_file_storage.cpp:214</a></td><td>test file attributes</td></tr><tr id="76" style="display: none;" colspan="3"><td colspan="3"><h2>test file attributes</h2><h4>../test/test_file_storage.cpp:214</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(77)">../test/test_file_storage.cpp:215</a></td><td>test symlinks</td></tr><tr id="77" style="display: none;" colspan="3"><td colspan="3"><h2>test symlinks</h2><h4>../test/test_file_storage.cpp:215</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(78)">../test/test_file_storage.cpp:216</a></td><td>test pad_files</td></tr><tr id="78" style="display: none;" colspan="3"><td colspan="3"><h2>test pad_files</h2><h4>../test/test_file_storage.cpp:216</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(79)">../test/test_file_storage.cpp:217</a></td><td>test reorder_file (make sure internal_file_entry::swap() is used)</td></tr><tr id="79" style="display: none;" colspan="3"><td colspan="3"><h2>test reorder_file (make sure internal_file_entry::swap() is used)</h2><h4>../test/test_file_storage.cpp:217</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		TEST_EQUAL(rq.piece, 7);
		TEST_EQUAL(rq.start, 298);
		TEST_EQUAL(rq.length, 841);
	}

	{
		// test file_path_hash and path_hash. Make sure we can detect a path
		// whose name collides with
		file_storage fs;
		fs.set_piece_length(512);
		fs.add_file(combine_path("temp_storage", "Foo"), 17);
		fs.add_file(combine_path("temp_storage", "foo"), 612);

		fprintf(stderr, "path: %s\n", fs.file_path(0).c_str());
		fprintf(stderr, "file: %s\n", fs.file_path(1).c_str());
		boost::uint32_t file_hash0 = fs.file_path_hash(0, "a");
		boost::uint32_t file_hash1 = fs.file_path_hash(1, "a");
		TEST_EQUAL(file_hash0, file_hash1);
	}

<div style="background: #ffff00" width="100%">
</div>	return 0;
}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(80)">../test/test_metadata_extension.cpp:93</a></td><td>it would be nice to test reversing which session is making the connection as well</td></tr><tr id="80" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to test reversing
which session is making the connection as well</h2><h4>../test/test_metadata_extension.cpp:93</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	, int timeout)
{
	using namespace libtorrent;
	namespace lt = libtorrent;

	fprintf(stderr, "\n==== test transfer: timeout=%d %s%s%s%s%s%s ====\n\n"
		, timeout
		, (flags &amp; clear_files) ? "clear-files " : ""
		, (flags &amp; disconnect) ? "disconnect " : ""
		, (flags &amp; full_encryption) ? "encryption " : ""
		, (flags &amp; reverse) ? "reverse " : ""
		, (flags &amp; utp) ? "utp " : ""
		, (flags &amp; upload_only) ? "upload_only " : "");

	// these are declared before the session objects
	// so that they are destructed last. This enables
	// the sessions to destruct in parallel
	session_proxy p1;
	session_proxy p2;

<div style="background: #ffff00" width="100%">	lt::session ses1(fingerprint("LT", 0, 1, 0, 0), std::make_pair(48100, 49000), "0.0.0.0", 0);
</div>	lt::session ses2(fingerprint("LT", 0, 1, 0, 0), std::make_pair(49100, 50000), "0.0.0.0", 0);
	ses1.add_extension(constructor);
	ses2.add_extension(constructor);
	torrent_handle tor1;
	torrent_handle tor2;

	settings_pack pack;
	pack.set_int(settings_pack::out_enc_policy, settings_pack::pe_forced);
	pack.set_int(settings_pack::in_enc_policy, settings_pack::pe_forced);
	pack.set_bool(settings_pack::prefer_rc4, flags &amp; full_encryption);

	if (flags &amp; utp)
	{
		pack.set_bool(settings_pack::utp_dynamic_sock_buf, true);
		pack.set_bool(settings_pack::enable_incoming_utp, true);
		pack.set_bool(settings_pack::enable_outgoing_utp, true);
		pack.set_bool(settings_pack::enable_incoming_tcp, false);
		pack.set_bool(settings_pack::enable_outgoing_tcp, false);
	}
	else
	{
		pack.set_bool(settings_pack::enable_incoming_utp, false);
		pack.set_bool(settings_pack::enable_outgoing_utp, false);
		pack.set_bool(settings_pack::enable_incoming_tcp, true);
		pack.set_bool(settings_pack::enable_outgoing_tcp, true);
	}

	ses1.apply_settings(pack);
	ses2.apply_settings(pack);

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(81)">../test/test_peer_list.cpp:921</a></td><td>test erasing peers</td></tr><tr id="81" style="display: none;" colspan="3"><td colspan="3"><h2>test erasing peers</h2><h4>../test/test_peer_list.cpp:921</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(82)">../test/test_peer_list.cpp:922</a></td><td>test update_peer_port with allow_multiple_connections_per_ip and without</td></tr><tr id="82" style="display: none;" colspan="3"><td colspan="3"><h2>test update_peer_port with allow_multiple_connections_per_ip and without</h2><h4>../test/test_peer_list.cpp:922</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(83)">../test/test_peer_list.cpp:923</a></td><td>test add i2p peers</td></tr><tr id="83" style="display: none;" colspan="3"><td colspan="3"><h2>test add i2p peers</h2><h4>../test/test_peer_list.cpp:923</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(84)">../test/test_peer_list.cpp:924</a></td><td>test allow_i2p_mixed</td></tr><tr id="84" style="display: none;" colspan="3"><td colspan="3"><h2>test allow_i2p_mixed</h2><h4>../test/test_peer_list.cpp:924</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(85)">../test/test_peer_list.cpp:925</a></td><td>test insert_peer failing with all error conditions</td></tr><tr id="85" style="display: none;" colspan="3"><td colspan="3"><h2>test insert_peer failing with all error conditions</h2><h4>../test/test_peer_list.cpp:925</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(86)">../test/test_peer_list.cpp:926</a></td><td>test IPv6</td></tr><tr id="86" style="display: none;" colspan="3"><td colspan="3"><h2>test IPv6</h2><h4>../test/test_peer_list.cpp:926</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(87)">../test/test_peer_list.cpp:927</a></td><td>test connect_to_peer() failing</td></tr><tr id="87" style="display: none;" colspan="3"><td colspan="3"><h2>test connect_to_peer() failing</h2><h4>../test/test_peer_list.cpp:927</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(88)">../test/test_peer_list.cpp:928</a></td><td>test connection_closed</td></tr><tr id="88" style="display: none;" colspan="3"><td colspan="3"><h2>test connection_closed</h2><h4>../test/test_peer_list.cpp:928</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(89)">../test/test_peer_list.cpp:929</a></td><td>connect candidates recalculation when incrementing failcount</td></tr><tr id="89" style="display: none;" colspan="3"><td colspan="3"><h2>connect candidates recalculation when incrementing failcount</h2><h4>../test/test_peer_list.cpp:929</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		torrent_peer* peer4 = add_peer(p, st, ep("10.0.0.4", 8080));
		TEST_CHECK(peer4);
		TEST_EQUAL(p.num_peers(), 4);
		torrent_peer* peer5 = add_peer(p, st, ep("10.0.0.5", 8080));
		TEST_CHECK(peer5);
		TEST_EQUAL(p.num_peers(), 5);
		torrent_peer* peer6 = p.add_peer(ep("10.0.0.6", 8080), 0, 0, &amp;st);
		TEST_CHECK(peer6 == NULL);
		TEST_EQUAL(p.num_peers(), 5);

		// one of the connection should have been removed
		TEST_EQUAL(has_peer(p, ep("10.0.0.1", 8080))
			+ has_peer(p, ep("10.0.0.2", 8080))
			+ has_peer(p, ep("10.0.0.3", 8080))
			+ has_peer(p, ep("10.0.0.4", 8080))
			+ has_peer(p, ep("10.0.0.5", 8080))
			+ has_peer(p, ep("10.0.0.6", 8080))
			, 5);
	}

<div style="background: #ffff00" width="100%">
</div>	return 0;
}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(90)">../test/test_primitives.cpp:212</a></td><td>test the case where we have > 120 samples (and have the base delay actually be updated)</td></tr><tr id="90" style="display: none;" colspan="3"><td colspan="3"><h2>test the case where we have > 120 samples (and have the base delay actually be updated)</h2><h4>../test/test_primitives.cpp:212</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(91)">../test/test_primitives.cpp:213</a></td><td>test the case where a sample is lower than the history entry but not lower than the base</td></tr><tr id="91" style="display: none;" colspan="3"><td colspan="3"><h2>test the case where a sample is lower than the history entry but not lower than the base</h2><h4>../test/test_primitives.cpp:213</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	TEST_CHECK(!filter.find(k3));
	TEST_CHECK(filter.find(k4));

	// test timestamp_history
	{
		timestamp_history h;
		TEST_EQUAL(h.add_sample(0x32, false), 0);
		TEST_EQUAL(h.base(), 0x32);
		TEST_EQUAL(h.add_sample(0x33, false), 0x1);
		TEST_EQUAL(h.base(), 0x32);
		TEST_EQUAL(h.add_sample(0x3433, false), 0x3401);
		TEST_EQUAL(h.base(), 0x32);
		TEST_EQUAL(h.add_sample(0x30, false), 0);
		TEST_EQUAL(h.base(), 0x30);

		// test that wrapping of the timestamp is properly handled
		h.add_sample(0xfffffff3, false);
		TEST_EQUAL(h.base(), 0xfffffff3);


<div style="background: #ffff00" width="100%">	}
</div>
	// test error codes
	TEST_CHECK(error_code(errors::http_error).message() == "HTTP error");
	TEST_CHECK(error_code(errors::missing_file_sizes).message() == "missing or invalid 'file sizes' entry");
	TEST_CHECK(error_code(errors::unsupported_protocol_version).message() == "unsupported protocol version");
	TEST_CHECK(error_code(errors::no_i2p_router).message() == "no i2p router is set up");
	TEST_CHECK(error_code(errors::http_parse_error).message() == "Invalid HTTP header");
	TEST_CHECK(error_code(errors::error_code_max).message() == "Unknown error");

	TEST_CHECK(error_code(errors::unauthorized, get_http_category()).message() == "401 Unauthorized");
	TEST_CHECK(error_code(errors::service_unavailable, get_http_category()).message() == "503 Service Unavailable");

	// test snprintf

	char msg[10];
	snprintf(msg, sizeof(msg), "too %s format string", "long");
	TEST_CHECK(strcmp(msg, "too long ") == 0);

	std::string path;
	sanitize_append_path_element(path, "a...", 4);
	TEST_EQUAL(path, "a");

	path.clear();
	sanitize_append_path_element(path, "a   ", 4);
	TEST_EQUAL(path, "a");

	path.clear();
	sanitize_append_path_element(path, "a...b", 5);
	TEST_EQUAL(path, "a...b");

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(92)">../test/test_resolve_links.cpp:80</a></td><td>test files with different piece size (negative test)</td></tr><tr id="92" style="display: none;" colspan="3"><td colspan="3"><h2>test files with different piece size (negative test)</h2><h4>../test/test_resolve_links.cpp:80</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{ "test2", "test1_pad_files", 0},
	{ "test3", "test1_pad_files", 0},
	{ "test2", "test1_single", 0},

	// these are all padded. The first small file will accidentally also
	// match, even though it's not tail padded, the following file is identical
	{ "test2_pad_files", "test1_pad_files", 2},
	{ "test3_pad_files", "test1_pad_files", 2},
	{ "test3_pad_files", "test2_pad_files", 2},
	{ "test1_pad_files", "test2_pad_files", 2},
	{ "test1_pad_files", "test3_pad_files", 2},
	{ "test2_pad_files", "test3_pad_files", 2},

	// one might expect this to work, but since the tail of the single file
	// torrent is not padded, the last piece hash won't match
	{ "test1_pad_files", "test1_single", 0},

	// if it's padded on the other hand, it will work
	{ "test1_pad_files", "test1_single_padded", 1},

<div style="background: #ffff00" width="100%">};
</div>
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(93)">../test/test_resolve_links.cpp:83</a></td><td>it would be nice to test resolving of more than just 2 files as well. like 3 single file torrents merged into one, resolving all 3 files.</td></tr><tr id="93" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to test resolving of more than just 2 files as well.
like 3 single file torrents merged into one, resolving all 3 files.</h2><h4>../test/test_resolve_links.cpp:83</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{ "test2", "test1_single", 0},

	// these are all padded. The first small file will accidentally also
	// match, even though it's not tail padded, the following file is identical
	{ "test2_pad_files", "test1_pad_files", 2},
	{ "test3_pad_files", "test1_pad_files", 2},
	{ "test3_pad_files", "test2_pad_files", 2},
	{ "test1_pad_files", "test2_pad_files", 2},
	{ "test1_pad_files", "test3_pad_files", 2},
	{ "test2_pad_files", "test3_pad_files", 2},

	// one might expect this to work, but since the tail of the single file
	// torrent is not padded, the last piece hash won't match
	{ "test1_pad_files", "test1_single", 0},

	// if it's padded on the other hand, it will work
	{ "test1_pad_files", "test1_single_padded", 1},

};

<div style="background: #ffff00" width="100%">
</div>int test_main()
{

#ifndef TORRENT_DISABLE_MUTABLE_TORRENTS
	std::string path = combine_path(parent_path(current_working_directory())
		, "mutable_test_torrents");

	for (int i = 0; i &lt; sizeof(test_torrents)/sizeof(test_torrents[0]); ++i)
	{
		test_torrent_t const&amp; e = test_torrents[i];

		std::string p = combine_path(path, e.filename1) + ".torrent";
		fprintf(stderr, "loading %s\n", p.c_str());
		boost::shared_ptr&lt;torrent_info&gt; ti1 = boost::make_shared&lt;torrent_info&gt;(p);

		p = combine_path(path, e.filename2) + ".torrent";
		fprintf(stderr, "loading %s\n", p.c_str());
		boost::shared_ptr&lt;torrent_info&gt; ti2 = boost::make_shared&lt;torrent_info&gt;(p);

		fprintf(stderr, "resolving\n");
		resolve_links l(ti1);
		l.match(ti2, ".");

		std::vector&lt;resolve_links::link_t&gt; const&amp; links = l.get_links();

		int num_matches = std::count_if(links.begin(), links.end()
			, boost::bind(&amp;resolve_links::link_t::ti, _1));

		// some debug output in case the test fails
		if (num_matches &gt; e.expected_matches)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(94)">../test/test_resume.cpp:340</a></td><td>test all other resume flags here too. This would require returning more than just the torrent_status from test_resume_flags. Also http seeds and trackers for instance</td></tr><tr id="94" style="display: none;" colspan="3"><td colspan="3"><h2>test all other resume flags here too. This would require returning
more than just the torrent_status from test_resume_flags. Also http seeds
and trackers for instance</h2><h4>../test/test_resume.cpp:340</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// resume data overrides the paused flag
	fprintf(stderr, "flags: paused\n");
	s = test_resume_flags(add_torrent_params::flag_paused);
	default_tests(s);
#ifdef TORRENT_WINDOWS
	TEST_EQUAL(s.save_path, "c:\\add_torrent_params save_path");
#else
	TEST_EQUAL(s.save_path, "/add_torrent_params save_path");
#endif
	TEST_EQUAL(s.sequential_download, false);
	TEST_EQUAL(s.paused, false);
	TEST_EQUAL(s.auto_managed, false);
	TEST_EQUAL(s.seed_mode, false);
	TEST_EQUAL(s.super_seeding, false);
	TEST_EQUAL(s.share_mode, false);
	TEST_EQUAL(s.upload_mode, false);
	TEST_EQUAL(s.ip_filter_applies, false);
	TEST_EQUAL(s.connections_limit, 1345);
	TEST_EQUAL(s.uploads_limit, 1346);

<div style="background: #ffff00" width="100%">	return 0;
</div>}


</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(95)">../test/test_ssl.cpp:377</a></td><td>test using a signed certificate with the wrong info-hash in DN</td></tr><tr id="95" style="display: none;" colspan="3"><td colspan="3"><h2>test using a signed certificate with the wrong info-hash in DN</h2><h4>../test/test_ssl.cpp:377</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// in verifying peers
	ctx.set_verify_mode(context::verify_none, ec);
	if (ec)
	{
		fprintf(stderr, "Failed to set SSL verify mode: %s\n"
			, ec.message().c_str());
		TEST_CHECK(!ec);
		return false;
	}

	std::string certificate = combine_path("..", combine_path("ssl", "peer_certificate.pem"));
	std::string private_key = combine_path("..", combine_path("ssl", "peer_private_key.pem"));
	std::string dh_params = combine_path("..", combine_path("ssl", "dhparams.pem"));

	if (flags &amp; invalid_certificate)
	{
		certificate = combine_path("..", combine_path("ssl", "invalid_peer_certificate.pem"));
		private_key = combine_path("..", combine_path("ssl", "invalid_peer_private_key.pem"));
	}

<div style="background: #ffff00" width="100%">
</div>	if (flags &amp; (valid_certificate | invalid_certificate))
	{
		fprintf(stderr, "set_password_callback\n");
		ctx.set_password_callback(boost::bind(&amp;password_callback, _1, _2, "test"), ec);
		if (ec)
		{
			fprintf(stderr, "Failed to set certificate password callback: %s\n"
				, ec.message().c_str());
			TEST_CHECK(!ec);
			return false;
		}
		fprintf(stderr, "use_certificate_file \"%s\"\n", certificate.c_str());
		ctx.use_certificate_file(certificate, context::pem, ec);
		if (ec)
		{
			fprintf(stderr, "Failed to set certificate file: %s\n"
				, ec.message().c_str());
			TEST_CHECK(!ec);
			return false;
		}
		fprintf(stderr, "use_private_key_file \"%s\"\n", private_key.c_str());
		ctx.use_private_key_file(private_key, context::pem, ec);
		if (ec)
		{
			fprintf(stderr, "Failed to set private key: %s\n"
				, ec.message().c_str());
			TEST_CHECK(!ec);
			return false;
		}
		fprintf(stderr, "use_tmp_dh_file \"%s\"\n", dh_params.c_str());
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(96)">../test/test_ssl.cpp:475</a></td><td>also test using a hash that refers to a valid torrent but that differs from the SNI hash</td></tr><tr id="96" style="display: none;" colspan="3"><td colspan="3"><h2>also test using a hash that refers to a valid torrent
but that differs from the SNI hash</h2><h4>../test/test_ssl.cpp:475</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	print_alerts(ses1, "ses1", true, true, true, &amp;on_alert);
	if (ec)
	{
		fprintf(stderr, "Failed SSL handshake: %s\n"
			, ec.message().c_str());
		return false;
	}

	char handshake[] = "\x13" "BitTorrent protocol\0\0\0\0\0\0\0\x04"
		"                    " // space for info-hash
		"aaaaaaaaaaaaaaaaaaaa" // peer-id
		"\0\0\0\x01\x02"; // interested
	
	// fill in the info-hash
	if (flags &amp; valid_bittorrent_hash)
	{
		std::memcpy(handshake + 28, &amp;t-&gt;info_hash()[0], 20);
	}
	else
	{
<div style="background: #ffff00" width="100%">		std::generate(handshake + 28, handshake + 48, &amp;rand);
</div>	}

	// fill in the peer-id
	std::generate(handshake + 48, handshake + 68, &amp;rand);

	fprintf(stderr, "bittorrent handshake\n");
	boost::asio::write(ssl_sock, libtorrent::asio::buffer(handshake, (sizeof(handshake) - 1)), ec);
	print_alerts(ses1, "ses1", true, true, true, &amp;on_alert);
	if (ec)
	{
		fprintf(stderr, "failed to write bittorrent handshake: %s\n"
			, ec.message().c_str());
		return false;
	}
	
	char buf[68];
	fprintf(stderr, "read bittorrent handshake\n");
	boost::asio::read(ssl_sock, libtorrent::asio::buffer(buf, sizeof(buf)), ec);
	print_alerts(ses1, "ses1", true, true, true, &amp;on_alert);
	if (ec)
	{
		fprintf(stderr, "failed to read bittorrent handshake: %s\n"
			, ec.message().c_str());
		return false;
	}

	if (memcmp(buf, "\x13" "BitTorrent protocol", 20) != 0)
	{
		fprintf(stderr, "invalid bittorrent handshake\n");
		return false;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(97)">../test/test_torrent.cpp:133</a></td><td>wait for an alert rather than just waiting 10 seconds. This is kind of silly</td></tr><tr id="97" style="display: none;" colspan="3"><td colspan="3"><h2>wait for an alert rather than just waiting 10 seconds. This is kind of silly</h2><h4>../test/test_torrent.cpp:133</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			TEST_EQUAL(h.file_priorities().size(), info-&gt;num_files());
			TEST_EQUAL(h.file_priorities()[0], 0);
			if (info-&gt;num_files() &gt; 1)
				TEST_EQUAL(h.file_priorities()[1], 0);
			if (info-&gt;num_files() &gt; 2)
				TEST_EQUAL(h.file_priorities()[2], 1);
		}
	}

	if (info-&gt;num_pieces() &gt; 0)
	{
		h.piece_priority(0, 1);
		st = h.status();
		TEST_CHECK(st.pieces.size() &gt; 0 &amp;&amp; st.pieces[0] == false);
		std::vector&lt;char&gt; piece(info-&gt;piece_length());
		for (int i = 0; i &lt; int(piece.size()); ++i)
			piece[i] = (i % 26) + 'A';
		h.add_piece(0, &amp;piece[0]);

		// wait until the piece is done writing and hashing
<div style="background: #ffff00" width="100%">		test_sleep(2000);
</div>		st = h.status();
		TEST_CHECK(st.pieces.size() &gt; 0 &amp;&amp; st.pieces[0] == true);

		std::cout &lt;&lt; "reading piece 0" &lt;&lt; std::endl;
		h.read_piece(0);
		alert const* a = wait_for_alert(ses, read_piece_alert::alert_type, "read_piece");
		TEST_CHECK(a);
		read_piece_alert const* rpa = alert_cast&lt;read_piece_alert&gt;(a);
		TEST_CHECK(rpa);
		if (rpa)
		{
			std::cout &lt;&lt; "SUCCEEDED!" &lt;&lt; std::endl;
			TEST_CHECK(memcmp(&amp;piece[0], rpa-&gt;buffer.get(), piece.size()) == 0);
			TEST_CHECK(rpa-&gt;size == info-&gt;piece_size(0));
			TEST_CHECK(rpa-&gt;piece == 0);
			TEST_CHECK(hasher(&amp;piece[0], piece.size()).final() == info-&gt;hash_for_piece(0));
		}
	}
}

int test_main()
{
/*	{
		remove("test_torrent_dir2/tmp1");
		remove("test_torrent_dir2/tmp2");
		remove("test_torrent_dir2/tmp3");
		file_storage fs;
		boost::int64_t file_size = 256 * 1024;
		fs.add_file("test_torrent_dir2/tmp1", file_size);
		fs.add_file("test_torrent_dir2/tmp2", file_size);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(98)">../test/test_torrent_info.cpp:160</a></td><td>test remap_files</td></tr><tr id="98" style="display: none;" colspan="3"><td colspan="3"><h2>test remap_files</h2><h4>../test/test_torrent_info.cpp:160</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(99)">../test/test_torrent_info.cpp:161</a></td><td>merkle torrents. specifically torrent_info::add_merkle_nodes and torrent with "root hash"</td></tr><tr id="99" style="display: none;" colspan="3"><td colspan="3"><h2>merkle torrents. specifically torrent_info::add_merkle_nodes and torrent with "root hash"</h2><h4>../test/test_torrent_info.cpp:161</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(100)">../test/test_torrent_info.cpp:162</a></td><td>torrent with 'p' (padfile) attribute</td></tr><tr id="100" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with 'p' (padfile) attribute</h2><h4>../test/test_torrent_info.cpp:162</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(101)">../test/test_torrent_info.cpp:163</a></td><td>torrent with 'h' (hidden) attribute</td></tr><tr id="101" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with 'h' (hidden) attribute</h2><h4>../test/test_torrent_info.cpp:163</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(102)">../test/test_torrent_info.cpp:164</a></td><td>torrent with 'x' (executable) attribute</td></tr><tr id="102" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with 'x' (executable) attribute</h2><h4>../test/test_torrent_info.cpp:164</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(103)">../test/test_torrent_info.cpp:165</a></td><td>torrent with 'l' (symlink) attribute</td></tr><tr id="103" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with 'l' (symlink) attribute</h2><h4>../test/test_torrent_info.cpp:165</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(104)">../test/test_torrent_info.cpp:166</a></td><td>creating a merkle torrent (torrent_info::build_merkle_list)</td></tr><tr id="104" style="display: none;" colspan="3"><td colspan="3"><h2>creating a merkle torrent (torrent_info::build_merkle_list)</h2><h4>../test/test_torrent_info.cpp:166</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(105)">../test/test_torrent_info.cpp:167</a></td><td>torrent with multiple trackers in multiple tiers, making sure we shuffle them (how do you test shuffling?, load it multiple times and make sure it's in different order at least once)</td></tr><tr id="105" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with multiple trackers in multiple tiers, making sure we shuffle them (how do you test shuffling?, load it multiple times and make sure it's in different order at least once)</h2><h4>../test/test_torrent_info.cpp:167</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(106)">../test/test_torrent_info.cpp:168</a></td><td>sanitize_append_path_element with all kinds of UTF-8 sequences, including invalid ones</td></tr><tr id="106" style="display: none;" colspan="3"><td colspan="3"><h2>sanitize_append_path_element with all kinds of UTF-8 sequences, including invalid ones</h2><h4>../test/test_torrent_info.cpp:168</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(107)">../test/test_torrent_info.cpp:169</a></td><td>torrents with a missing name</td></tr><tr id="107" style="display: none;" colspan="3"><td colspan="3"><h2>torrents with a missing name</h2><h4>../test/test_torrent_info.cpp:169</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(108)">../test/test_torrent_info.cpp:170</a></td><td>torrents with a zero-length name</td></tr><tr id="108" style="display: none;" colspan="3"><td colspan="3"><h2>torrents with a zero-length name</h2><h4>../test/test_torrent_info.cpp:170</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(109)">../test/test_torrent_info.cpp:171</a></td><td>torrents with a merkle tree and add_merkle_nodes</td></tr><tr id="109" style="display: none;" colspan="3"><td colspan="3"><h2>torrents with a merkle tree and add_merkle_nodes</h2><h4>../test/test_torrent_info.cpp:171</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(110)">../test/test_torrent_info.cpp:172</a></td><td>torrent with a non-dictionary info-section</td></tr><tr id="110" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with a non-dictionary info-section</h2><h4>../test/test_torrent_info.cpp:172</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(111)">../test/test_torrent_info.cpp:173</a></td><td>torrents with DHT nodes</td></tr><tr id="111" style="display: none;" colspan="3"><td colspan="3"><h2>torrents with DHT nodes</h2><h4>../test/test_torrent_info.cpp:173</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(112)">../test/test_torrent_info.cpp:174</a></td><td>torrent with url-list as a single string</td></tr><tr id="112" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with url-list as a single string</h2><h4>../test/test_torrent_info.cpp:174</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(113)">../test/test_torrent_info.cpp:175</a></td><td>torrent with http seed as a single string</td></tr><tr id="113" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with http seed as a single string</h2><h4>../test/test_torrent_info.cpp:175</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(114)">../test/test_torrent_info.cpp:176</a></td><td>torrent with a comment</td></tr><tr id="114" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with a comment</h2><h4>../test/test_torrent_info.cpp:176</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(115)">../test/test_torrent_info.cpp:177</a></td><td>torrent with an SSL cert</td></tr><tr id="115" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with an SSL cert</h2><h4>../test/test_torrent_info.cpp:177</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(116)">../test/test_torrent_info.cpp:178</a></td><td>torrent with attributes (executable and hidden)</td></tr><tr id="116" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with attributes (executable and hidden)</h2><h4>../test/test_torrent_info.cpp:178</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(117)">../test/test_torrent_info.cpp:179</a></td><td>torrent_info::add_tracker</td></tr><tr id="117" style="display: none;" colspan="3"><td colspan="3"><h2>torrent_info::add_tracker</h2><h4>../test/test_torrent_info.cpp:179</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(118)">../test/test_torrent_info.cpp:180</a></td><td>torrent_info::add_url_seed</td></tr><tr id="118" style="display: none;" colspan="3"><td colspan="3"><h2>torrent_info::add_url_seed</h2><h4>../test/test_torrent_info.cpp:180</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(119)">../test/test_torrent_info.cpp:181</a></td><td>torrent_info::add_http_seed</td></tr><tr id="119" style="display: none;" colspan="3"><td colspan="3"><h2>torrent_info::add_http_seed</h2><h4>../test/test_torrent_info.cpp:181</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(120)">../test/test_torrent_info.cpp:182</a></td><td>torrent_info::unload</td></tr><tr id="120" style="display: none;" colspan="3"><td colspan="3"><h2>torrent_info::unload</h2><h4>../test/test_torrent_info.cpp:182</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(121)">../test/test_torrent_info.cpp:183</a></td><td>torrent_info constructor that takes an invalid bencoded buffer</td></tr><tr id="121" style="display: none;" colspan="3"><td colspan="3"><h2>torrent_info constructor that takes an invalid bencoded buffer</h2><h4>../test/test_torrent_info.cpp:183</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(122)">../test/test_torrent_info.cpp:184</a></td><td>verify_encoding with a string that triggers character replacement</td></tr><tr id="122" style="display: none;" colspan="3"><td colspan="3"><h2>verify_encoding with a string that triggers character replacement</h2><h4>../test/test_torrent_info.cpp:184</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{ "invalid_info.torrent", errors::torrent_missing_info },
	{ "string.torrent", errors::torrent_is_no_dict },
	{ "negative_size.torrent", errors::torrent_invalid_length },
	{ "negative_file_size.torrent", errors::torrent_invalid_length },
	{ "invalid_path_list.torrent", errors::torrent_missing_name},
	{ "missing_path_list.torrent", errors::torrent_missing_name },
	{ "invalid_pieces.torrent", errors::torrent_missing_pieces },
	{ "unaligned_pieces.torrent", errors::torrent_invalid_hashes },
	{ "invalid_root_hash.torrent", errors::torrent_invalid_hashes },
	{ "invalid_root_hash2.torrent", errors::torrent_missing_pieces },
	{ "invalid_file_size.torrent", errors::torrent_invalid_length },
};

namespace libtorrent
{
	// defined in torrent_info.cpp
	TORRENT_EXPORT bool verify_encoding(std::string&amp; target, bool path = true);
	TORRENT_EXTRA_EXPORT void sanitize_append_path_element(std::string&amp; p, char const* element, int len);
}

<div style="background: #ffff00" width="100%">
</div>int test_torrent_parse()
{
	error_code ec;

	// test sanitize_append_path_element

	std::string path;

	path.clear();
	sanitize_append_path_element(path,
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_"
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_"
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_", 250);
	sanitize_append_path_element(path,
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_"
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_"
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcde.test", 250);
#ifdef TORRENT_WINDOWS
	TEST_EQUAL(path,
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_"
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_"
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_\\"
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_"
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_"
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_.test");
#else
	TEST_EQUAL(path,
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_"
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_abcdefghi_"
		"abcdefghi_abcdefghi_abcdefghi_abcdefghi_/"
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(123)">../test/test_tracker.cpp:198</a></td><td>test parse peers6</td></tr><tr id="123" style="display: none;" colspan="3"><td colspan="3"><h2>test parse peers6</h2><h4>../test/test_tracker.cpp:198</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(124)">../test/test_tracker.cpp:199</a></td><td>test parse tracker-id</td></tr><tr id="124" style="display: none;" colspan="3"><td colspan="3"><h2>test parse tracker-id</h2><h4>../test/test_tracker.cpp:199</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(125)">../test/test_tracker.cpp:200</a></td><td>test parse failure-reason</td></tr><tr id="125" style="display: none;" colspan="3"><td colspan="3"><h2>test parse failure-reason</h2><h4>../test/test_tracker.cpp:200</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(126)">../test/test_tracker.cpp:201</a></td><td>test all failure paths, including invalid bencoding not a dictionary no files entry in scrape response no info-hash entry in scrape response malformed peers in peer list of dictionaries uneven number of bytes in peers and peers6 string responses</td></tr><tr id="126" style="display: none;" colspan="3"><td colspan="3"><h2>test all failure paths, including
invalid bencoding
not a dictionary
no files entry in scrape response
no info-hash entry in scrape response
malformed peers in peer list of dictionaries
uneven number of bytes in peers and peers6 string responses</h2><h4>../test/test_tracker.cpp:201</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	TEST_EQUAL(ec, error_code());
	TEST_EQUAL(resp.peers.size(), 0);
	TEST_EQUAL(resp.external_ip, address_v6::from_string("f102:0304::ffff"));
}
#endif

int test_main()
{
	test_parse_hostname_peers();
	test_parse_peers4();
	test_parse_interval();
	test_parse_warning();
	test_parse_failure_reason();
	test_parse_scrape_response();
	test_parse_scrape_response_with_zero();
	test_parse_external_ip();
#if TORRENT_USE_IPV6
	test_parse_external_ip6();
#endif

<div style="background: #ffff00" width="100%">
</div>	int http_port = start_web_server();
	int udp_port = start_udp_tracker();

	int prev_udp_announces = num_udp_announces();

	int const alert_mask = alert::all_categories
		&amp; ~alert::progress_notification
		&amp; ~alert::stats_notification;

	lt::session* s = new lt::session(fingerprint("LT", 0, 1, 0, 0), std::make_pair(48875, 49800), "0.0.0.0", 0, alert_mask);

	settings_pack pack;
#ifndef TORRENT_NO_DEPRECATE
	pack.set_int(settings_pack::half_open_limit, 1);
#endif
	pack.set_bool(settings_pack::announce_to_all_trackers, true);
	pack.set_bool(settings_pack::announce_to_all_tiers, true);
	s-&gt;apply_settings(pack);

	error_code ec;
	remove_all("tmp1_tracker", ec);
	create_directory("tmp1_tracker", ec);
	std::ofstream file(combine_path("tmp1_tracker", "temporary").c_str());
	boost::shared_ptr&lt;torrent_info&gt; t = ::create_torrent(&amp;file, 16 * 1024, 13, false);
	file.close();

	char tracker_url[200];
	snprintf(tracker_url, sizeof(tracker_url), "http://127.0.0.1:%d/announce", http_port);
	t-&gt;add_tracker(tracker_url, 0);

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(127)">../test/test_transfer.cpp:291</a></td><td>factor out the disk-full test into its own unit test</td></tr><tr id="127" style="display: none;" colspan="3"><td colspan="3"><h2>factor out the disk-full test into its own unit test</h2><h4>../test/test_transfer.cpp:291</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		print_alerts(ses1, "ses1", true, true, true, &amp;on_alert);
		print_alerts(ses2, "ses2", true, true, true, &amp;on_alert);

		if (i % 10 == 0)
		{
			print_ses_rate(i / 10.f, &amp;st1, &amp;st2);
		}

		if (!test_move_storage &amp;&amp; st2.progress &gt; 0.25f)
		{
			test_move_storage = true;
			tor1.move_storage("tmp1_transfer_moved");
			tor2.move_storage("tmp2_transfer_moved");
			std::cerr &lt;&lt; "moving storage" &lt;&lt; std::endl;
		}

		// wait 10 loops before we restart the torrent. This lets
		// us catch all events that failed (and would put the torrent
		// back into upload mode) before we restart it.

<div style="background: #ffff00" width="100%">		if (test_disk_full &amp;&amp; st2.upload_mode &amp;&amp; ++upload_mode_timer &gt; 10)
</div>		{
			test_disk_full = false;
			((test_storage*)tor2.get_storage_impl())-&gt;set_limit(16 * 1024 * 1024);

			// if we reset the upload mode too soon, there may be more disk
			// jobs failing right after, putting us back in upload mode. So,
			// give the disk some time to fail all disk jobs before resetting
			// upload mode to false
			test_sleep(500);

			// then we need to drain the alert queue, so the peer_disconnects
			// counter doesn't get incremented by old alerts
			print_alerts(ses1, "ses1", true, true, true, &amp;on_alert);
			print_alerts(ses2, "ses2", true, true, true, &amp;on_alert);

			tor2.set_upload_mode(false);

			// at this point we probably disconnected the seed
			// so we need to reconnect as well
			fprintf(stderr, "%s: reconnecting peer\n", time_now_string());
			error_code ec;
			tor2.connect_peer(tcp::endpoint(address::from_string("127.0.0.1", ec)
				, ses1.listen_port()));

			TEST_CHECK(tor2.status().is_finished == false);
			fprintf(stderr, "disconnects: %d\n", peer_disconnects);
			TEST_CHECK(peer_disconnects &gt;= 2);
			fprintf(stderr, "%s: discovered disk full mode. Raise limit and disable upload-mode\n", time_now_string());
			peer_disconnects = 0;
			continue;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(128)">../test/test_upnp.cpp:100</a></td><td>store the log and verify that some key messages are there</td></tr><tr id="128" style="display: none;" colspan="3"><td colspan="3"><h2>store the log and verify that some key messages are there</h2><h4>../test/test_upnp.cpp:100</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		"USN:uuid:000f-66d6-7296000099dc::upnp:rootdevice\r\n"
		"Location: http://127.0.0.1:%d/upnp.xml\r\n"
		"Server: Custom/1.0 UPnP/1.0 Proc/Ver\r\n"
		"EXT:\r\n"
		"Cache-Control:max-age=180\r\n"
		"DATE: Fri, 02 Jan 1970 08:10:38 GMT\r\n\r\n";

	TORRENT_ASSERT(g_port != 0);
	char buf[sizeof(msg) + 30];
	int len = snprintf(buf, sizeof(buf), msg, g_port);

	error_code ec;
	sock-&gt;send(buf, len, ec);

	if (ec) std::cerr &lt;&lt; "*** error sending " &lt;&lt; ec.message() &lt;&lt; std::endl;
}

void log_callback(char const* err)
{
	std::cerr &lt;&lt; "UPnP: " &lt;&lt; err &lt;&lt; std::endl;
<div style="background: #ffff00" width="100%">}
</div>
struct callback_info
{
	int mapping;
	int port;
	error_code ec;
	bool operator==(callback_info const&amp; e)
	{ return mapping == e.mapping &amp;&amp; port == e.port &amp;&amp; !ec == !e.ec; }
};

std::list&lt;callback_info&gt; callbacks;

void callback(int mapping, address const&amp; ip, int port, error_code const&amp; err)
{
	callback_info info = {mapping, port, err};
	callbacks.push_back(info);
	std::cerr &lt;&lt; "mapping: " &lt;&lt; mapping &lt;&lt; ", port: " &lt;&lt; port &lt;&lt; ", IP: " &lt;&lt; ip
		&lt;&lt; ", error: \"" &lt;&lt; err.message() &lt;&lt; "\"\n";
}

int run_upnp_test(char const* root_filename, char const* router_model, char const* control_name)
{
	libtorrent::io_service ios;
	
	g_port = start_web_server();

	std::vector&lt;char&gt; buf;
	error_code ec;
	load_file(root_filename, buf, ec);
	buf.push_back(0);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(129)">../test/web_seed_suite.cpp:366</a></td><td>file hashes don't work with the new torrent creator reading async</td></tr><tr id="129" style="display: none;" colspan="3"><td colspan="3"><h2>file hashes don't work with the new torrent creator reading async</h2><h4>../test/web_seed_suite.cpp:366</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// corrupt the files now, so that the web seed will be banned
		if (test_url_seed)
		{
			create_random_files(combine_path(save_path, "torrent_dir"), file_sizes, sizeof(file_sizes)/sizeof(file_sizes[0]));
		}
		else
		{
			piece_size = 64 * 1024;
			char* random_data = (char*)malloc(64 * 1024 * num_pieces);
			std::generate(random_data, random_data + 64 * 1024 * num_pieces, random_byte);
			save_file(combine_path(save_path, "seed").c_str(), random_data, 64 * 1024 * num_pieces);
			free(random_data);
		}
	}

	std::vector&lt;char&gt; buf;
	bencode(std::back_inserter(buf), t.generate());
	boost::shared_ptr&lt;torrent_info&gt; torrent_file(boost::make_shared&lt;torrent_info&gt;(&amp;buf[0], buf.size(), boost::ref(ec), 0));


<div style="background: #ffff00" width="100%">/*
</div>	// no point in testing the hashes since we know the data is corrupt
	if (!test_ban)
	{
		// verify that the file hashes are correct
		for (int i = 0; i &lt; torrent_file-&gt;num_files(); ++i)
		{
			sha1_hash h1 = torrent_file-&gt;file_at(i).filehash;
			sha1_hash h2 = file_hash(combine_path(save_path
				, torrent_file-&gt;file_at(i).path));
//			fprintf(stderr, "%s: %s == %s\n"
//				, torrent_file-&gt;file_at(i).path.c_str()
//				, to_hex(h1.to_string()).c_str(), to_hex(h2.to_string()).c_str());
			TEST_EQUAL(h1, h2);
		}
	}
*/
	{
		settings_pack pack;
		pack.set_int(settings_pack::max_queued_disk_bytes, 256 * 1024);
		pack.set_str(settings_pack::listen_interfaces, "0.0.0.0:51000");
		pack.set_int(settings_pack::max_retry_port_bind, 1000);
		pack.set_int(settings_pack::alert_mask, ~(alert::progress_notification | alert::stats_notification));
		pack.set_bool(settings_pack::enable_lsd, false);
		pack.set_bool(settings_pack::enable_natpmp, false);
		pack.set_bool(settings_pack::enable_upnp, false);
		pack.set_bool(settings_pack::enable_dht, false);
		libtorrent::session ses(pack, 0);

		test_transfer(ses, torrent_file, proxy, port, protocol, test_url_seed
			, chunked_encoding, test_ban, keepalive);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(130)">../src/block_cache.cpp:959</a></td><td>it's somewhat expensive to iterate over this linked list. Presumably because of the random access of memory. It would be nice if pieces with no evictable blocks weren't in this list</td></tr><tr id="130" style="display: none;" colspan="3"><td colspan="3"><h2>it's somewhat expensive
to iterate over this linked list. Presumably because of the random
access of memory. It would be nice if pieces with no evictable blocks
weren't in this list</h2><h4>../src/block_cache.cpp:959</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	}
	else if (m_last_cache_op == ghost_hit_lru1)
	{
		// when we insert new items or move things from L1 to L2
		// evict blocks from L2
		lru_list[1] = &amp;m_lru[cached_piece_entry::read_lru2];
		lru_list[2] = &amp;m_lru[cached_piece_entry::read_lru1];
	}
	else
	{
		// when we get cache hits in L2 evict from L1
		lru_list[1] = &amp;m_lru[cached_piece_entry::read_lru1];
		lru_list[2] = &amp;m_lru[cached_piece_entry::read_lru2];
	}

	// end refers to which end of the ARC cache we're evicting
	// from. The LFU or the LRU end
	for (int end = 0; num &gt; 0 &amp;&amp; end &lt; 3; ++end)
	{
		// iterate over all blocks in order of last being used (oldest first) and
<div style="background: #ffff00" width="100%">		for (list_iterator i = lru_list[end]-&gt;iterate(); i.get() &amp;&amp; num &gt; 0;)
</div>		{
			cached_piece_entry* pe = reinterpret_cast&lt;cached_piece_entry*&gt;(i.get());
			TORRENT_PIECE_ASSERT(pe-&gt;in_use, pe);
			i.next();

			if (pe == ignore)
				continue;

			if (pe-&gt;ok_to_evict())
			{
#ifdef TORRENT_DEBUG
				for (int j = 0; j &lt; pe-&gt;blocks_in_piece; ++j)
					TORRENT_PIECE_ASSERT(pe-&gt;blocks[j].buf == 0, pe);
#endif
				TORRENT_PIECE_ASSERT(pe-&gt;refcount == 0, pe);
				move_to_ghost(pe);
				continue;
			}

			TORRENT_PIECE_ASSERT(pe-&gt;num_dirty == 0, pe);

			// all blocks are pinned in this piece, skip it
			if (pe-&gt;num_blocks &lt;= pe-&gt;pinned) continue;

			// go through the blocks and evict the ones that are not dirty and not
			// referenced
			for (int j = 0; j &lt; pe-&gt;blocks_in_piece &amp;&amp; num &gt; 0; ++j)
			{
				cached_block_entry&amp; b = pe-&gt;blocks[j];

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(131)">../src/block_cache.cpp:1023</a></td><td>this should probably only be done every n:th time</td></tr><tr id="131" style="display: none;" colspan="3"><td colspan="3"><h2>this should probably only be done every n:th time</h2><h4>../src/block_cache.cpp:1023</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			}

			if (pe-&gt;ok_to_evict())
			{
#ifdef TORRENT_DEBUG
				for (int j = 0; j &lt; pe-&gt;blocks_in_piece; ++j)
					TORRENT_PIECE_ASSERT(pe-&gt;blocks[j].buf == 0, pe);
#endif
				move_to_ghost(pe);
			}
		}
	}

	// if we can't evict enough blocks from the read cache, also look at write
	// cache pieces for blocks that have already been written to disk and can be
	// evicted the first pass, we only evict blocks that have been hashed, the
	// second pass we flush anything this is potentially a very expensive
	// operation, since we're likely to have iterate every single block in the
	// cache, and we might not get to evict anything.

<div style="background: #ffff00" width="100%">	if (num &gt; 0 &amp;&amp; m_read_cache_size &gt; m_pinned_blocks)
</div>	{
		for (int pass = 0; pass &lt; 2 &amp;&amp; num &gt; 0; ++pass)
		{
			for (list_iterator i = m_lru[cached_piece_entry::write_lru].iterate(); i.get() &amp;&amp; num &gt; 0;)
			{
				cached_piece_entry* pe = reinterpret_cast&lt;cached_piece_entry*&gt;(i.get());
				TORRENT_PIECE_ASSERT(pe-&gt;in_use, pe);

				i.next();

				if (pe == ignore)
					continue;

				if (pe-&gt;ok_to_evict())
				{
#ifdef TORRENT_DEBUG
					for (int j = 0; j &lt; pe-&gt;blocks_in_piece; ++j)
						TORRENT_PIECE_ASSERT(pe-&gt;blocks[j].buf == 0, pe);
#endif
					TORRENT_PIECE_ASSERT(pe-&gt;refcount == 0, pe);
					erase_piece(pe);
					continue;
				}

				// all blocks in this piece are dirty
				if (pe-&gt;num_dirty == pe-&gt;num_blocks)
					continue;

				int end = pe-&gt;blocks_in_piece;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(132)">../src/block_cache.cpp:1775</a></td><td>create a holder for refcounts that automatically decrement</td></tr><tr id="132" style="display: none;" colspan="3"><td colspan="3"><h2>create a holder for refcounts that automatically decrement</h2><h4>../src/block_cache.cpp:1775</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	}

	j-&gt;buffer = allocate_buffer("send buffer");
	if (j-&gt;buffer == 0) return -2;

	while (size &gt; 0)
	{
		TORRENT_PIECE_ASSERT(pe-&gt;blocks[block].buf, pe);
		int to_copy = (std::min)(block_size()
			- block_offset, size);
		std::memcpy(j-&gt;buffer + buffer_offset
			, pe-&gt;blocks[block].buf + block_offset
			, to_copy);
		size -= to_copy;
		block_offset = 0;
		buffer_offset += to_copy;
		++block;
	}
	// we incremented the refcount for both of these blocks.
	// now decrement it.
<div style="background: #ffff00" width="100%">	dec_block_refcount(pe, start_block, ref_reading);
</div>	if (blocks_to_read == 2) dec_block_refcount(pe, start_block + 1, ref_reading);
	return j-&gt;d.io.buffer_size;
}

void block_cache::reclaim_block(block_cache_reference const&amp; ref)
{
	cached_piece_entry* pe = find_piece(ref);
	TORRENT_ASSERT(pe);
	if (pe == NULL) return;

	TORRENT_PIECE_ASSERT(pe-&gt;in_use, pe);

	TORRENT_PIECE_ASSERT(pe-&gt;blocks[ref.block].buf, pe);
	dec_block_refcount(pe, ref.block, block_cache::ref_reading);

	TORRENT_PIECE_ASSERT(m_send_buffer_blocks &gt; 0, pe);
	--m_send_buffer_blocks;

	maybe_free_piece(pe);
}

bool block_cache::maybe_free_piece(cached_piece_entry* pe)
{
	if (!pe-&gt;ok_to_evict()
		|| !pe-&gt;marked_for_deletion
		|| !pe-&gt;jobs.empty())
		return false;

	boost::shared_ptr&lt;piece_manager&gt; s = pe-&gt;storage;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(133)">../src/bt_peer_connection.cpp:676</a></td><td>this could be optimized using knuth morris pratt</td></tr><tr id="133" style="display: none;" colspan="3"><td colspan="3"><h2>this could be optimized using knuth morris pratt</h2><h4>../src/bt_peer_connection.cpp:676</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		}

		m_rc4-&gt;set_incoming_key(&amp;remote_key[0], 20);
		m_rc4-&gt;set_outgoing_key(&amp;local_key[0], 20);

#ifndef TORRENT_DISABLE_LOGGING
		peer_log(peer_log_alert::info, "ENCRYPTION", "computed RC4 keys");
#endif
	}

	int bt_peer_connection::get_syncoffset(char const* src, int src_size,
		char const* target, int target_size) const
	{
		TORRENT_ASSERT(target_size &gt;= src_size);
		TORRENT_ASSERT(src_size &gt; 0);
		TORRENT_ASSERT(src);
		TORRENT_ASSERT(target);

		int traverse_limit = target_size - src_size;

<div style="background: #ffff00" width="100%">		for (int i = 0; i &lt; traverse_limit; ++i)
</div>		{
			char const* target_ptr = target + i;
			if (std::equal(src, src+src_size, target_ptr))
				return i;
		}

//	    // Partial sync
// 		for (int i = 0; i &lt; target_size; ++i)
// 		{
// 			// first is iterator in src[] at which mismatch occurs
// 			// second is iterator in target[] at which mismatch occurs
// 			std::pair&lt;const char*, const char*&gt; ret;
// 			int src_sync_size;
//  			if (i &gt; traverse_limit) // partial sync test
//  			{
//  				ret = std::mismatch(src, src + src_size - (i - traverse_limit), &amp;target[i]);
//  				src_sync_size = ret.first - src;
//  				if (src_sync_size == (src_size - (i - traverse_limit)))
//  					return i;
//  			}
//  			else // complete sync test
// 			{
// 				ret = std::mismatch(src, src + src_size, &amp;target[i]);
// 				src_sync_size = ret.first - src;
// 				if (src_sync_size == src_size)
// 					return i;
// 			}
// 		}

        // no complete sync
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(134)">../src/bt_peer_connection.cpp:2245</a></td><td>if we're finished, send upload_only message</td></tr><tr id="134" style="display: none;" colspan="3"><td colspan="3"><h2>if we're finished, send upload_only message</h2><h4>../src/bt_peer_connection.cpp:2245</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		}
		peer_log(peer_log_alert::outgoing_message, "BITFIELD"
			, "%s", bitfield_string.c_str());
#endif
		m_sent_bitfield = true;

		send_buffer(msg, packet_size);

		stats_counters().inc_stats_counter(counters::num_outgoing_bitfield);

		if (num_lazy_pieces &gt; 0)
		{
			for (int i = 0; i &lt; num_lazy_pieces; ++i)
			{
#ifndef TORRENT_DISABLE_LOGGING
				peer_log(peer_log_alert::outgoing_message, "HAVE"
					, "piece: %d", lazy_pieces[i]);
#endif
				write_have(lazy_pieces[i]);
			}
<div style="background: #ffff00" width="100%">		}
</div>
		if (m_supports_fast)
			send_allowed_set();
	}

#ifndef TORRENT_DISABLE_EXTENSIONS
	void bt_peer_connection::write_extensions()
	{
		INVARIANT_CHECK;

		TORRENT_ASSERT(m_supports_extensions);
		TORRENT_ASSERT(m_sent_handshake);

		entry handshake;
		entry::dictionary_type&amp; m = handshake["m"].dict();

		// if we're using a proxy, our listen port won't be useful
		// anyway.
		if (!m_settings.get_bool(settings_pack::force_proxy) &amp;&amp; is_outgoing())
			handshake["p"] = m_ses.listen_port();

		// only send the port in case we bade the connection
		// on incoming connections the other end already knows
		// our listen port
		if (!m_settings.get_bool(settings_pack::anonymous_mode))
		{
			handshake["v"] = m_settings.get_str(settings_pack::handshake_client_version).empty()
				? m_settings.get_str(settings_pack::user_agent)
				: m_settings.get_str(settings_pack::handshake_client_version);
		}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(135)">../src/choker.cpp:336</a></td><td>optimize this using partial_sort or something. We don't need to sort the entire list</td></tr><tr id="135" style="display: none;" colspan="3"><td colspan="3"><h2>optimize this using partial_sort or something. We don't need
to sort the entire list</h2><h4>../src/choker.cpp:336</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			return upload_slots;
		}

		// ==== rate-based ====
		//
		// The rate based unchoker looks at our upload rate to peers, and find
		// a balance between number of upload slots and the rate we achieve. The
		// intention is to not spread upload bandwidth too thin, but also to not
		// unchoke few enough peers to not be able to saturate the up-link.
		// this is done by traversing the peers sorted by our upload rate to
		// them in decreasing rates. For each peer we increase our threshold
		// by 1 kB/s. The first peer we get to to whom we upload slower than
		// the threshold, we stop and that's the number of unchoke slots we have.
		if (sett.get_int(settings_pack::choking_algorithm)
			== settings_pack::rate_based_choker)
		{
			// first reset the number of unchoke slots, because we'll calculate
			// it purely based on the current state of our peers.
			upload_slots = 0;

<div style="background: #ffff00" width="100%">			
</div></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(136)">../src/choker.cpp:339</a></td><td>make the comparison function a free function and move it into this cpp file</td></tr><tr id="136" style="display: none;" colspan="3"><td colspan="3"><h2>make the comparison function a free function and move it
into this cpp file</h2><h4>../src/choker.cpp:339</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		}

		// ==== rate-based ====
		//
		// The rate based unchoker looks at our upload rate to peers, and find
		// a balance between number of upload slots and the rate we achieve. The
		// intention is to not spread upload bandwidth too thin, but also to not
		// unchoke few enough peers to not be able to saturate the up-link.
		// this is done by traversing the peers sorted by our upload rate to
		// them in decreasing rates. For each peer we increase our threshold
		// by 1 kB/s. The first peer we get to to whom we upload slower than
		// the threshold, we stop and that's the number of unchoke slots we have.
		if (sett.get_int(settings_pack::choking_algorithm)
			== settings_pack::rate_based_choker)
		{
			// first reset the number of unchoke slots, because we'll calculate
			// it purely based on the current state of our peers.
			upload_slots = 0;

			
<div style="background: #ffff00" width="100%">			std::sort(peers.begin(), peers.end()
</div>				, boost::bind(&amp;upload_rate_compare, _1, _2));

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(137)">../src/choker.cpp:344</a></td><td>make configurable</td></tr><tr id="137" style="display: none;" colspan="3"><td colspan="3"><h2>make configurable</h2><h4>../src/choker.cpp:344</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		//
		// The rate based unchoker looks at our upload rate to peers, and find
		// a balance between number of upload slots and the rate we achieve. The
		// intention is to not spread upload bandwidth too thin, but also to not
		// unchoke few enough peers to not be able to saturate the up-link.
		// this is done by traversing the peers sorted by our upload rate to
		// them in decreasing rates. For each peer we increase our threshold
		// by 1 kB/s. The first peer we get to to whom we upload slower than
		// the threshold, we stop and that's the number of unchoke slots we have.
		if (sett.get_int(settings_pack::choking_algorithm)
			== settings_pack::rate_based_choker)
		{
			// first reset the number of unchoke slots, because we'll calculate
			// it purely based on the current state of our peers.
			upload_slots = 0;

			
			std::sort(peers.begin(), peers.end()
				, boost::bind(&amp;upload_rate_compare, _1, _2));

<div style="background: #ffff00" width="100%">			int rate_threshold = 1024;
</div>
			for (std::vector&lt;peer_connection*&gt;::const_iterator i = peers.begin()
				, end(peers.end()); i != end; ++i)
			{
				peer_connection const&amp; p = **i;
				int rate = int(p.uploaded_in_last_round()
					* 1000 / total_milliseconds(unchoke_interval));

				if (rate &lt; rate_threshold) break;

				++upload_slots;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(138)">../src/choker.cpp:358</a></td><td>make configurable</td></tr><tr id="138" style="display: none;" colspan="3"><td colspan="3"><h2>make configurable</h2><h4>../src/choker.cpp:358</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// it purely based on the current state of our peers.
			upload_slots = 0;

			
			std::sort(peers.begin(), peers.end()
				, boost::bind(&amp;upload_rate_compare, _1, _2));

			int rate_threshold = 1024;

			for (std::vector&lt;peer_connection*&gt;::const_iterator i = peers.begin()
				, end(peers.end()); i != end; ++i)
			{
				peer_connection const&amp; p = **i;
				int rate = int(p.uploaded_in_last_round()
					* 1000 / total_milliseconds(unchoke_interval));

				if (rate &lt; rate_threshold) break;

				++upload_slots;

<div style="background: #ffff00" width="100%">				rate_threshold += 1024;
</div>			}
			++upload_slots;
		}

		// sorts the peers that are eligible for unchoke by download rate and
		// secondary by total upload. The reason for this is, if all torrents are
		// being seeded, the download rate will be 0, and the peers we have sent
		// the least to should be unchoked
		
		// we use partial sort here, because we only care about the top
		// upload_slots peers.

		if (sett.get_int(settings_pack::seed_choking_algorithm)
			== settings_pack::round_robin)
		{
			int pieces = sett.get_int(settings_pack::seeding_piece_quota);

			std::partial_sort(peers.begin(), peers.begin()
				+ (std::min)(upload_slots, int(peers.size())), peers.end()
				, boost::bind(&amp;unchoke_compare_rr, _1, _2, pieces));
		}
		else if (sett.get_int(settings_pack::seed_choking_algorithm)
			== settings_pack::fastest_upload)
		{
			std::partial_sort(peers.begin(), peers.begin()
				+ (std::min)(upload_slots, int(peers.size())), peers.end()
				, boost::bind(&amp;unchoke_compare_fastest_upload, _1, _2));
		}
		else if (sett.get_int(settings_pack::seed_choking_algorithm)
			== settings_pack::anti_leech)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(139)">../src/create_torrent.cpp:284</a></td><td>this should probably be optional</td></tr><tr id="139" style="display: none;" colspan="3"><td colspan="3"><h2>this should probably be optional</h2><h4>../src/create_torrent.cpp:284</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		boost::shared_ptr&lt;char&gt; dummy;
		counters cnt;
		disk_io_thread disk_thread(ios, cnt, 0);

		storage_params params;
		params.files = &amp;t.files();
		params.mapped_files = NULL;
		params.path = path;
		params.pool = &amp;disk_thread.files();
		params.mode = storage_mode_sparse;

		storage_interface* storage_impl = default_storage_constructor(params);

		boost::shared_ptr&lt;piece_manager&gt; storage = boost::make_shared&lt;piece_manager&gt;(
			storage_impl, dummy, (file_storage*)&amp;t.files());

		settings_pack sett;
		sett.set_int(settings_pack::cache_size, 0);
		sett.set_int(settings_pack::hashing_threads, 2);

<div style="background: #ffff00" width="100%">		alert_manager dummy2(0, 0);
</div>		disk_thread.set_settings(&amp;sett, dummy2);

		int piece_counter = 0;
		int completed_piece = 0;
		int piece_read_ahead = 15 * 1024 * 1024 / t.piece_length();
		if (piece_read_ahead &lt; 1) piece_read_ahead = 1;

		for (int i = 0; i &lt; piece_read_ahead; ++i)
		{
			disk_thread.async_hash(storage.get(), i, disk_io_job::sequential_access
				, boost::bind(&amp;on_hash, _1, &amp;t, storage, &amp;disk_thread
				, &amp;piece_counter, &amp;completed_piece, &amp;f, &amp;ec), (void*)0);
			++piece_counter;
			if (piece_counter &gt;= t.num_pieces()) break;
		}
		disk_thread.submit_jobs();
		ios.run(ec);
	}

	create_torrent::~create_torrent() {}

	create_torrent::create_torrent(file_storage&amp; fs, int piece_size
		, int pad_file_limit, int flags, int alignment)
		: m_files(fs)
		, m_creation_date(time(0))
		, m_multifile(fs.num_files() &gt; 1)
		, m_private(false)
		, m_merkle_torrent((flags &amp; merkle) != 0)
		, m_include_mtime((flags &amp; modification_time) != 0)
		, m_include_symlinks((flags &amp; symlinks) != 0)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(140)">../src/disk_buffer_pool.cpp:319</a></td><td>perhaps we should sort the buffers here?</td></tr><tr id="140" style="display: none;" colspan="3"><td colspan="3"><h2>perhaps we should sort the buffers here?</h2><h4>../src/disk_buffer_pool.cpp:319</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		mutex::scoped_lock l(m_pool_mutex);
		for (int i = 0; i &lt; iov_len; ++i)
		{
			iov[i].iov_base = allocate_buffer_impl(l, "pending read");
			iov[i].iov_len = block_size();
			if (iov[i].iov_base == NULL)
			{
				// uh oh. We failed to allocate the buffer!
				// we need to roll back and free all the buffers
				// we've already allocated
				for (int j = 0; j &lt; i; ++j)
					free_buffer_impl((char*)iov[j].iov_base, l);
				return -1;
			}
		}
		return 0;
	}

	void disk_buffer_pool::free_iovec(file::iovec_t* iov, int iov_len)
	{
<div style="background: #ffff00" width="100%">		mutex::scoped_lock l(m_pool_mutex);
</div>		for (int i = 0; i &lt; iov_len; ++i)
			free_buffer_impl((char*)iov[i].iov_base, l);
		check_buffer_level(l);
	}

	char* disk_buffer_pool::allocate_buffer_impl(mutex::scoped_lock&amp; l
		, char const*)
	{
		TORRENT_ASSERT(m_settings_set);
		TORRENT_ASSERT(m_magic == 0x1337);
		TORRENT_ASSERT(l.locked());
		TORRENT_UNUSED(l);

		char* ret;
#if TORRENT_HAVE_MMAP
		if (m_cache_pool)
		{
			if (m_free_list.size() &lt;= (m_max_use - m_low_watermark)
				/ 2 &amp;&amp; !m_exceeded_max_size)
			{
				m_exceeded_max_size = true;
				m_trigger_cache_trim();
			}
			if (m_free_list.empty()) return 0;
			boost::uint64_t slot_index = m_free_list.back();
			m_free_list.pop_back();
			ret = m_cache_pool + (slot_index * 0x4000);
			TORRENT_ASSERT(is_disk_buffer(ret, l));
		}
		else
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(141)">../src/disk_io_thread.cpp:857</a></td><td>it would be nice to optimize this by having the cache pieces also ordered by</td></tr><tr id="141" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to optimize this by having the cache
pieces also ordered by</h2><h4>../src/disk_io_thread.cpp:857</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// from disk_io_thread::do_delete, which is a fence job and should
			// have any other jobs active, i.e. there should not be any references
			// keeping pieces or blocks alive
			if ((flags &amp; flush_delete_cache) &amp;&amp; (flags &amp; flush_expect_clear))
			{
				boost::unordered_set&lt;cached_piece_entry*&gt; const&amp; storage_pieces = storage-&gt;cached_pieces();
				for (boost::unordered_set&lt;cached_piece_entry*&gt;::const_iterator i = storage_pieces.begin()
					, end(storage_pieces.end()); i != end; ++i)
				{
					cached_piece_entry* pe = m_disk_cache.find_piece(storage, (*i)-&gt;piece);
					TORRENT_PIECE_ASSERT(pe-&gt;num_dirty == 0, pe);
				}
			}
#endif
		}
		else
		{
			std::pair&lt;block_cache::iterator, block_cache::iterator&gt; range = m_disk_cache.all_pieces();
			while (range.first != range.second)
			{
<div style="background: #ffff00" width="100%">				if ((flags &amp; (flush_read_cache | flush_delete_cache)) == 0)
</div>				{
					// if we're not flushing the read cache, and not deleting the
					// cache, skip pieces with no dirty blocks, i.e. read cache
					// pieces
					while (range.first-&gt;num_dirty == 0)
					{
						++range.first;
						if (range.first == range.second) return;
					}
				}
				cached_piece_entry* pe = const_cast&lt;cached_piece_entry*&gt;(&amp;*range.first);
				flush_piece(pe, flags, completed_jobs, l);
				range = m_disk_cache.all_pieces();
			}
		}
	}

	// this is called if we're exceeding (or about to exceed) the cache
	// size limit. This means we should not restrict ourselves to contiguous
	// blocks of write cache line size, but try to flush all old blocks
	// this is why we pass in 1 as cont_block to the flushing functions
	void disk_io_thread::try_flush_write_blocks(int num, tailqueue&amp; completed_jobs
		, mutex::scoped_lock&amp; l)
	{
		DLOG("try_flush_write_blocks: %d\n", num);

		list_iterator range = m_disk_cache.write_lru_pieces();
		std::vector&lt;std::pair&lt;piece_manager*, int&gt; &gt; pieces;
		pieces.reserve(m_disk_cache.num_write_lru_pieces());

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(142)">../src/disk_io_thread.cpp:900</a></td><td>instead of doing a lookup each time through the loop, save cached_piece_entry pointers with piece_refcount incremented to pin them</td></tr><tr id="142" style="display: none;" colspan="3"><td colspan="3"><h2>instead of doing a lookup each time through the loop, save
cached_piece_entry pointers with piece_refcount incremented to pin them</h2><h4>../src/disk_io_thread.cpp:900</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// this is why we pass in 1 as cont_block to the flushing functions
	void disk_io_thread::try_flush_write_blocks(int num, tailqueue&amp; completed_jobs
		, mutex::scoped_lock&amp; l)
	{
		DLOG("try_flush_write_blocks: %d\n", num);

		list_iterator range = m_disk_cache.write_lru_pieces();
		std::vector&lt;std::pair&lt;piece_manager*, int&gt; &gt; pieces;
		pieces.reserve(m_disk_cache.num_write_lru_pieces());

		for (list_iterator p = range; p.get() &amp;&amp; num &gt; 0; p.next())
		{
			cached_piece_entry* e = (cached_piece_entry*)p.get();
			if (e-&gt;num_dirty == 0) continue;
			pieces.push_back(std::make_pair(e-&gt;storage.get(), int(e-&gt;piece)));
		}

		for (std::vector&lt;std::pair&lt;piece_manager*, int&gt; &gt;::iterator i = pieces.begin()
			, end(pieces.end()); i != end; ++i)
		{
<div style="background: #ffff00" width="100%">			cached_piece_entry* pe = m_disk_cache.find_piece(i-&gt;first, i-&gt;second);
</div>			if (pe == NULL) continue;

			// another thread may flush this piece while we're looping and
			// evict it into a read piece and then also evict it to ghost
			if (pe-&gt;cache_state != cached_piece_entry::write_lru) continue;

#if TORRENT_USE_ASSERTS
			pe-&gt;piece_log.push_back(piece_log_t(piece_log_t::try_flush_write_blocks, -1));
#endif
			++pe-&gt;piece_refcount;
			kick_hasher(pe, l);
			num -= try_flush_hashed(pe, 1, completed_jobs, l);
			--pe-&gt;piece_refcount;
		}

		// when the write cache is under high pressure, it is likely
		// counter productive to actually do this, since a piece may
		// not have had its flush_hashed job run on it 
		// so only do it if no other thread is currently flushing

		if (num == 0 || m_stats_counters[counters::num_writing_threads] &gt; 0) return;

		// if we still need to flush blocks, start over and flush
		// everything in LRU order (degrade to lru cache eviction)
		for (std::vector&lt;std::pair&lt;piece_manager*, int&gt; &gt;::iterator i = pieces.begin()
			, end(pieces.end()); i != end; ++i)
		{
			cached_piece_entry* pe = m_disk_cache.find_piece(i-&gt;first, i-&gt;second);
			if (pe == NULL) continue;
			if (pe-&gt;num_dirty == 0) continue;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(143)">../src/disk_io_thread.cpp:1079</a></td><td>instead of doing this. pass in the settings to each storage_interface call. Each disk thread could hold its most recent understanding of the settings in a shared_ptr, and update it every time it wakes up from a job. That way each access to the settings won't require a mutex to be held.</td></tr><tr id="143" style="display: none;" colspan="3"><td colspan="3"><h2>instead of doing this. pass in the settings to each storage_interface
call. Each disk thread could hold its most recent understanding of the settings
in a shared_ptr, and update it every time it wakes up from a job. That way
each access to the settings won't require a mutex to be held.</h2><h4>../src/disk_io_thread.cpp:1079</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{
		INVARIANT_CHECK;
		TORRENT_ASSERT(j-&gt;next == 0);
		TORRENT_ASSERT((j-&gt;flags &amp; disk_io_job::in_progress) || !j-&gt;storage);

		mutex::scoped_lock l(m_cache_mutex);

		check_cache_level(l, completed_jobs);

		DLOG("perform_job job: %s ( %s%s) piece: %d offset: %d outstanding: %d\n"
			, job_action_name[j-&gt;action]
			, (j-&gt;flags &amp; disk_io_job::fence) ? "fence ": ""
			, (j-&gt;flags &amp; disk_io_job::force_copy) ? "force_copy ": ""
			, j-&gt;piece, j-&gt;d.io.offset
			, j-&gt;storage ? j-&gt;storage-&gt;num_outstanding_jobs() : -1);

		l.unlock();

		boost::shared_ptr&lt;piece_manager&gt; storage = j-&gt;storage;

<div style="background: #ffff00" width="100%">		if (storage &amp;&amp; storage-&gt;get_storage_impl()-&gt;m_settings == 0)
</div>			storage-&gt;get_storage_impl()-&gt;m_settings = &amp;m_settings;

		TORRENT_ASSERT(j-&gt;action &lt; sizeof(job_functions)/sizeof(job_functions[0]));

		time_point start_time = clock_type::now();

		m_stats_counters.inc_stats_counter(counters::num_running_disk_jobs, 1);

		// call disk function
		int ret = (this-&gt;*(job_functions[j-&gt;action]))(j, completed_jobs);

		// note that -2 erros are OK
		TORRENT_ASSERT(ret != -1 || (j-&gt;error.ec &amp;&amp; j-&gt;error.operation != 0));

		m_stats_counters.inc_stats_counter(counters::num_running_disk_jobs, -1);

		if (ret == retry_job)
		{
			mutex::scoped_lock l(m_job_mutex);
			// to avoid busy looping here, give up
			// our quanta in case there aren't any other
			// jobs to run in between

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(144)">../src/disk_io_thread.cpp:1107</a></td><td>a potentially more efficient solution would be to have a special queue for retry jobs, that's only ever run when a job completes, in any thread. It would only work if counters::num_running_disk_jobs > 0</td></tr><tr id="144" style="display: none;" colspan="3"><td colspan="3"><h2>a potentially more efficient solution would be to have a special
queue for retry jobs, that's only ever run when a job completes, in
any thread. It would only work if counters::num_running_disk_jobs > 0</h2><h4>../src/disk_io_thread.cpp:1107</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		time_point start_time = clock_type::now();

		m_stats_counters.inc_stats_counter(counters::num_running_disk_jobs, 1);

		// call disk function
		int ret = (this-&gt;*(job_functions[j-&gt;action]))(j, completed_jobs);

		// note that -2 erros are OK
		TORRENT_ASSERT(ret != -1 || (j-&gt;error.ec &amp;&amp; j-&gt;error.operation != 0));

		m_stats_counters.inc_stats_counter(counters::num_running_disk_jobs, -1);

		if (ret == retry_job)
		{
			mutex::scoped_lock l(m_job_mutex);
			// to avoid busy looping here, give up
			// our quanta in case there aren't any other
			// jobs to run in between

<div style="background: #ffff00" width="100%">			
</div>			TORRENT_ASSERT((j-&gt;flags &amp; disk_io_job::in_progress) || !j-&gt;storage);
	
			bool need_sleep = m_queued_jobs.empty();
			m_queued_jobs.push_back(j);
			l.unlock();
			if (need_sleep) sleep(0);
			return;
		}

#if TORRENT_USE_ASSERT
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(145)">../src/disk_io_thread.cpp:1121</a></td><td>it should clear the hash state even when there's an error, right?</td></tr><tr id="145" style="display: none;" colspan="3"><td colspan="3"><h2>it should clear the hash state even when there's an error, right?</h2><h4>../src/disk_io_thread.cpp:1121</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		m_stats_counters.inc_stats_counter(counters::num_running_disk_jobs, -1);

		if (ret == retry_job)
		{
			mutex::scoped_lock l(m_job_mutex);
			// to avoid busy looping here, give up
			// our quanta in case there aren't any other
			// jobs to run in between

			
			TORRENT_ASSERT((j-&gt;flags &amp; disk_io_job::in_progress) || !j-&gt;storage);
	
			bool need_sleep = m_queued_jobs.empty();
			m_queued_jobs.push_back(j);
			l.unlock();
			if (need_sleep) sleep(0);
			return;
		}

#if TORRENT_USE_ASSERT
<div style="background: #ffff00" width="100%">		if (j-&gt;action == disk_io_job::hash &amp;&amp; !j-&gt;error.ec)
</div>		{
			// a hash job should never return without clearing pe-&gt;hash
			l.lock();
			cached_piece_entry* pe = m_disk_cache.find_piece(j);
			if (pe != NULL)
			{
				TORRENT_PIECE_ASSERT(pe-&gt;hash == NULL, pe);
			}
			l.unlock();
		}
#endif

		if (ret == defer_handler) return;

		j-&gt;ret = ret;

		time_point now = clock_type::now();
		m_job_time.add_sample(total_microseconds(now - start_time));
		completed_jobs.push_back(j);
	}

	int disk_io_thread::do_uncached_read(disk_io_job* j)
	{
		j-&gt;buffer = m_disk_cache.allocate_buffer("send buffer");
		if (j-&gt;buffer == 0)
		{
			j-&gt;error.ec = error::no_memory;
			j-&gt;error.operation = storage_error::alloc_cache_piece;
			return -1;
		}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(146)">../src/disk_io_thread.cpp:1819</a></td><td>maybe the tailqueue_iterator should contain a pointer-pointer instead and have an unlink function</td></tr><tr id="146" style="display: none;" colspan="3"><td colspan="3"><h2>maybe the tailqueue_iterator should contain a pointer-pointer
instead and have an unlink function</h2><h4>../src/disk_io_thread.cpp:1819</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		j-&gt;callback = handler;

		add_fence_job(storage, j);
	}

	void disk_io_thread::async_delete_files(piece_manager* storage
		, boost::function&lt;void(disk_io_job const*)&gt; const&amp; handler)
	{
#ifdef TORRENT_DEBUG
		// the caller must increment the torrent refcount before
		// issuing an async disk request
		storage-&gt;assert_torrent_refcount();
#endif

		// remove cache blocks belonging to this torrent
		tailqueue completed_jobs;

		// remove outstanding jobs belonging to this torrent
		mutex::scoped_lock l2(m_job_mutex);

<div style="background: #ffff00" width="100%">		disk_io_job* qj = (disk_io_job*)m_queued_jobs.get_all();
</div>		tailqueue to_abort;

		while (qj)
		{
			disk_io_job* next = (disk_io_job*)qj-&gt;next;
#if TORRENT_USE_ASSERTS
			qj-&gt;next = NULL;
#endif
			if (qj-&gt;storage.get() == storage)
				to_abort.push_back(qj);
			else
				m_queued_jobs.push_back(qj);
			qj = next;
		}
		l2.unlock();

		mutex::scoped_lock l(m_cache_mutex);
		flush_cache(storage, flush_delete_cache, completed_jobs, l);
		l.unlock();

		disk_io_job* j = allocate_job(disk_io_job::delete_files);
		j-&gt;storage = storage-&gt;shared_from_this();
		j-&gt;callback = handler;
		add_fence_job(storage, j);

		fail_jobs_impl(storage_error(boost::asio::error::operation_aborted)
			, to_abort, completed_jobs);

		if (completed_jobs.size())
			add_completed_jobs(completed_jobs);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(147)">../src/disk_io_thread.cpp:2081</a></td><td>this is potentially very expensive. One way to solve it would be to have a fence for just this one piece.</td></tr><tr id="147" style="display: none;" colspan="3"><td colspan="3"><h2>this is potentially very expensive. One way to solve
it would be to have a fence for just this one piece.</h2><h4>../src/disk_io_thread.cpp:2081</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	}

	void disk_io_thread::async_clear_piece(piece_manager* storage, int index
		, boost::function&lt;void(disk_io_job const*)&gt; const&amp; handler)
	{
#ifdef TORRENT_DEBUG
		// the caller must increment the torrent refcount before
		// issuing an async disk request
		storage-&gt;assert_torrent_refcount();
#endif

		disk_io_job* j = allocate_job(disk_io_job::clear_piece);
		j-&gt;storage = storage-&gt;shared_from_this();
		j-&gt;piece = index;
		j-&gt;callback = handler;

		// regular jobs are not guaranteed to be executed in-order
		// since clear piece must guarantee that all write jobs that
		// have been issued finish before the clear piece job completes

<div style="background: #ffff00" width="100%">		add_fence_job(storage, j);
</div>	}

	void disk_io_thread::clear_piece(piece_manager* storage, int index)	
	{
		mutex::scoped_lock l(m_cache_mutex);

		cached_piece_entry* pe = m_disk_cache.find_piece(storage, index);
		if (pe == 0) return;
		TORRENT_PIECE_ASSERT(pe-&gt;hashing == false, pe);
		pe-&gt;hashing_done = 0;
		delete pe-&gt;hash;
		pe-&gt;hash = NULL;

		// evict_piece returns true if the piece was in fact
		// evicted. A piece may fail to be evicted if there
		// are still outstanding operations on it, which should
		// never be the case when this function is used
		// in fact, no jobs should really be hung on this piece
		// at this point
		tailqueue jobs;
		bool ok = m_disk_cache.evict_piece(pe, jobs);
		TORRENT_PIECE_ASSERT(ok, pe);
		fail_jobs(storage_error(boost::asio::error::operation_aborted), jobs);
	}

	void disk_io_thread::kick_hasher(cached_piece_entry* pe, mutex::scoped_lock&amp; l)
	{
		if (!pe-&gt;hash) return;
		if (pe-&gt;hashing) return;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(148)">../src/disk_io_thread.cpp:2342</a></td><td>we should probably just hang the job on the piece and make sure the hasher gets kicked</td></tr><tr id="148" style="display: none;" colspan="3"><td colspan="3"><h2>we should probably just hang the job on the piece and make sure the hasher gets kicked</h2><h4>../src/disk_io_thread.cpp:2342</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (pe == NULL)
		{
			int cache_state = (j-&gt;flags &amp; disk_io_job::volatile_read)
				? cached_piece_entry::volatile_read_lru
				: cached_piece_entry::read_lru1;
			pe = m_disk_cache.allocate_piece(j, cache_state);
		}
		if (pe == NULL)
		{
			j-&gt;error.ec = error::no_memory;
			j-&gt;error.operation = storage_error::alloc_cache_piece;
			return -1;
		}

		if (pe-&gt;hashing)
		{
			TORRENT_PIECE_ASSERT(pe-&gt;hash, pe);
			// another thread is hashing this piece right now
			// try again in a little bit
			DLOG("do_hash: retry\n");
<div style="background: #ffff00" width="100%">			return retry_job;
</div>		}

		pe-&gt;hashing = 1;

		TORRENT_PIECE_ASSERT(pe-&gt;cache_state &lt;= cached_piece_entry::read_lru1
			|| pe-&gt;cache_state == cached_piece_entry::read_lru2, pe);
		++pe-&gt;piece_refcount;

		if (pe-&gt;hash == NULL)
		{
			pe-&gt;hashing_done = 0;
			pe-&gt;hash = new partial_hash;
		}
		partial_hash* ph = pe-&gt;hash;

		int block_size = m_disk_cache.block_size();
		int blocks_in_piece = (piece_size + block_size - 1) / block_size;
		
		// keep track of which blocks we have locked by incrementing
		// their refcounts. This is used to decrement only these blocks
		// later.
		int* locked_blocks = TORRENT_ALLOCA(int, blocks_in_piece);
		memset(locked_blocks, 0, blocks_in_piece * sizeof(int));
		int num_locked_blocks = 0;

		// increment the refcounts of all
		// blocks up front, and then hash them without holding the lock
		TORRENT_PIECE_ASSERT(ph-&gt;offset % block_size == 0, pe);
		for (int i = ph-&gt;offset / block_size; i &lt; blocks_in_piece; ++i)
		{
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(149)">../src/disk_io_thread.cpp:2409</a></td><td>introduce a holder class that automatically increments and decrements the piece_refcount</td></tr><tr id="149" style="display: none;" colspan="3"><td colspan="3"><h2>introduce a holder class that automatically increments
and decrements the piece_refcount</h2><h4>../src/disk_io_thread.cpp:2409</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		{
			file::iovec_t iov;
			iov.iov_len = (std::min)(block_size, piece_size - ph-&gt;offset);

			if (next_locked_block &lt; num_locked_blocks
				&amp;&amp; locked_blocks[next_locked_block] == i)
			{
				++next_locked_block;
				TORRENT_PIECE_ASSERT(pe-&gt;blocks[i].buf, pe);
				TORRENT_PIECE_ASSERT(ph-&gt;offset == i * block_size, pe);
				ph-&gt;offset += iov.iov_len;
				ph-&gt;h.update(pe-&gt;blocks[i].buf, iov.iov_len);
			}
			else
			{
				iov.iov_base = m_disk_cache.allocate_buffer("hashing");

				if (iov.iov_base == NULL)
				{
					l.lock();
<div style="background: #ffff00" width="100%">
</div>					// decrement the refcounts of the blocks we just hashed
					for (int i = 0; i &lt; num_locked_blocks; ++i)
						m_disk_cache.dec_block_refcount(pe, locked_blocks[i], block_cache::ref_hashing);

					--pe-&gt;piece_refcount;
					pe-&gt;hashing = false;
					delete pe-&gt;hash;
					pe-&gt;hash = NULL;

					m_disk_cache.maybe_free_piece(pe);

					j-&gt;error.ec = errors::no_memory;
					j-&gt;error.operation = storage_error::alloc_cache_piece;
					return -1;
				}

				DLOG("do_hash: reading (piece: %d block: %d)\n", int(pe-&gt;piece), i);

				time_point start_time = clock_type::now();

				TORRENT_PIECE_ASSERT(ph-&gt;offset == i * block_size, pe);
				ret = j-&gt;storage-&gt;get_storage_impl()-&gt;readv(&amp;iov, 1, j-&gt;piece
						, ph-&gt;offset, file_flags, j-&gt;error);

				if (ret &lt; 0)
				{
					m_disk_cache.free_buffer((char*)iov.iov_base);
					l.lock();
					break;
				}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(150)">../src/disk_io_thread.cpp:2655</a></td><td>it would be nice to not have to lock the mutex every turn through this loop</td></tr><tr id="150" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to not have to lock the mutex every
turn through this loop</h2><h4>../src/disk_io_thread.cpp:2655</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			j-&gt;error.ec = error::no_memory;
			j-&gt;error.operation = storage_error::alloc_cache_piece;
			return -1;
		}

#if TORRENT_USE_ASSERTS
		pe-&gt;piece_log.push_back(piece_log_t(j-&gt;action));
#endif
		TORRENT_PIECE_ASSERT(pe-&gt;cache_state &lt;= cached_piece_entry::read_lru1
			|| pe-&gt;cache_state == cached_piece_entry::read_lru2, pe);
		++pe-&gt;piece_refcount;

		int block_size = m_disk_cache.block_size();
		int piece_size = j-&gt;storage-&gt;files()-&gt;piece_size(j-&gt;piece);
		int blocks_in_piece = (piece_size + block_size - 1) / block_size;
		
		file::iovec_t iov;
		int ret = 0;
		int offset = 0;

<div style="background: #ffff00" width="100%">		for (int i = 0; i &lt; blocks_in_piece; ++i)
</div>		{
			iov.iov_len = (std::min)(block_size, piece_size - offset);

			// is the block already in the cache?
			if (pe-&gt;blocks[i].buf) continue;
			l.unlock();

			iov.iov_base = m_disk_cache.allocate_buffer("read cache");

			if (iov.iov_base == NULL)
			{
				//#error introduce a holder class that automatically increments and decrements the piece_refcount
				--pe-&gt;piece_refcount;
				m_disk_cache.maybe_free_piece(pe);
				j-&gt;error.ec = errors::no_memory;
				j-&gt;error.operation = storage_error::alloc_cache_piece;
				return -1;
			}

			DLOG("do_cache_piece: reading (piece: %d block: %d)\n"
				, int(pe-&gt;piece), i);

			time_point start_time = clock_type::now();

			ret = j-&gt;storage-&gt;get_storage_impl()-&gt;readv(&amp;iov, 1, j-&gt;piece
				, offset, file_flags, j-&gt;error);

			if (ret &lt; 0)
			{
				l.lock();
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(151)">../src/http_tracker_connection.cpp:184</a></td><td>support this somehow</td></tr><tr id="151" style="display: none;" colspan="3"><td colspan="3"><h2>support this somehow</h2><h4>../src/http_tracker_connection.cpp:184</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				url += escape_string(id.c_str(), id.length());
			}

#if TORRENT_USE_I2P
			if (i2p &amp;&amp; tracker_req().i2pconn)
			{
				url += "&amp;ip=";
				url += escape_string(tracker_req().i2pconn-&gt;local_endpoint().c_str()
					, tracker_req().i2pconn-&gt;local_endpoint().size());
				url += ".i2p";
			}
			else
#endif
			if (!settings.get_bool(settings_pack::anonymous_mode))
			{
				std::string announce_ip = settings.get_str(settings_pack::announce_ip);
				if (!announce_ip.empty())
				{
					url += "&amp;ip=" + escape_string(announce_ip.c_str(), announce_ip.size());
				}
<div style="background: #ffff00" width="100%">/*				else if (settings.get_bool(settings_pack::announce_double_nat)
</div>					&amp;&amp; is_local(m_ses.listen_address()))
				{
					// only use the global external listen address here
					// if it turned out to be on a local network
					// since otherwise the tracker should use our
					// source IP to determine our origin
					url += "&amp;ip=" + print_address(m_ses.listen_address());
				}
*/
			}
		}

		m_tracker_connection.reset(new http_connection(get_io_service(), m_man.host_resolver()
			, boost::bind(&amp;http_tracker_connection::on_response, shared_from_this(), _1, _2, _3, _4)
			, true, settings.get_int(settings_pack::max_http_recv_buffer_size)
			, boost::bind(&amp;http_tracker_connection::on_connect, shared_from_this(), _1)
			, boost::bind(&amp;http_tracker_connection::on_filter, shared_from_this(), _1, _2)
#ifdef TORRENT_USE_OPENSSL
			, tracker_req().ssl_ctx
#endif
			));

		int timeout = tracker_req().event==tracker_request::stopped
			?settings.get_int(settings_pack::stop_tracker_timeout)
			:settings.get_int(settings_pack::tracker_completion_timeout);

		// when sending stopped requests, prefer the cached DNS entry
		// to avoid being blocked for slow or failing responses. Chances
		// are that we're shutting down, and this should be a best-effort
		// attempt. It's not worth stalling shutdown.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(152)">../src/metadata_transfer.cpp:356</a></td><td>this is not safe. The torrent could be unloaded while we're still sending the metadata</td></tr><tr id="152" style="display: none;" colspan="3"><td colspan="3"><h2>this is not safe. The torrent could be unloaded while
we're still sending the metadata</h2><h4>../src/metadata_transfer.cpp:356</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">					= req_to_offset(req, (int)m_tp.metadata().left());

				char msg[15];
				char* ptr = msg;

#ifndef TORRENT_DISABLE_LOGGING
				m_pc.peer_log(peer_log_alert::outgoing_message, "METADATA"
					, "start: %d total_size: %d offset: %d data_size: %d"
					, req.first, req.second, offset.first, offset.second);
#endif
				// yes, we have metadata, send it
				detail::write_uint32(11 + offset.second, ptr);
				detail::write_uint8(bt_peer_connection::msg_extended, ptr);
				detail::write_uint8(m_message_index, ptr);
				// means 'data packet'
				detail::write_uint8(1, ptr);
				detail::write_uint32((int)m_tp.metadata().left(), ptr);
				detail::write_uint32(offset.first, ptr);
				m_pc.send_buffer(msg, sizeof(msg));

<div style="background: #ffff00" width="100%">				char const* metadata = m_tp.metadata().begin;
</div>				m_pc.append_const_send_buffer(metadata + offset.first, offset.second);
			}
			else
			{
#ifndef TORRENT_DISABLE_LOGGING
				m_pc.peer_log(peer_log_alert::outgoing_message, "METADATA"
					, "don't have metadata");
#endif
				char msg[4+3];
				char* ptr = msg;

				// we don't have the metadata, reply with
				// don't have-message
				detail::write_uint32(1 + 2, ptr);
				detail::write_uint8(bt_peer_connection::msg_extended, ptr);
				detail::write_uint8(m_message_index, ptr);
				// means 'have no data'
				detail::write_uint8(2, ptr);
				m_pc.send_buffer(msg, sizeof(msg));
			}
			m_pc.setup_send();
		}

		virtual bool on_extended(int length
			, int msg, buffer::const_interval body)
		{
			if (msg != 14) return false;
			if (m_message_index == 0) return false;

			if (length &gt; 500 * 1024)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(153)">../src/packet_buffer.cpp:176</a></td><td>use compare_less_wrap for this comparison as well</td></tr><tr id="153" style="display: none;" colspan="3"><td colspan="3"><h2>use compare_less_wrap for this comparison as well</h2><h4>../src/packet_buffer.cpp:176</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		while (new_size &lt; size)
			new_size &lt;&lt;= 1;

		void** new_storage = (void**)malloc(sizeof(void*) * new_size);

		for (index_type i = 0; i &lt; new_size; ++i)
			new_storage[i] = 0;

		for (index_type i = m_first; i &lt; (m_first + m_capacity); ++i)
			new_storage[i &amp; (new_size - 1)] = m_storage[i &amp; (m_capacity - 1)];

		free(m_storage);

		m_storage = new_storage;
		m_capacity = new_size;
	}

	void* packet_buffer::remove(index_type idx)
	{
		INVARIANT_CHECK;
<div style="background: #ffff00" width="100%">		if (idx &gt;= m_first + m_capacity)
</div>			return 0;

		if (compare_less_wrap(idx, m_first, 0xffff))
			return 0;

		const int mask = (m_capacity - 1);
		void* old_value = m_storage[idx &amp; mask];
		m_storage[idx &amp; mask] = 0;

		if (old_value)
		{
			--m_size;
			if (m_size == 0) m_last = m_first;
		}

		if (idx == m_first &amp;&amp; m_size != 0)
		{
			++m_first;
			for (boost::uint32_t i = 0; i &lt; m_capacity; ++i, ++m_first)
				if (m_storage[m_first &amp; mask]) break;
			m_first &amp;= 0xffff;
		}

		if (((idx + 1) &amp; 0xffff) == m_last &amp;&amp; m_size != 0)
		{
			--m_last;
			for (boost::uint32_t i = 0; i &lt; m_capacity; ++i, --m_last)
				if (m_storage[m_last &amp; mask]) break;
			++m_last;
			m_last &amp;= 0xffff;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(154)">../src/part_file.cpp:252</a></td><td>what do we do if someone is currently reading from the disk from this piece? does it matter? Since we won't actively erase the data from disk, but it may be overwritten soon, it's probably not that big of a deal</td></tr><tr id="154" style="display: none;" colspan="3"><td colspan="3"><h2>what do we do if someone is currently reading from the disk
from this piece? does it matter? Since we won't actively erase the
data from disk, but it may be overwritten soon, it's probably not that
big of a deal</h2><h4>../src/part_file.cpp:252</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (((mode &amp; file::rw_mask) != file::read_only)
			&amp;&amp; ec == boost::system::errc::no_such_file_or_directory)
		{
			// this means the directory the file is in doesn't exist.
			// so create it
			ec.clear();
			create_directories(m_path, ec);

			if (ec) return;
			m_file.open(fn, mode, ec);
		}
	}

	void part_file::free_piece(int piece, error_code&amp; ec)
	{
		mutex::scoped_lock l(m_mutex);

		boost::unordered_map&lt;int, int&gt;::iterator i = m_piece_map.find(piece);
		if (i == m_piece_map.end()) return;

<div style="background: #ffff00" width="100%">
</div>		m_free_slots.push_back(i-&gt;second);
		m_piece_map.erase(i);
		m_dirty_metadata = true;
	}

	void part_file::move_partfile(std::string const&amp; path, error_code&amp; ec)
	{
		mutex::scoped_lock l(m_mutex);

		flush_metadata_impl(ec);
		if (ec) return;

		m_file.close();

		if (!m_piece_map.empty())
		{
			std::string old_path = combine_path(m_path, m_name);
			std::string new_path = combine_path(path, m_name);

			rename(old_path, new_path, ec);
			if (ec == boost::system::errc::no_such_file_or_directory)
				ec.clear();

			if (ec)
			{
				copy_file(old_path, new_path, ec);
				if (ec) return;
				remove(old_path, ec);
			}
		}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(155)">../src/part_file.cpp:350</a></td><td>instead of rebuilding the whole file header and flushing it, update the slot entries as we go</td></tr><tr id="155" style="display: none;" colspan="3"><td colspan="3"><h2>instead of rebuilding the whole file header
and flushing it, update the slot entries as we go</h2><h4>../src/part_file.cpp:350</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				if (block_to_copy == m_piece_size)
				{
					m_free_slots.push_back(i-&gt;second);
					m_piece_map.erase(i);
					m_dirty_metadata = true;
				}
			}
			file_offset += block_to_copy;
			piece_offset = 0;
			size -= block_to_copy;
		}
	}

	void part_file::flush_metadata(error_code&amp; ec)
	{
		mutex::scoped_lock l(m_mutex);

		flush_metadata_impl(ec);
	}

<div style="background: #ffff00" width="100%">	void part_file::flush_metadata_impl(error_code&amp; ec)
</div>	{
		// do we need to flush the metadata?
		if (m_dirty_metadata == false) return;

		if (m_piece_map.empty())
		{
			m_file.close();

			// if we don't have any pieces left in the
			// part file, remove it
			std::string p = combine_path(m_path, m_name);
			remove(p, ec);
		
			if (ec == boost::system::errc::no_such_file_or_directory)
				ec.clear();
			return;
		}

		open_file(file::read_write, ec);
		if (ec) return;

		boost::scoped_array&lt;boost::uint32_t&gt; header(new boost::uint32_t[m_header_size]);

		using namespace libtorrent::detail;

		char* ptr = (char*)header.get();

		write_uint32(m_max_pieces, ptr);
		write_uint32(m_piece_size, ptr);

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(156)">../src/peer_connection.cpp:511</a></td><td>it would be neat to be able to print this straight into the alert's stack allocator</td></tr><tr id="156" style="display: none;" colspan="3"><td colspan="3"><h2>it would be neat to be able to print this straight into the
alert's stack allocator</h2><h4>../src/peer_connection.cpp:511</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		TORRENT_ASSERT(in_handshake() || is_interesting() == interested);

		disconnect_if_redundant();
	}

#ifndef TORRENT_DISABLE_LOGGING
#if defined __GNUC__ || defined __clang__
	__attribute__((format(printf, 4, 5)))
#endif
	void peer_connection::peer_log(peer_log_alert::direction_t direction
		, char const* event, char const* fmt, ...) const
	{
		TORRENT_ASSERT(is_single_thread());

		if (!m_ses.alerts().should_post&lt;peer_log_alert&gt;()) return;

		va_list v;
		va_start(v, fmt);

<div style="background: #ffff00" width="100%">		char buf[512];
</div>		vsnprintf(buf, sizeof(buf), fmt, v);
		va_end(v);

		torrent_handle h;
		boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		if (t) h = t-&gt;get_handle();

		m_ses.alerts().emplace_alert&lt;peer_log_alert&gt;(
			h, m_remote, m_peer_id, direction, event, buf);
	}
#endif

#ifndef TORRENT_DISABLE_EXTENSIONS
	void peer_connection::add_extension(boost::shared_ptr&lt;peer_plugin&gt; ext)
	{
		TORRENT_ASSERT(is_single_thread());
		m_extensions.push_back(ext);
	}

	peer_plugin const* peer_connection::find_plugin(char const* type)
	{
		TORRENT_ASSERT(is_single_thread());
		for (extension_list_t::iterator i = m_extensions.begin()
			, end(m_extensions.end()); i != end; ++i)
		{
			if (strcmp((*i)-&gt;type(), type) == 0) return (*i).get();
		}
		return 0;
	}
#endif
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(157)">../src/peer_connection.cpp:1011</a></td><td>this should be the global download rate</td></tr><tr id="157" style="display: none;" colspan="3"><td colspan="3"><h2>this should be the global download rate</h2><h4>../src/peer_connection.cpp:1011</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		int rate = 0;

		// if we haven't received any data recently, the current download rate
		// is not representative
		if (aux::time_now() - m_last_piece &gt; seconds(30) &amp;&amp; m_download_rate_peak &gt; 0)
		{
			rate = m_download_rate_peak;
		}
		else if (aux::time_now() - m_last_unchoked &lt; seconds(5)
			&amp;&amp; m_statistics.total_payload_upload() &lt; 2 * 0x4000)
		{
			// if we're have only been unchoked for a short period of time,
			// we don't know what rate we can get from this peer. Instead of assuming
			// the lowest possible rate, assume the average.

			int peers_with_requests = stats_counters()[counters::num_peers_down_requests];
			// avoid division by 0
			if (peers_with_requests == 0) peers_with_requests = 1;

<div style="background: #ffff00" width="100%">			rate = t-&gt;statistics().transfer_rate(stat::download_payload) / peers_with_requests;
</div>		}
		else
		{
			// current download rate in bytes per seconds
			rate = m_statistics.transfer_rate(stat::download_payload);
		}

		// avoid division by zero
		if (rate &lt; 50) rate = 50;

		// average of current rate and peak
//		rate = (rate + m_download_rate_peak) / 2;

		return milliseconds((m_outstanding_bytes
			+ m_queued_time_critical * t-&gt;block_size() * 1000) / rate);
	}

	void peer_connection::add_stat(boost::int64_t downloaded, boost::int64_t uploaded)
	{
		TORRENT_ASSERT(is_single_thread());
		m_statistics.add_stat(downloaded, uploaded);
	}

	void peer_connection::received_bytes(int bytes_payload, int bytes_protocol)
	{
		TORRENT_ASSERT(is_single_thread());
		m_statistics.received_bytes(bytes_payload, bytes_protocol);
		if (m_ignore_stats) return;
		boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		if (!t) return;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(158)">../src/peer_connection.cpp:3284</a></td><td>sort the allowed fast set in priority order</td></tr><tr id="158" style="display: none;" colspan="3"><td colspan="3"><h2>sort the allowed fast set in priority order</h2><h4>../src/peer_connection.cpp:3284</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// if the peer has the piece and we want
		// to download it, request it
		if (int(m_have_piece.size()) &gt; index
			&amp;&amp; m_have_piece[index]
			&amp;&amp; !t-&gt;has_piece_passed(index)
			&amp;&amp; t-&gt;valid_metadata()
			&amp;&amp; t-&gt;has_picker()
			&amp;&amp; t-&gt;picker().piece_priority(index) &gt; 0)
		{
			t-&gt;peer_is_interesting(*this);
		}
	}

	std::vector&lt;int&gt; const&amp; peer_connection::allowed_fast()
	{
		TORRENT_ASSERT(is_single_thread());
		boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		TORRENT_ASSERT(t);

<div style="background: #ffff00" width="100%">		return m_allowed_fast;
</div>	}

	bool peer_connection::can_request_time_critical() const
	{
		TORRENT_ASSERT(is_single_thread());
		if (has_peer_choked() || !is_interesting()) return false;
		if ((int)m_download_queue.size() + (int)m_request_queue.size()
			&gt; m_desired_queue_size * 2) return false;
		if (on_parole()) return false; 
		if (m_disconnecting) return false;
		boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		TORRENT_ASSERT(t);
		if (t-&gt;upload_mode()) return false;

		// ignore snubbed peers, since they're not likely to return pieces in a
		// timely manner anyway
		if (m_snubbed) return false;
		return true;
	}

	bool peer_connection::make_time_critical(piece_block const&amp; block)
	{
		TORRENT_ASSERT(is_single_thread());
		std::vector&lt;pending_block&gt;::iterator rit = std::find_if(m_request_queue.begin()
			, m_request_queue.end(), has_block(block));
		if (rit == m_request_queue.end()) return false;
#if TORRENT_USE_ASSERTS
		boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		TORRENT_ASSERT(t);
		TORRENT_ASSERT(t-&gt;has_picker());
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(159)">../src/peer_connection.cpp:6050</a></td><td>The stats checks can not be honored when authenticated encryption is in use because we may have encrypted data which we cannot authenticate yet</td></tr><tr id="159" style="display: none;" colspan="3"><td colspan="3"><h2>The stats checks can not be honored when authenticated encryption is in use
because we may have encrypted data which we cannot authenticate yet</h2><h4>../src/peer_connection.cpp:6050</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			peer_log(peer_log_alert::incoming, "READ"
				, "%d bytes", int(bytes_transferred));
#endif
			// correct the dl quota usage, if not all of the buffer was actually read
			TORRENT_ASSERT(int(bytes_transferred) &lt;= m_quota[download_channel]);
			m_quota[download_channel] -= bytes_transferred;

			if (m_disconnecting)
			{
				trancieve_ip_packet(bytes_in_loop, m_remote.address().is_v6());
				return;
			}
	
			TORRENT_ASSERT(bytes_transferred &gt; 0);
			m_recv_buffer.received(bytes_transferred);

			int bytes = bytes_transferred;
			int sub_transferred = 0;
			do {
				INVARIANT_CHECK;
<div style="background: #ffff00" width="100%">#if 0
</div>				boost::int64_t cur_payload_dl = m_statistics.last_payload_downloaded();
				boost::int64_t cur_protocol_dl = m_statistics.last_protocol_downloaded();
#endif
				sub_transferred = m_recv_buffer.advance_pos(bytes);
				on_receive(error, sub_transferred);
				bytes -= sub_transferred;
				TORRENT_ASSERT(sub_transferred &gt; 0);

#if 0
				TORRENT_ASSERT(m_statistics.last_payload_downloaded() - cur_payload_dl &gt;= 0);
				TORRENT_ASSERT(m_statistics.last_protocol_downloaded() - cur_protocol_dl &gt;= 0);
				boost::int64_t stats_diff = m_statistics.last_payload_downloaded() - cur_payload_dl +
					m_statistics.last_protocol_downloaded() - cur_protocol_dl;
				TORRENT_ASSERT(stats_diff == int(sub_transferred));
#endif
			if (m_disconnecting) return;

			} while (bytes &gt; 0 &amp;&amp; sub_transferred &gt; 0);

			m_recv_buffer.normalize();

			TORRENT_ASSERT(m_recv_buffer.pos_at_end());
			TORRENT_ASSERT(m_recv_buffer.packet_size() &gt; 0);

			if (m_peer_choked)
			{
				m_recv_buffer.clamp_size();
			}

			if (num_loops &gt; read_loops) break;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(160)">../src/piece_picker.cpp:2070</a></td><td>this could probably be optimized by incrementally calling partial_sort to sort one more element in the list. Because chances are that we'll just need a single piece, and once we've picked from it we're done. Sorting the rest of the list in that case is a waste of time.</td></tr><tr id="160" style="display: none;" colspan="3"><td colspan="3"><h2>this could probably be optimized by incrementally
calling partial_sort to sort one more element in the list. Because
chances are that we'll just need a single piece, and once we've
picked from it we're done. Sorting the rest of the list in that
case is a waste of time.</h2><h4>../src/piece_picker.cpp:2070</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				, end(m_downloads[piece_pos::piece_downloading].end()); i != end; ++i)
			{
				pc.inc_stats_counter(counters::piece_picker_partial_loops);

				// in time critical mode, only pick high priority pieces
				if ((options &amp; time_critical_mode)
					&amp;&amp; piece_priority(i-&gt;index) != priority_levels - 1)
					continue;

				if (!is_piece_free(i-&gt;index, pieces)) continue;

				TORRENT_ASSERT(m_piece_map[i-&gt;index].download_queue()
					== piece_pos::piece_downloading);

				ordered_partials[num_ordered_partials++] = &amp;*i;
			}

			// now, sort the list.
			if (options &amp; rarest_first)
			{
<div style="background: #ffff00" width="100%">				std::sort(ordered_partials, ordered_partials + num_ordered_partials
</div>					, boost::bind(&amp;piece_picker::partial_compare_rarest_first, this
						, _1, _2));
			}

			for (int i = 0; i &lt; num_ordered_partials; ++i)
			{
				num_blocks = add_blocks_downloading(*ordered_partials[i], pieces
					, interesting_blocks, backup_blocks, backup_blocks2
					, num_blocks, prefer_contiguous_blocks, peer, options);
				if (num_blocks &lt;= 0) return;
				if (int(backup_blocks.size()) &gt;= num_blocks
					&amp;&amp; int(backup_blocks2.size()) &gt;= num_blocks)
					break;
			}

			num_blocks = append_blocks(interesting_blocks, backup_blocks
				, num_blocks);
			if (num_blocks &lt;= 0) return;

			num_blocks = append_blocks(interesting_blocks, backup_blocks2
				, num_blocks);
			if (num_blocks &lt;= 0) return;
		}

		if (!suggested_pieces.empty())
		{
			for (std::vector&lt;int&gt;::const_iterator i = suggested_pieces.begin();
				i != suggested_pieces.end(); ++i)
			{
				// in time critical mode, only pick high priority pieces
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(161)">../src/piece_picker.cpp:2575</a></td><td>when expanding pieces for cache stripe reasons, the !downloading condition doesn't make much sense</td></tr><tr id="161" style="display: none;" colspan="3"><td colspan="3"><h2>when expanding pieces for cache stripe reasons,
the !downloading condition doesn't make much sense</h2><h4>../src/piece_picker.cpp:2575</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		TORRENT_ASSERT(index &lt; (int)m_piece_map.size() || m_piece_map.empty());
		if (index+1 == (int)m_piece_map.size())
			return m_blocks_in_last_piece;
		else
			return m_blocks_per_piece;
	}

	bool piece_picker::is_piece_free(int piece, bitfield const&amp; bitmask) const
	{
		TORRENT_ASSERT(piece &gt;= 0 &amp;&amp; piece &lt; int(m_piece_map.size()));
		return bitmask[piece]
			&amp;&amp; !m_piece_map[piece].have()
			&amp;&amp; !m_piece_map[piece].filtered();
	}

	bool piece_picker::can_pick(int piece, bitfield const&amp; bitmask) const
	{
		TORRENT_ASSERT(piece &gt;= 0 &amp;&amp; piece &lt; int(m_piece_map.size()));
		return bitmask[piece]
			&amp;&amp; !m_piece_map[piece].have()
<div style="background: #ffff00" width="100%">			&amp;&amp; !m_piece_map[piece].downloading()
</div>			&amp;&amp; !m_piece_map[piece].filtered();
	}

#if TORRENT_USE_INVARIANT_CHECKS
	void piece_picker::check_peers()
	{
		for (std::vector&lt;block_info&gt;::iterator i = m_block_info.begin()
			, end(m_block_info.end()); i != end; ++i)
		{
			TORRENT_ASSERT(i-&gt;peer == 0 || static_cast&lt;torrent_peer*&gt;(i-&gt;peer)-&gt;in_use);
		}
	}
#endif

	void piece_picker::clear_peer(void* peer)
	{
		for (std::vector&lt;block_info&gt;::iterator i = m_block_info.begin()
			, end(m_block_info.end()); i != end; ++i)
		{
			if (i-&gt;peer == peer) i-&gt;peer = 0;
		}
	}

	// the first bool is true if this is the only peer that has requested and downloaded
	// blocks from this piece.
	// the second bool is true if this is the only active peer that is requesting
	// and downloading blocks from this piece. Active means having a connection.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(162)">../src/session_impl.cpp:504</a></td><td>there's no rule here to make uTP connections not have the global or local rate limits apply to it. This used to be the default.</td></tr><tr id="162" style="display: none;" colspan="3"><td colspan="3"><h2>there's no rule here to make uTP connections not have the global or
local rate limits apply to it. This used to be the default.</h2><h4>../src/session_impl.cpp:504</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		m_global_class = m_classes.new_peer_class("global");
		m_tcp_peer_class = m_classes.new_peer_class("tcp");
		m_local_peer_class = m_classes.new_peer_class("local");
		// local peers are always unchoked
		m_classes.at(m_local_peer_class)-&gt;ignore_unchoke_slots = true;
		// local peers are allowed to exceed the normal connection
		// limit by 50%
		m_classes.at(m_local_peer_class)-&gt;connection_limit_factor = 150;

		TORRENT_ASSERT(m_global_class == session::global_peer_class_id);
		TORRENT_ASSERT(m_tcp_peer_class == session::tcp_peer_class_id);
		TORRENT_ASSERT(m_local_peer_class == session::local_peer_class_id);

		init_peer_class_filter(true);

		// TCP, SSL/TCP and I2P connections should be assigned the TCP peer class
		m_peer_class_type_filter.add(peer_class_type_filter::tcp_socket, m_tcp_peer_class);
		m_peer_class_type_filter.add(peer_class_type_filter::ssl_tcp_socket, m_tcp_peer_class);
		m_peer_class_type_filter.add(peer_class_type_filter::i2p_socket, m_tcp_peer_class);

<div style="background: #ffff00" width="100%">
</div>#ifndef TORRENT_DISABLE_LOGGING

		session_log("config: %s\n"
			"version: %s\n"
			"revision: %s\n\n"
		  	, TORRENT_CFG_STRING
			, LIBTORRENT_VERSION
			, LIBTORRENT_REVISION);

#endif // TORRENT_DISABLE_LOGGING

#if TORRENT_USE_RLIMIT
		// ---- auto-cap max connections ----

		struct rlimit rl;
		if (getrlimit(RLIMIT_NOFILE, &amp;rl) == 0)
		{
#ifndef TORRENT_DISABLE_LOGGING
			session_log(" max number of open files: %d", int(rl.rlim_cur));
#endif
			// deduct some margin for epoll/kqueue, log files,
			// futexes, shared objects etc.
			rl.rlim_cur -= 20;

			// 80% of the available file descriptors should go to connections
			m_settings.set_int(settings_pack::connections_limit, (std::min)(
				m_settings.get_int(settings_pack::connections_limit)
				, int(rl.rlim_cur * 8 / 10)));
			// 20% goes towards regular files (see disk_io_thread)
#ifndef TORRENT_DISABLE_LOGGING
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(163)">../src/session_impl.cpp:1731</a></td><td>instead of having a special case for this, just make the default listen interfaces be "0.0.0.0:6881,[::1]:6881" and use the generic path. That would even allow for not listening at all.</td></tr><tr id="163" style="display: none;" colspan="3"><td colspan="3"><h2>instead of having a special case for this, just make the
default listen interfaces be "0.0.0.0:6881,[::1]:6881" and use
the generic path. That would even allow for not listening at all.</h2><h4>../src/session_impl.cpp:1731</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// reset the retry counter
		m_listen_port_retries = m_settings.get_int(settings_pack::max_retry_port_bind);

retry:

		// close the open listen sockets
		// close the listen sockets
		for (std::list&lt;listen_socket_t&gt;::iterator i = m_listen_sockets.begin()
			, end(m_listen_sockets.end()); i != end; ++i)
			i-&gt;sock-&gt;close(ec);
		m_listen_sockets.clear();
		m_stats_counters.set_value(counters::has_incoming_connections, 0);
		ec.clear();

		if (m_abort) return;

		m_ipv6_interface = tcp::endpoint();
		m_ipv4_interface = tcp::endpoint();

<div style="background: #ffff00" width="100%">		if (m_listen_interfaces.empty())
</div>		{
			// this means we should open two listen sockets
			// one for IPv4 and one for IPv6
		
			listen_socket_t s = setup_listener("0.0.0.0", true
				, m_listen_interface.port()
				, m_listen_port_retries, flags, ec);

			if (s.sock)
			{
				// update the listen_interface member with the
				// actual port we ended up listening on, so that the other
				// sockets can be bound to the same one
				m_listen_interface.port(s.external_port);

				TORRENT_ASSERT(!m_abort);
				m_listen_sockets.push_back(s);
			}

#ifdef TORRENT_USE_OPENSSL
			if (m_settings.get_int(settings_pack::ssl_listen))
			{
				int retries = 10;
				listen_socket_t s = setup_listener("0.0.0.0", true
					, m_settings.get_int(settings_pack::ssl_listen)
					, retries, flags | open_ssl_socket, ec);

				if (s.sock)
				{
					TORRENT_ASSERT(!m_abort);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(164)">../src/session_impl.cpp:2624</a></td><td>should this function take a shared_ptr instead?</td></tr><tr id="164" style="display: none;" colspan="3"><td colspan="3"><h2>should this function take a shared_ptr instead?</h2><h4>../src/session_impl.cpp:2624</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{
#if defined TORRENT_ASIO_DEBUGGING
		complete_async("session_impl::on_socks_accept");
#endif
		m_socks_listen_socket.reset();
		if (e == asio::error::operation_aborted) return;
		if (e)
		{
			if (m_alerts.should_post&lt;listen_failed_alert&gt;())
				m_alerts.emplace_alert&lt;listen_failed_alert&gt;("socks5", listen_failed_alert::accept, e
						, listen_failed_alert::socks5);
			return;
		}
		open_new_incoming_socks_connection();
		incoming_connection(s);
	}

	// if cancel_with_cq is set, the peer connection is
	// currently expected to be scheduled for a connection
	// with the connection queue, and should be cancelled
<div style="background: #ffff00" width="100%">	void session_impl::close_connection(peer_connection* p
</div>		, error_code const&amp; ec)
	{
		TORRENT_ASSERT(is_single_thread());
		boost::shared_ptr&lt;peer_connection&gt; sp(p-&gt;self());

		// someone else is holding a reference, it's important that
		// it's destructed from the network thread. Make sure the
		// last reference is held by the network thread.
		if (!sp.unique())
			m_undead_peers.push_back(sp);

// too expensive
//		INVARIANT_CHECK;

#ifdef TORRENT_DEBUG
//		for (aux::session_impl::torrent_map::const_iterator i = m_torrents.begin()
//			, end(m_torrents.end()); i != end; ++i)
//			TORRENT_ASSERT(!i-&gt;second-&gt;has_peer((peer_connection*)p));
#endif

#ifndef TORRENT_DISABLE_LOGGING
		session_log(" CLOSING CONNECTION %s : %s"
			, print_endpoint(p-&gt;remote()).c_str(), ec.message().c_str());
#endif

		TORRENT_ASSERT(p-&gt;is_disconnecting());

		TORRENT_ASSERT(sp.use_count() &gt; 0);

		connection_map::iterator i = m_connections.find(sp);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(165)">../src/session_impl.cpp:2983</a></td><td>have a separate list for these connections, instead of having to loop through all of them</td></tr><tr id="165" style="display: none;" colspan="3"><td colspan="3"><h2>have a separate list for these connections, instead of having to loop through all of them</h2><h4>../src/session_impl.cpp:2983</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (m_auto_manage_time_scaler &lt; 0)
		{
			INVARIANT_CHECK;
			m_auto_manage_time_scaler = settings().get_int(settings_pack::auto_manage_interval);
			recalculate_auto_managed_torrents();
		}

		// --------------------------------------------------------------
		// check for incoming connections that might have timed out
		// --------------------------------------------------------------

		for (connection_map::iterator i = m_connections.begin();
			i != m_connections.end();)
		{
			peer_connection* p = (*i).get();
			++i;
			// ignore connections that already have a torrent, since they
			// are ticked through the torrents' second_tick
			if (!p-&gt;associated_torrent().expired()) continue;

<div style="background: #ffff00" width="100%">			if (m_last_tick - p-&gt;connected_time()
</div>				&gt; seconds(m_settings.get_int(settings_pack::handshake_timeout)))
				p-&gt;disconnect(errors::timed_out, op_bittorrent);
		}

		// --------------------------------------------------------------
		// second_tick every torrent (that wants it)
		// --------------------------------------------------------------

#if TORRENT_DEBUG_STREAMING &gt; 0
		printf("\033[2J\033[0;0H");
#endif

		std::vector&lt;torrent*&gt;&amp; want_tick = m_torrent_lists[torrent_want_tick];
		for (int i = 0; i &lt; int(want_tick.size()); ++i)
		{
			torrent&amp; t = *want_tick[i];
			TORRENT_ASSERT(t.want_tick());
			TORRENT_ASSERT(!t.is_aborted());

			t.second_tick(tick_interval_ms, m_tick_residual / 1000);

			// if the call to second_tick caused the torrent
			// to no longer want to be ticked (i.e. it was
			// removed from the list) we need to back up the counter
			// to not miss the torrent after it
			if (!t.want_tick()) --i;
		}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(166)">../src/session_impl.cpp:3013</a></td><td>this should apply to all bandwidth channels</td></tr><tr id="166" style="display: none;" colspan="3"><td colspan="3"><h2>this should apply to all bandwidth channels</h2><h4>../src/session_impl.cpp:3013</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#if TORRENT_DEBUG_STREAMING &gt; 0
		printf("\033[2J\033[0;0H");
#endif

		std::vector&lt;torrent*&gt;&amp; want_tick = m_torrent_lists[torrent_want_tick];
		for (int i = 0; i &lt; int(want_tick.size()); ++i)
		{
			torrent&amp; t = *want_tick[i];
			TORRENT_ASSERT(t.want_tick());
			TORRENT_ASSERT(!t.is_aborted());

			t.second_tick(tick_interval_ms, m_tick_residual / 1000);

			// if the call to second_tick caused the torrent
			// to no longer want to be ticked (i.e. it was
			// removed from the list) we need to back up the counter
			// to not miss the torrent after it
			if (!t.want_tick()) --i;
		}

<div style="background: #ffff00" width="100%">		if (m_settings.get_bool(settings_pack::rate_limit_ip_overhead))
</div>		{
			int up_limit = upload_rate_limit(m_global_class);
			int down_limit = download_rate_limit(m_global_class);

			if (down_limit &gt; 0
				&amp;&amp; m_stat.download_ip_overhead() &gt;= down_limit
				&amp;&amp; m_alerts.should_post&lt;performance_alert&gt;())
			{
				m_alerts.emplace_alert&lt;performance_alert&gt;(torrent_handle()
					, performance_alert::download_limit_too_low);
			}

			if (up_limit &gt; 0
				&amp;&amp; m_stat.upload_ip_overhead() &gt;= up_limit
				&amp;&amp; m_alerts.should_post&lt;performance_alert&gt;())
			{
				m_alerts.emplace_alert&lt;performance_alert&gt;(torrent_handle()
					, performance_alert::upload_limit_too_low);
			}
		}

		m_peak_up_rate = (std::max)(m_stat.upload_rate(), m_peak_up_rate);
		m_peak_down_rate = (std::max)(m_stat.download_rate(), m_peak_down_rate);
	
		m_stat.second_tick(tick_interval_ms);

		// --------------------------------------------------------------
		// scrape paused torrents that are auto managed
		// (unless the session is paused)
		// --------------------------------------------------------------
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(167)">../src/session_impl.cpp:3500</a></td><td>these vectors could be copied from m_torrent_lists, if we would maintain them. That way the first pass over all torrents could be avoided. It would be especially efficient if most torrents are not auto-managed whenever we receive a scrape response (or anything that may change the rank of a torrent) that one torrent could re-sort itself in a list that's kept sorted at all times. That way, this pass over all torrents could be avoided alltogether.</td></tr><tr id="167" style="display: none;" colspan="3"><td colspan="3"><h2>these vectors could be copied from m_torrent_lists,
if we would maintain them. That way the first pass over
all torrents could be avoided. It would be especially
efficient if most torrents are not auto-managed
whenever we receive a scrape response (or anything
that may change the rank of a torrent) that one torrent
could re-sort itself in a list that's kept sorted at all
times. That way, this pass over all torrents could be
avoided alltogether.</h2><h4>../src/session_impl.cpp:3500</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				if (t-&gt;allows_peers())
					t-&gt;log_to_all_peers("auto manager pausing torrent");
#endif
				// use graceful pause for auto-managed torrents
				t-&gt;set_allow_peers(false, true);
			}
		}
	}

	void session_impl::recalculate_auto_managed_torrents()
	{
		INVARIANT_CHECK;

		m_last_auto_manage = time_now();
		m_need_auto_manage = false;

		if (is_paused()) return;

		// these vectors are filled with auto managed torrents

<div style="background: #ffff00" width="100%">		std::vector&lt;torrent*&gt; checking;
</div>		std::vector&lt;torrent*&gt; downloaders;
		downloaders.reserve(m_torrents.size());
		std::vector&lt;torrent*&gt; seeds;
		seeds.reserve(m_torrents.size());

		// these counters are set to the number of torrents
		// of each kind we're allowed to have active
		int num_downloaders = settings().get_int(settings_pack::active_downloads);
		int num_seeds = settings().get_int(settings_pack::active_seeds);
		int checking_limit = 1;
		int dht_limit = settings().get_int(settings_pack::active_dht_limit);
		int tracker_limit = settings().get_int(settings_pack::active_tracker_limit);
		int lsd_limit = settings().get_int(settings_pack::active_lsd_limit);
		int hard_limit = settings().get_int(settings_pack::active_limit);

		if (num_downloaders == -1)
			num_downloaders = (std::numeric_limits&lt;int&gt;::max)();
		if (num_seeds == -1)
			num_seeds = (std::numeric_limits&lt;int&gt;::max)();
		if (hard_limit == -1)
			hard_limit = (std::numeric_limits&lt;int&gt;::max)();
		if (dht_limit == -1)
			dht_limit = (std::numeric_limits&lt;int&gt;::max)();
		if (lsd_limit == -1)
			lsd_limit = (std::numeric_limits&lt;int&gt;::max)();
		if (tracker_limit == -1)
			tracker_limit = (std::numeric_limits&lt;int&gt;::max)();
            
		for (torrent_map::iterator i = m_torrents.begin()
			, end(m_torrents.end()); i != end; ++i)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(168)">../src/session_impl.cpp:3577</a></td><td>allow extensions to sort torrents for queuing</td></tr><tr id="168" style="display: none;" colspan="3"><td colspan="3"><h2>allow extensions to sort torrents for queuing</h2><h4>../src/session_impl.cpp:3577</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				if (t-&gt;is_finished())
					seeds.push_back(t);
				else
					downloaders.push_back(t);
			}
			else if (!t-&gt;is_paused())
			{
				if (t-&gt;state() == torrent_status::checking_files)
				{
					if (checking_limit &gt; 0) --checking_limit;
					continue;
				}
				TORRENT_ASSERT(t-&gt;m_resume_data_loaded || !t-&gt;valid_metadata());
				--hard_limit;
			}
		}

		bool handled_by_extension = false;

#ifndef TORRENT_DISABLE_EXTENSIONS
<div style="background: #ffff00" width="100%">#endif
</div>
		if (!handled_by_extension)
		{
			std::sort(checking.begin(), checking.end()
				, boost::bind(&amp;torrent::sequence_number, _1) &lt; boost::bind(&amp;torrent::sequence_number, _2));

			std::sort(downloaders.begin(), downloaders.end()
				, boost::bind(&amp;torrent::sequence_number, _1) &lt; boost::bind(&amp;torrent::sequence_number, _2));

			std::sort(seeds.begin(), seeds.end()
				, boost::bind(&amp;torrent::seed_rank, _1, boost::ref(m_settings))
				&gt; boost::bind(&amp;torrent::seed_rank, _2, boost::ref(m_settings)));
		}

		auto_manage_torrents(checking, checking_limit, dht_limit, tracker_limit, lsd_limit
			, hard_limit, num_downloaders);

		if (settings().get_bool(settings_pack::auto_manage_prefer_seeds))
		{
			auto_manage_torrents(seeds, checking_limit, dht_limit, tracker_limit, lsd_limit
				, hard_limit, num_seeds);
			auto_manage_torrents(downloaders, checking_limit, dht_limit, tracker_limit, lsd_limit
				, hard_limit, num_downloaders);
		}
		else
		{
			auto_manage_torrents(downloaders, checking_limit, dht_limit, tracker_limit, lsd_limit
				, hard_limit, num_downloaders);
			auto_manage_torrents(seeds, checking_limit, dht_limit, tracker_limit, lsd_limit
				, hard_limit, num_seeds);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(169)">../src/session_impl.cpp:3750</a></td><td>use a lower limit than m_settings.connections_limit to allocate the to 10% or so of connection slots for incoming connections</td></tr><tr id="169" style="display: none;" colspan="3"><td colspan="3"><h2>use a lower limit than m_settings.connections_limit
to allocate the to 10% or so of connection slots for incoming
connections</h2><h4>../src/session_impl.cpp:3750</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// robin fashion, so that every torrent is equally likely to connect to a
		// peer

		// boost connections are connections made by torrent connection
		// boost, which are done immediately on a tracker response. These
		// connections needs to be deducted from this second
		if (m_boost_connections &gt; 0)
		{
			if (m_boost_connections &gt; max_connections)
			{
				m_boost_connections -= max_connections;
				max_connections = 0;
			}
			else
			{
				max_connections -= m_boost_connections;
				m_boost_connections = 0;
			}
		}

<div style="background: #ffff00" width="100%">		int limit = m_settings.get_int(settings_pack::connections_limit)
</div>			- num_connections();

		// this logic is here to smooth out the number of new connection
		// attempts over time, to prevent connecting a large number of
		// sockets, wait 10 seconds, and then try again
		if (m_settings.get_bool(settings_pack::smooth_connects) &amp;&amp; max_connections &gt; (limit+1) / 2)
			max_connections = (limit+1) / 2;

		std::vector&lt;torrent*&gt;&amp; want_peers_download = m_torrent_lists[torrent_want_peers_download];
		std::vector&lt;torrent*&gt;&amp; want_peers_finished = m_torrent_lists[torrent_want_peers_finished];

		// if no torrent want any peers, just return
		if (want_peers_download.empty() &amp;&amp; want_peers_finished.empty()) return;

		// if we don't have any connection attempt quota, return
		if (max_connections &lt;= 0) return;

		INVARIANT_CHECK;

		int steps_since_last_connect = 0;
		int num_torrents = int(want_peers_finished.size() + want_peers_download.size());
		for (;;)
		{
			if (m_next_downloading_connect_torrent &gt;= int(want_peers_download.size()))
				m_next_downloading_connect_torrent = 0;

			if (m_next_finished_connect_torrent &gt;= int(want_peers_finished.size()))
				m_next_finished_connect_torrent = 0;

			torrent* t = NULL;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(170)">../src/session_impl.cpp:3893</a></td><td>post a message to have this happen immediately instead of waiting for the next tick</td></tr><tr id="170" style="display: none;" colspan="3"><td colspan="3"><h2>post a message to have this happen
immediately instead of waiting for the next tick</h2><h4>../src/session_impl.cpp:3893</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			torrent* t = p-&gt;associated_torrent().lock().get();
			torrent_peer* pi = p-&gt;peer_info_struct();

			if (p-&gt;ignore_unchoke_slots() || t == 0 || pi == 0
				|| pi-&gt;web_seed || t-&gt;is_paused())
				continue;

			if (!p-&gt;is_peer_interested()
				|| p-&gt;is_disconnecting()
				|| p-&gt;is_connecting())
			{
				// this peer is not unchokable. So, if it's unchoked
				// already, make sure to choke it.
				if (p-&gt;is_choked()) continue;
				if (pi &amp;&amp; pi-&gt;optimistically_unchoked)
				{
					m_stats_counters.inc_stats_counter(counters::num_peers_up_unchoked_optimistic, -1);
					pi-&gt;optimistically_unchoked = false;
					// force a new optimistic unchoke
					m_optimistic_unchoke_time_scaler = 0;
<div style="background: #ffff00" width="100%">				}
</div>				t-&gt;choke_peer(*p);
				continue;
			}

			peers.push_back(p.get());
		}

		// the unchoker wants an estimate of our upload rate capacity
		// (used by bittyrant)
		int max_upload_rate = upload_rate_limit(m_global_class);
		if (m_settings.get_int(settings_pack::choking_algorithm)
			== settings_pack::bittyrant_choker
			&amp;&amp; max_upload_rate == 0)
		{
			// we don't know at what rate we can upload. If we have a
			// measurement of the peak, use that + 10kB/s, otherwise
			// assume 20 kB/s
			max_upload_rate = (std::max)(20000, m_peak_up_rate + 10000);
			if (m_alerts.should_post&lt;performance_alert&gt;())
				m_alerts.emplace_alert&lt;performance_alert&gt;(torrent_handle()
					, performance_alert::bittyrant_with_no_uplimit);
		}

		int allowed_upload_slots = unchoke_sort(peers, max_upload_rate
			, unchoke_interval, m_settings);
		m_stats_counters.set_value(counters::num_unchoke_slots
			, allowed_upload_slots);

		int num_opt_unchoke = m_settings.get_int(settings_pack::num_optimistic_unchoke_slots);
		if (num_opt_unchoke == 0) num_opt_unchoke = (std::max)(1, allowed_upload_slots / 5);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(171)">../src/session_impl.cpp:3940</a></td><td>this should be called for all peers!</td></tr><tr id="171" style="display: none;" colspan="3"><td colspan="3"><h2>this should be called for all peers!</h2><h4>../src/session_impl.cpp:3940</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			, unchoke_interval, m_settings);
		m_stats_counters.set_value(counters::num_unchoke_slots
			, allowed_upload_slots);

		int num_opt_unchoke = m_settings.get_int(settings_pack::num_optimistic_unchoke_slots);
		if (num_opt_unchoke == 0) num_opt_unchoke = (std::max)(1, allowed_upload_slots / 5);

		// reserve some upload slots for optimistic unchokes
		int unchoke_set_size = allowed_upload_slots;

		// go through all the peers and unchoke the first ones and choke
		// all the other ones.
		for (std::vector&lt;peer_connection*&gt;::iterator i = peers.begin()
			, end(peers.end()); i != end; ++i)
		{
			peer_connection* p = *i;
			TORRENT_ASSERT(p);
			TORRENT_ASSERT(!p-&gt;ignore_unchoke_slots());

			// this will update the m_uploaded_at_last_unchoke
<div style="background: #ffff00" width="100%">			p-&gt;reset_choke_counters();
</div>
			torrent* t = p-&gt;associated_torrent().lock().get();
			TORRENT_ASSERT(t);

			if (unchoke_set_size &gt; 0)
			{
				// yes, this peer should be unchoked
				if (p-&gt;is_choked())
				{
					if (!t-&gt;unchoke_peer(*p))
						continue;
				}

				--unchoke_set_size;

				TORRENT_ASSERT(p-&gt;peer_info_struct());
				if (p-&gt;peer_info_struct()-&gt;optimistically_unchoked)
				{
					// force a new optimistic unchoke
					// since this one just got promoted into the
					// proper unchoke set
					m_optimistic_unchoke_time_scaler = 0;
					p-&gt;peer_info_struct()-&gt;optimistically_unchoked = false;
					m_stats_counters.inc_stats_counter(counters::num_peers_up_unchoked_optimistic, -1);
				}
			}
			else
			{
				// no, this peer should be choked
				TORRENT_ASSERT(p-&gt;peer_info_struct());
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(172)">../src/session_impl.cpp:4350</a></td><td>it might be a nice feature here to limit the number of torrents to send in a single update. By just posting the first n torrents, they would nicely be round-robined because the torrent lists are always pushed back. Perhaps the status_update_alert could even have a fixed array of n entries rather than a vector, to further improve memory locality.</td></tr><tr id="172" style="display: none;" colspan="3"><td colspan="3"><h2>it might be a nice feature here to limit the number of torrents
to send in a single update. By just posting the first n torrents, they
would nicely be round-robined because the torrent lists are always
pushed back. Perhaps the status_update_alert could even have a fixed
array of n entries rather than a vector, to further improve memory
locality.</h2><h4>../src/session_impl.cpp:4350</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			t-&gt;status(&amp;*i, flags);
		}
	}
	
	void session_impl::post_torrent_updates(boost::uint32_t flags)
	{
		INVARIANT_CHECK;

		TORRENT_ASSERT(is_single_thread());

		std::vector&lt;torrent*&gt;&amp; state_updates
			= m_torrent_lists[aux::session_impl::torrent_state_updates];

#if TORRENT_USE_ASSERTS
		m_posting_torrent_updates = true;
#endif

		std::vector&lt;torrent_status&gt; status;
		status.reserve(state_updates.size());

<div style="background: #ffff00" width="100%">		for (std::vector&lt;torrent*&gt;::iterator i = state_updates.begin()
</div>			, end(state_updates.end()); i != end; ++i)
		{
			torrent* t = *i;
			TORRENT_ASSERT(t-&gt;m_links[aux::session_impl::torrent_state_updates].in_list());
			status.push_back(torrent_status());
			// querying accurate download counters may require
			// the torrent to be loaded. Loading a torrent, and evicting another
			// one will lead to calling state_updated(), which screws with
			// this list while we're working on it, and break things
			t-&gt;status(&amp;status.back(), flags);
			t-&gt;clear_in_state_update();
		}
		state_updates.clear();

#if TORRENT_USE_ASSERTS
		m_posting_torrent_updates = false;
#endif

		m_alerts.emplace_alert&lt;state_update_alert&gt;(status);
	}

	void session_impl::post_session_stats()
	{
		m_disk_thread.update_stats_counters(m_stats_counters);

		m_stats_counters.set_value(counters::sent_ip_overhead_bytes
			, m_stat.total_transfer(stat::upload_ip_protocol));

		m_stats_counters.set_value(counters::recv_ip_overhead_bytes
			, m_stat.total_transfer(stat::download_ip_protocol));
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(173)">../src/storage.cpp:731</a></td><td>make this more generic to not just work if files have been renamed, but also if they have been merged into a single file for instance maybe use the same format as .torrent files and reuse some code from torrent_info</td></tr><tr id="173" style="display: none;" colspan="3"><td colspan="3"><h2>make this more generic to not just work if files have been
renamed, but also if they have been merged into a single file for instance
maybe use the same format as .torrent files and reuse some code from torrent_info</h2><h4>../src/storage.cpp:731</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			if (file_offset &lt; files().file_size(file_index))
				break;

			file_offset -= files().file_size(file_index);
			++file_index;
			TORRENT_ASSERT(file_index != files().num_files());
		}
	
		error_code ec;
		file_handle handle = open_file_impl(file_index, file::read_only, ec);
		if (ec) return slot;

		boost::int64_t data_start = handle-&gt;sparse_end(file_offset);
		return int((data_start + files().piece_length() - 1) / files().piece_length());
	}

	bool default_storage::verify_resume_data(bdecode_node const&amp; rd
		, std::vector&lt;std::string&gt; const* links
		, storage_error&amp; ec)
	{
<div style="background: #ffff00" width="100%">		bdecode_node mapped_files = rd.dict_find_list("mapped_files");
</div>		if (mapped_files &amp;&amp; mapped_files.list_size() == m_files.num_files())
		{
			m_mapped_files.reset(new file_storage(m_files));
			for (int i = 0; i &lt; m_files.num_files(); ++i)
			{
				std::string new_filename = mapped_files.list_string_value_at(i);
				if (new_filename.empty()) continue;
				m_mapped_files-&gt;rename_file(i, new_filename);
			}
		}
		
		bdecode_node file_priority = rd.dict_find_list("file_priority");
		if (file_priority &amp;&amp; file_priority.list_size()
			== files().num_files())
		{
			m_file_priority.resize(file_priority.list_size());
			for (int i = 0; i &lt; file_priority.list_size(); ++i)
				m_file_priority[i] = boost::uint8_t(file_priority.list_int_value_at(i, 1));
		}

		bdecode_node file_sizes_ent = rd.dict_find_list("file sizes");
		if (file_sizes_ent == 0)
		{
			ec.ec = errors::missing_file_sizes;
			ec.file = -1;
			ec.operation = storage_error::check_resume;
			return false;
		}
		
		if (file_sizes_ent.list_size() == 0)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(174)">../src/storage.cpp:1062</a></td><td>if everything moves OK, except for the partfile we currently won't update the save path, which breaks things. it would probably make more sense to give up on the partfile</td></tr><tr id="174" style="display: none;" colspan="3"><td colspan="3"><h2>if everything moves OK, except for the partfile
we currently won't update the save path, which breaks things.
it would probably make more sense to give up on the partfile</h2><h4>../src/storage.cpp:1062</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">					if (ec)
					{
						ec.file = i-&gt;second;
						ec.operation = storage_error::copy;
					}
					else
					{
						// ignore errors when removing
						error_code e;
						remove_all(old_path, e);
					}
					break;
				}
			}
		}

		if (!ec)
		{
			if (m_part_file)
			{
<div style="background: #ffff00" width="100%">				m_part_file-&gt;move_partfile(save_path, ec.ec);
</div>				if (ec)
				{
					ec.file = -1;
					ec.operation = storage_error::partfile_move;
					return piece_manager::fatal_disk_error; 
				}
			}

			m_save_path = save_path;
		}
		return ret;
	}

	int default_storage::readv(file::iovec_t const* bufs, int num_bufs
		, int slot, int offset, int flags, storage_error&amp; ec)
	{
		fileop op = { &amp;file::readv
			, file::read_only | flags };
#ifdef TORRENT_SIMULATE_SLOW_READ
		boost::thread::sleep(boost::get_system_time()
			+ boost::posix_time::milliseconds(1000));
#endif
		return readwritev(bufs, slot, offset, num_bufs, op, ec);
	}

	int default_storage::writev(file::iovec_t const* bufs, int num_bufs
		, int slot, int offset, int flags, storage_error&amp; ec)
	{
		fileop op = { &amp;file::writev
			, file::read_write | flags };
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(175)">../src/string_util.cpp:60</a></td><td>warning C4146: unary minus operator applied to unsigned type, result still unsigned</td></tr><tr id="175" style="display: none;" colspan="3"><td colspan="3"><h2>warning C4146: unary minus operator applied to unsigned type,
result still unsigned</h2><h4>../src/string_util.cpp:60</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
#include &lt;boost/tuple/tuple.hpp&gt;

#include &lt;cstdlib&gt; // for malloc
#include &lt;cstring&gt; // for memmov/strcpy/strlen

#include "libtorrent/aux_/disable_warnings_pop.hpp"

namespace libtorrent
{

	// lexical_cast's result depends on the locale. We need
	// a well defined result
	boost::array&lt;char, 4 + std::numeric_limits&lt;boost::int64_t&gt;::digits10&gt;
		to_string(boost::int64_t n)
	{
		boost::array&lt;char, 4 + std::numeric_limits&lt;boost::int64_t&gt;::digits10&gt; ret;
		char *p = &amp;ret.back();
		*p = '\0';
		boost::uint64_t un = n;
<div style="background: #ffff00" width="100%">		if (n &lt; 0)  un = -un;
</div>		do {
			*--p = '0' + un % 10;
			un /= 10;
		} while (un);
		if (n &lt; 0) *--p = '-';
		std::memmove(&amp;ret[0], p, &amp;ret.back() - p + 1);
		return ret;
	}

	bool is_alpha(char c)
	{
		return (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z');
	}

	bool is_print(char c)
	{
		return c &gt;= 32 &amp;&amp; c &lt; 127;
	}

	bool is_space(char c)
	{
		static const char* ws = " \t\n\r\f\v";
		return strchr(ws, c) != 0;
	}

	char to_lower(char c)
	{
		return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ? c - 'A' + 'a' : c;
	}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(176)">../src/torrent.cpp:515</a></td><td>if the existing torrent doesn't have metadata, insert the metadata we just downloaded into it.</td></tr><tr id="176" style="display: none;" colspan="3"><td colspan="3"><h2>if the existing torrent doesn't have metadata, insert
the metadata we just downloaded into it.</h2><h4>../src/torrent.cpp:515</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		m_torrent_file = tf;

		// now, we might already have this torrent in the session.
		boost::shared_ptr&lt;torrent&gt; t = m_ses.find_torrent(m_torrent_file-&gt;info_hash()).lock();
		if (t)
		{
			if (!m_uuid.empty() &amp;&amp; t-&gt;uuid().empty())
				t-&gt;set_uuid(m_uuid);
			if (!m_url.empty() &amp;&amp; t-&gt;url().empty())
				t-&gt;set_url(m_url);
			if (!m_source_feed_url.empty() &amp;&amp; t-&gt;source_feed_url().empty())
				t-&gt;set_source_feed_url(m_source_feed_url);

			// insert this torrent in the uuid index
			if (!m_uuid.empty() || !m_url.empty())
			{
				m_ses.insert_uuid_torrent(m_uuid.empty() ? m_url : m_uuid, t);
			}

<div style="background: #ffff00" width="100%">
</div>			set_error(error_code(errors::duplicate_torrent, get_libtorrent_category()), error_file_url);
			abort();
			return;
		}

		m_ses.insert_torrent(m_torrent_file-&gt;info_hash(), me, m_uuid);

		TORRENT_ASSERT(num_torrents == int(m_ses.m_torrents.size()));

		// if the user added any trackers while downloading the
		// .torrent file, serge them into the new tracker list
		std::vector&lt;announce_entry&gt; new_trackers = m_torrent_file-&gt;trackers();
		for (std::vector&lt;announce_entry&gt;::iterator i = m_trackers.begin()
			, end(m_trackers.end()); i != end; ++i)
		{
			// if we already have this tracker, ignore it
			if (std::find_if(new_trackers.begin(), new_trackers.end()
				, boost::bind(&amp;announce_entry::url, _1) == i-&gt;url) != new_trackers.end())
				continue;

			// insert the tracker ordered by tier
			new_trackers.insert(std::find_if(new_trackers.begin(), new_trackers.end()
				, boost::bind(&amp;announce_entry::tier, _1) &gt;= i-&gt;tier), *i);
		}
		m_trackers.swap(new_trackers);

#if !defined(TORRENT_DISABLE_ENCRYPTION) &amp;&amp; !defined(TORRENT_DISABLE_EXTENSIONS)
		hasher h;
		h.update("req2", 4);
		h.update((char*)&amp;m_torrent_file-&gt;info_hash()[0], 20);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(177)">../src/torrent.cpp:666</a></td><td>if the existing torrent doesn't have metadata, insert the metadata we just downloaded into it.</td></tr><tr id="177" style="display: none;" colspan="3"><td colspan="3"><h2>if the existing torrent doesn't have metadata, insert
the metadata we just downloaded into it.</h2><h4>../src/torrent.cpp:666</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		m_torrent_file = tf;
		m_info_hash = tf-&gt;info_hash();

		// now, we might already have this torrent in the session.
		boost::shared_ptr&lt;torrent&gt; t = m_ses.find_torrent(m_torrent_file-&gt;info_hash()).lock();
		if (t)
		{
			if (!m_uuid.empty() &amp;&amp; t-&gt;uuid().empty())
				t-&gt;set_uuid(m_uuid);
			if (!m_url.empty() &amp;&amp; t-&gt;url().empty())
				t-&gt;set_url(m_url);
			if (!m_source_feed_url.empty() &amp;&amp; t-&gt;source_feed_url().empty())
				t-&gt;set_source_feed_url(m_source_feed_url);

			// insert this torrent in the uuid index
			if (!m_uuid.empty() || !m_url.empty())
			{
				m_ses.insert_uuid_torrent(m_uuid.empty() ? m_url : m_uuid, t);
			}

<div style="background: #ffff00" width="100%">
</div>			set_error(error_code(errors::duplicate_torrent, get_libtorrent_category()), error_file_url);
			abort();
			return;
		}

		m_ses.insert_torrent(m_torrent_file-&gt;info_hash(), me, m_uuid);

		// if the user added any trackers while downloading the
		// .torrent file, merge them into the new tracker list
		std::vector&lt;announce_entry&gt; new_trackers = m_torrent_file-&gt;trackers();
		for (std::vector&lt;announce_entry&gt;::iterator i = m_trackers.begin()
			, end(m_trackers.end()); i != end; ++i)
		{
			// if we already have this tracker, ignore it
			if (std::find_if(new_trackers.begin(), new_trackers.end()
				, boost::bind(&amp;announce_entry::url, _1) == i-&gt;url) != new_trackers.end())
				continue;

			// insert the tracker ordered by tier
			new_trackers.insert(std::find_if(new_trackers.begin(), new_trackers.end()
				, boost::bind(&amp;announce_entry::tier, _1) &gt;= i-&gt;tier), *i);
		}
		m_trackers.swap(new_trackers);

#if !defined(TORRENT_DISABLE_ENCRYPTION) &amp;&amp; !defined(TORRENT_DISABLE_EXTENSIONS)
		hasher h;
		h.update("req2", 4);
		h.update((char*)&amp;m_torrent_file-&gt;info_hash()[0], 20);
		m_ses.add_obfuscated_hash(h.final(), shared_from_this());
#endif
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(178)">../src/torrent.cpp:1475</a></td><td>is verify_peer_cert called once per certificate in the chain, and this function just tells us which depth we're at right now? If so, the comment makes sense. any certificate that isn't the leaf (i.e. the one presented by the peer) should be accepted automatically, given preverified is true. The leaf certificate need to be verified to make sure its DN matches the info-hash</td></tr><tr id="178" style="display: none;" colspan="3"><td colspan="3"><h2>is verify_peer_cert called once per certificate in the chain, and
this function just tells us which depth we're at right now? If so, the comment
makes sense.
any certificate that isn't the leaf (i.e. the one presented by the peer)
should be accepted automatically, given preverified is true. The leaf certificate
need to be verified to make sure its DN matches the info-hash</h2><h4>../src/torrent.cpp:1475</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			if (pp) p-&gt;add_extension(pp);
		}

		// if files are checked for this torrent, call the extension
		// to let it initialize itself
		if (m_connections_initialized)
			tp-&gt;on_files_checked();
	}

#endif

#ifdef TORRENT_USE_OPENSSL

#if BOOST_VERSION &gt;= 104700
	bool torrent::verify_peer_cert(bool preverified, boost::asio::ssl::verify_context&amp; ctx)
	{
		// if the cert wasn't signed by the correct CA, fail the verification
		if (!preverified) return false;

		// we're only interested in checking the certificate at the end of the chain.
<div style="background: #ffff00" width="100%">		int depth = X509_STORE_CTX_get_error_depth(ctx.native_handle());
</div>		if (depth &gt; 0) return true;

		X509* cert = X509_STORE_CTX_get_current_cert(ctx.native_handle());

		// Go through the alternate names in the certificate looking for matching DNS entries
		GENERAL_NAMES* gens = static_cast&lt;GENERAL_NAMES*&gt;(
			X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0));

#ifndef TORRENT_DISABLE_LOGGING
		std::string names;
		bool match = false;
#endif
		for (int i = 0; i &lt; sk_GENERAL_NAME_num(gens); ++i)
		{
			GENERAL_NAME* gen = sk_GENERAL_NAME_value(gens, i);
			if (gen-&gt;type != GEN_DNS) continue;
			ASN1_IA5STRING* domain = gen-&gt;d.dNSName;
			if (domain-&gt;type != V_ASN1_IA5STRING || !domain-&gt;data || !domain-&gt;length) continue;
			const char* torrent_name = reinterpret_cast&lt;const char*&gt;(domain-&gt;data);
			std::size_t name_length = domain-&gt;length;

#ifndef TORRENT_DISABLE_LOGGING
			if (i &gt; 1) names += " | n: ";
			names.append(torrent_name, name_length);
#endif
			if (strncmp(torrent_name, "*", name_length) == 0
				|| strncmp(torrent_name, m_torrent_file-&gt;name().c_str(), name_length) == 0)
			{
#ifndef TORRENT_DISABLE_LOGGING
				match = true;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(179)">../src/torrent.cpp:1882</a></td><td>instead of creating the picker up front here, maybe this whole section should move to need_picker()</td></tr><tr id="179" style="display: none;" colspan="3"><td colspan="3"><h2>instead of creating the picker up front here,
maybe this whole section should move to need_picker()</h2><h4>../src/torrent.cpp:1882</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		if (m_seed_mode)
		{
			m_have_all = true;
			m_ses.get_io_service().post(boost::bind(&amp;torrent::files_checked, shared_from_this()));
			m_resume_data.reset();
			update_gauge();
			return;
		}

		int num_pad_files = 0;
		TORRENT_ASSERT(block_size() &gt; 0);
		file_storage const&amp; fs = m_torrent_file-&gt;files();
		for (int i = 0; i &lt; fs.num_files(); ++i)
		{
			if (fs.pad_file_at(i)) ++num_pad_files;

			if (!fs.pad_file_at(i) || fs.file_size(i) == 0) continue;
			m_padding += boost::uint32_t(fs.file_size(i));
			
<div style="background: #ffff00" width="100%">			need_picker();
</div>
			peer_request pr = m_torrent_file-&gt;map_file(i, 0, fs.file_size(i));
			int off = pr.start &amp; (block_size()-1);
			if (off != 0) { pr.length -= block_size() - off; pr.start += block_size() - off; }
			TORRENT_ASSERT((pr.start &amp; (block_size()-1)) == 0);

			int block = block_size();
			int blocks_per_piece = m_torrent_file-&gt;piece_length() / block;
			piece_block pb(pr.piece, pr.start / block);
			for (; pr.length &gt;= block; pr.length -= block, ++pb.block_index)
			{
				if (int(pb.block_index) == blocks_per_piece) { pb.block_index = 0; ++pb.piece_index; }
				m_picker-&gt;mark_as_finished(pb, 0);
			}
			// ugly edge case where padfiles are not used they way they're
			// supposed to be. i.e. added back-to back or at the end
			if (int(pb.block_index) == blocks_per_piece) { pb.block_index = 0; ++pb.piece_index; }
			if (pr.length &gt; 0 &amp;&amp; ((i+1 != fs.num_files() &amp;&amp; fs.pad_file_at(i+1))
				|| i + 1 == fs.num_files()))
			{
				m_picker-&gt;mark_as_finished(pb, 0);
			}
		}

		if (m_padding &gt; 0)
		{
			// if we marked an entire piece as finished, we actually
			// need to consider it finished

			std::vector&lt;piece_picker::downloading_piece&gt; dq
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(180)">../src/torrent.cpp:1957</a></td><td>this could be optimized by looking up which files are complete and just look at those</td></tr><tr id="180" style="display: none;" colspan="3"><td colspan="3"><h2>this could be optimized by looking up which files are
complete and just look at those</h2><h4>../src/torrent.cpp:1957</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (!need_loaded()) return;

		if (num_pad_files &gt; 0)
			m_picker-&gt;set_num_pad_files(num_pad_files);

		std::auto_ptr&lt;std::vector&lt;std::string&gt; &gt; links;
#ifndef TORRENT_DISABLE_MUTABLE_TORRENTS
		if (!m_torrent_file-&gt;similar_torrents().empty()
			|| !m_torrent_file-&gt;collections().empty())
		{
			resolve_links res(m_torrent_file);

			std::vector&lt;sha1_hash&gt; s = m_torrent_file-&gt;similar_torrents();
			for (std::vector&lt;sha1_hash&gt;::iterator i = s.begin(), end(s.end());
				i != end; ++i)
			{
				boost::shared_ptr&lt;torrent&gt; t = m_ses.find_torrent(*i).lock();
				if (!t) continue;

				// Only attempt to reuse files from torrents that are seeding.
<div style="background: #ffff00" width="100%">				if (!t-&gt;is_seed()) continue;
</div>
				res.match(t-&gt;get_torrent_copy(), t-&gt;save_path());
			}
			std::vector&lt;std::string&gt; c = m_torrent_file-&gt;collections();
			for (std::vector&lt;std::string&gt;::iterator i = c.begin(), end(c.end());
				i != end; ++i)
			{
				std::vector&lt;boost::shared_ptr&lt;torrent&gt; &gt; ts = m_ses.find_collection(*i);

				for (std::vector&lt;boost::shared_ptr&lt;torrent&gt; &gt;::iterator k = ts.begin()
					, end(ts.end()); k != end; ++k)
				{
					// Only attempt to reuse files from torrents that are seeding.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(181)">../src/torrent.cpp:1973</a></td><td>this could be optimized by looking up which files are complete and just look at those</td></tr><tr id="181" style="display: none;" colspan="3"><td colspan="3"><h2>this could be optimized by looking up which files are
complete and just look at those</h2><h4>../src/torrent.cpp:1973</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				i != end; ++i)
			{
				boost::shared_ptr&lt;torrent&gt; t = m_ses.find_torrent(*i).lock();
				if (!t) continue;

				// Only attempt to reuse files from torrents that are seeding.
				if (!t-&gt;is_seed()) continue;

				res.match(t-&gt;get_torrent_copy(), t-&gt;save_path());
			}
			std::vector&lt;std::string&gt; c = m_torrent_file-&gt;collections();
			for (std::vector&lt;std::string&gt;::iterator i = c.begin(), end(c.end());
				i != end; ++i)
			{
				std::vector&lt;boost::shared_ptr&lt;torrent&gt; &gt; ts = m_ses.find_collection(*i);

				for (std::vector&lt;boost::shared_ptr&lt;torrent&gt; &gt;::iterator k = ts.begin()
					, end(ts.end()); k != end; ++k)
				{
					// Only attempt to reuse files from torrents that are seeding.
<div style="background: #ffff00" width="100%">					if (!(*k)-&gt;is_seed()) continue;
</div>
					res.match((*k)-&gt;get_torrent_copy(), (*k)-&gt;save_path());
				}
			}

			std::vector&lt;resolve_links::link_t&gt; const&amp; l = res.get_links();
			if (!l.empty())
			{
				links.reset(new std::vector&lt;std::string&gt;(l.size()));
				for (std::vector&lt;resolve_links::link_t&gt;::const_iterator i = l.begin()
					, end(l.end()); i != end; ++i)
				{
					if (!i-&gt;ti) continue;

					torrent_info const&amp; ti = *i-&gt;ti;
					std::string const&amp; save_path = i-&gt;save_path;
					links-&gt;push_back(combine_path(save_path
						, ti.files().file_path(i-&gt;file_idx)));
				}
			}
		}
#endif // TORRENT_DISABLE_MUTABLE_TORRENTS

		inc_refcount("check_fastresume");
		// async_check_fastresume will release links
		m_ses.disk_thread().async_check_fastresume(
			m_storage.get(), m_resume_data ? &amp;m_resume_data-&gt;node : NULL
			, links, boost::bind(&amp;torrent::on_resume_data_checked
			, shared_from_this(), _1));
#ifndef TORRENT_DISABLE_LOGGING
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(182)">../src/torrent.cpp:2140</a></td><td>there may be peer extensions relying on the torrent extension still being alive. Only do this if there are no peers. And when the last peer is disconnected, if the torrent is unloaded, clear the extensions m_extensions.clear();</td></tr><tr id="182" style="display: none;" colspan="3"><td colspan="3"><h2>there may be peer extensions relying on the torrent extension
still being alive. Only do this if there are no peers. And when the last peer
is disconnected, if the torrent is unloaded, clear the extensions
m_extensions.clear();</h2><h4>../src/torrent.cpp:2140</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// pinned torrents are not allowed to be swapped out
		TORRENT_ASSERT(!m_pinned);

		m_should_be_loaded = false;

		// make sure it's not unloaded in the middle of some operation that uses it
		if (m_refcount &gt; 0) return;

		// call on_unload() on extensions
#ifndef TORRENT_DISABLE_EXTENSIONS
		for (extension_list_t::iterator i = m_extensions.begin()
			, end(m_extensions.end()); i != end; ++i)
		{
			TORRENT_TRY {
				(*i)-&gt;on_unload();
			} TORRENT_CATCH (std::exception&amp;) {}
		}

		// also remove extensions and re-instantiate them when the torrent is loaded again
		// they end up using a significant amount of memory
<div style="background: #ffff00" width="100%">#endif
</div>
		// someone else holds a reference to the torrent_info
		// make the torrent release its reference to it,
		// after making a copy and then unloading that version
		// as soon as the user is done with its copy of torrent_info
		// it will be freed, and we'll have the unloaded version left
		if (!m_torrent_file.unique())
			m_torrent_file = boost::make_shared&lt;torrent_info&gt;(*m_torrent_file);

		m_torrent_file-&gt;unload();
		inc_stats_counter(counters::num_loaded_torrents, -1);

		m_storage.reset();

		state_updated();
	}

	bt_peer_connection* torrent::find_introducer(tcp::endpoint const&amp; ep) const
	{
#ifndef TORRENT_DISABLE_EXTENSIONS
		for (const_peer_iterator i = m_connections.begin(); i != m_connections.end(); ++i)
		{
			if ((*i)-&gt;type() != peer_connection::bittorrent_connection) continue;
			bt_peer_connection* p = (bt_peer_connection*)(*i);
			if (!p-&gt;supports_holepunch()) continue;
			peer_plugin const* pp = p-&gt;find_plugin("ut_pex");
			if (!pp) continue;
			if (was_introduced_by(pp, ep)) return (bt_peer_connection*)p;
		}
#endif
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(183)">../src/torrent.cpp:2816</a></td><td>this pattern is repeated in a few places. Factor this into a function and generalize the concept of a torrent having a dedicated listen port</td></tr><tr id="183" style="display: none;" colspan="3"><td colspan="3"><h2>this pattern is repeated in a few places. Factor this into
a function and generalize the concept of a torrent having a
dedicated listen port</h2><h4>../src/torrent.cpp:2816</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// if the files haven't been checked yet, we're
		// not ready for peers. Except, if we don't have metadata,
		// we need peers to download from
		if (!m_files_checked &amp;&amp; valid_metadata()) return;

		if (!m_announce_to_lsd) return;

		// private torrents are never announced on LSD
		if (m_torrent_file-&gt;is_valid() &amp;&amp; m_torrent_file-&gt;priv()) return;

		// i2p torrents are also never announced on LSD
		// unless we allow mixed swarms
		if (m_torrent_file-&gt;is_valid()
			&amp;&amp; (torrent_file().is_i2p() &amp;&amp; !settings().get_bool(settings_pack::allow_i2p_mixed)))
			return;

		if (is_paused()) return;

		if (!m_ses.has_lsd()) return;

<div style="background: #ffff00" width="100%">#ifdef TORRENT_USE_OPENSSL
</div>		int port = is_ssl_torrent() ? m_ses.ssl_listen_port() : m_ses.listen_port();
#else
		int port = m_ses.listen_port();
#endif

		// announce with the local discovery service
		m_ses.announce_lsd(m_torrent_file-&gt;info_hash(), port
			, m_ses.settings().get_bool(settings_pack::broadcast_lsd) &amp;&amp; m_lsd_seq == 0);
		++m_lsd_seq;
	}

#ifndef TORRENT_DISABLE_DHT

	void torrent::dht_announce()
	{
		TORRENT_ASSERT(is_single_thread());
		if (!m_ses.dht())
		{
#ifndef TORRENT_DISABLE_LOGGING
			debug_log("DHT: no dht initialized");
#endif
			return;
		}
		if (!should_announce_dht())
		{
#ifndef TORRENT_DISABLE_LOGGING
			if (!m_ses.announce_dht())
				debug_log("DHT: no listen sockets");

			if (m_torrent_file-&gt;is_valid() &amp;&amp; !m_files_checked)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(184)">../src/torrent.cpp:3593</a></td><td>add one peer per IP the hostname resolves to</td></tr><tr id="184" style="display: none;" colspan="3"><td colspan="3"><h2>add one peer per IP the hostname resolves to</h2><h4>../src/torrent.cpp:3593</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#endif

	void torrent::on_peer_name_lookup(error_code const&amp; e
		, std::vector&lt;address&gt; const&amp; host_list, int port)
	{
		TORRENT_ASSERT(is_single_thread());

		INVARIANT_CHECK;

#if defined TORRENT_ASIO_DEBUGGING
		complete_async("torrent::on_peer_name_lookup");
#endif

#ifndef TORRENT_DISABLE_LOGGING
		if (e)
			debug_log("peer name lookup error: %s", e.message().c_str());
#endif

		if (e || host_list.empty() || m_ses.is_aborted()) return;

<div style="background: #ffff00" width="100%">		tcp::endpoint host(host_list.front(), port);
</div>
		if (m_apply_ip_filter
			&amp;&amp; m_ses.get_ip_filter().access(host.address()) &amp; ip_filter::blocked)
		{
#ifndef TORRENT_DISABLE_LOGGING
			error_code ec;
			debug_log("blocked ip from tracker: %s", host.address().to_string(ec).c_str());
#endif
			if (m_ses.alerts().should_post&lt;peer_blocked_alert&gt;())
				m_ses.alerts().emplace_alert&lt;peer_blocked_alert&gt;(get_handle()
					, host.address(), peer_blocked_alert::ip_filter);
			return;
		}

		if (add_peer(host, peer_info::tracker))
			state_updated();
		update_want_peers();
	}

	boost::int64_t torrent::bytes_left() const
	{
		// if we don't have the metadata yet, we
		// cannot tell how big the torrent is.
		if (!valid_metadata()) return -1;
		return m_torrent_file-&gt;total_size()
			- quantized_bytes_done();
	}

	boost::int64_t torrent::quantized_bytes_done() const
	{
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(185)">../src/torrent.cpp:4587</a></td><td>update suggest_piece?</td></tr><tr id="185" style="display: none;" colspan="3"><td colspan="3"><h2>update suggest_piece?</h2><h4>../src/torrent.cpp:4587</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	void torrent::peer_has_all(peer_connection const* peer)
	{
		if (has_picker())
		{
			m_picker-&gt;inc_refcount_all(peer);
		}
#ifdef TORRENT_DEBUG
		else
		{
			TORRENT_ASSERT(is_seed() || !m_have_all);
		}
#endif
	}

	void torrent::peer_lost(bitfield const&amp; bits, peer_connection const* peer)
	{
		if (has_picker())
		{
			m_picker-&gt;dec_refcount(bits, peer);
<div style="background: #ffff00" width="100%">		}
</div>#ifdef TORRENT_DEBUG
		else
		{
			TORRENT_ASSERT(is_seed() || !m_have_all);
		}
#endif
	}

	void torrent::peer_lost(int index, peer_connection const* peer)
	{
		if (m_picker.get())
		{
			m_picker-&gt;dec_refcount(index, peer);
			update_suggest_piece(index, -1);
		}
#ifdef TORRENT_DEBUG
		else
		{
			TORRENT_ASSERT(is_seed() || !m_have_all);
		}
#endif
	}

	void torrent::add_suggest_piece(int index)
	{
		// it would be nice if we would keep track of piece
		// availability even when we're a seed, for
		// the suggest piece feature
		if (!has_picker()) return;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(186)">../src/torrent.cpp:4730</a></td><td>really, we should just keep the picker around in this case to maintain the availability counters</td></tr><tr id="186" style="display: none;" colspan="3"><td colspan="3"><h2>really, we should just keep the picker around
in this case to maintain the availability counters</h2><h4>../src/torrent.cpp:4730</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		pieces.reserve(cs.pieces.size());

		// sort in ascending order, to get most recently used first
		std::sort(cs.pieces.begin(), cs.pieces.end()
			, boost::bind(&amp;cached_piece_info::last_use, _1)
			&gt; boost::bind(&amp;cached_piece_info::last_use, _2));

		for (std::vector&lt;cached_piece_info&gt;::iterator i = cs.pieces.begin()
			, end(cs.pieces.end()); i != end; ++i)
		{
			TORRENT_ASSERT(i-&gt;storage == m_storage.get());
			if (!has_piece_passed(i-&gt;piece)) continue;
			suggest_piece_t p;
			p.piece_index = i-&gt;piece;
			if (has_picker())
			{
				p.num_peers = m_picker-&gt;get_availability(i-&gt;piece);
			}
			else
			{
<div style="background: #ffff00" width="100%">				p.num_peers = 0;
</div>				for (const_peer_iterator i = m_connections.begin()
					, end(m_connections.end()); i != end; ++i)
				{
					peer_connection* peer = *i;
					if (peer-&gt;has_piece(p.piece_index)) ++p.num_peers;
				}
			}
			pieces.push_back(p);
		}

		// sort by rarity (stable, to maintain sort
		// by last use)
		std::stable_sort(pieces.begin(), pieces.end());

		// only suggest half of the pieces
		pieces.resize(pieces.size() / 2);

		// send new suggests to peers
		// the peers will filter out pieces we've
		// already suggested to them
		for (std::vector&lt;suggest_piece_t&gt;::iterator i = pieces.begin()
			, end(pieces.end()); i != end; ++i)
		{
			for (peer_iterator p = m_connections.begin();
				p != m_connections.end(); ++p)
				(*p)-&gt;send_suggest(i-&gt;piece_index);
		}
	}

	void torrent::abort()
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(187)">../src/torrent.cpp:6704</a></td><td>make this more generic to not just work if files have been renamed, but also if they have been merged into a single file for instance maybe use the same format as .torrent files and reuse some code from torrent_info The mapped_files needs to be read both in the network thread and in the disk thread, since they both have their own mapped files structures which are kept in sync</td></tr><tr id="187" style="display: none;" colspan="3"><td colspan="3"><h2>make this more generic to not just work if files have been
renamed, but also if they have been merged into a single file for instance
maybe use the same format as .torrent files and reuse some code from torrent_info
The mapped_files needs to be read both in the network thread
and in the disk thread, since they both have their own mapped files structures
which are kept in sync</h2><h4>../src/torrent.cpp:6704</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		m_last_upload = tmp == -1 ? (std::numeric_limits&lt;boost::int16_t&gt;::min)() : now - tmp;

		if (m_use_resume_save_path)
		{
			std::string p = rd.dict_find_string_value("save_path");
			if (!p.empty()) m_save_path = p;
		}

		m_url = rd.dict_find_string_value("url");
		m_uuid = rd.dict_find_string_value("uuid");
		m_source_feed_url = rd.dict_find_string_value("feed");

		if (!m_uuid.empty() || !m_url.empty())
		{
			boost::shared_ptr&lt;torrent&gt; me(shared_from_this());

			// insert this torrent in the uuid index
			m_ses.insert_uuid_torrent(m_uuid.empty() ? m_url : m_uuid, me);
		}

<div style="background: #ffff00" width="100%">		bdecode_node mapped_files = rd.dict_find_list("mapped_files");
</div>		if (mapped_files &amp;&amp; mapped_files.list_size() == m_torrent_file-&gt;num_files())
		{
			for (int i = 0; i &lt; m_torrent_file-&gt;num_files(); ++i)
			{
				std::string new_filename = mapped_files.list_string_value_at(i);
				if (new_filename.empty()) continue;
				m_torrent_file-&gt;rename_file(i, new_filename);
			}
		}
		
		m_added_time = rd.dict_find_int_value("added_time", m_added_time);
		m_completed_time = rd.dict_find_int_value("completed_time", m_completed_time);
		if (m_completed_time != 0 &amp;&amp; m_completed_time &lt; m_added_time)
			m_completed_time = m_added_time;

		if (!m_seed_mode &amp;&amp; !m_override_resume_data)
		{
			bdecode_node file_priority = rd.dict_find_list("file_priority");
			if (file_priority &amp;&amp; file_priority.list_size()
				== m_torrent_file-&gt;num_files())
			{
				int num_files = m_torrent_file-&gt;num_files();
				m_file_priority.resize(num_files);
				for (int i = 0; i &lt; num_files; ++i)
					m_file_priority[i] = file_priority.list_int_value_at(i, 1);
				// unallocated slots are assumed to be priority 1, so cut off any
				// trailing ones
				int end_range = num_files - 1;
				for (; end_range &gt;= 0; --end_range) if (m_file_priority[end_range] != 1) break;
				m_file_priority.resize(end_range + 1);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(188)">../src/torrent.cpp:6822</a></td><td>if this is a merkle torrent and we can't restore the tree, we need to wipe all the bits in the have array, but not necessarily we might want to do a full check to see if we have all the pieces. This is low priority since almost no one uses merkle torrents</td></tr><tr id="188" style="display: none;" colspan="3"><td colspan="3"><h2>if this is a merkle torrent and we can't
restore the tree, we need to wipe all the
bits in the have array, but not necessarily
we might want to do a full check to see if we have
all the pieces. This is low priority since almost
no one uses merkle torrents</h2><h4>../src/torrent.cpp:6822</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				add_web_seed(url, web_seed_entry::http_seed);
			}
		}

		if (m_torrent_file-&gt;is_merkle_torrent())
		{
			bdecode_node mt = rd.dict_find_string("merkle tree");
			if (mt)
			{
				std::vector&lt;sha1_hash&gt; tree;
				tree.resize(m_torrent_file-&gt;merkle_tree().size());
				std::memcpy(&amp;tree[0], mt.string_ptr()
					, (std::min)(mt.string_length(), int(tree.size()) * 20));
				if (mt.string_length() &lt; int(tree.size()) * 20)
					std::memset(&amp;tree[0] + mt.string_length() / 20, 0
						, tree.size() - mt.string_length() / 20);
				m_torrent_file-&gt;set_merkle_tree(tree);
			}
			else
			{
<div style="background: #ffff00" width="100%">				TORRENT_ASSERT(false);
</div>			}
		}

		// updating some of the torrent state may have set need_save_resume_data.
		// clear it here since we've just restored the resume data we already
		// have. Nothing has changed from that state yet.
		m_need_save_resume_data = false;
	}

	boost::shared_ptr&lt;const torrent_info&gt; torrent::get_torrent_copy()
	{
		if (!m_torrent_file-&gt;is_valid()) return boost::shared_ptr&lt;const torrent_info&gt;();
		if (!need_loaded()) return boost::shared_ptr&lt;const torrent_info&gt;();

		return m_torrent_file;
	}
	
	void torrent::write_resume_data(entry&amp; ret) const
	{
		using namespace libtorrent::detail; // for write_*_endpoint()
		ret["file-format"] = "libtorrent resume file";
		ret["file-version"] = 1;
		ret["libtorrent-version"] = LIBTORRENT_VERSION;

		ret["total_uploaded"] = m_total_uploaded;
		ret["total_downloaded"] = m_total_downloaded;

		ret["active_time"] = active_time();
		ret["finished_time"] = finished_time();
		ret["seeding_time"] = seeding_time();
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(189)">../src/torrent.cpp:7013</a></td><td>make this more generic to not just work if files have been renamed, but also if they have been merged into a single file for instance. using file_base</td></tr><tr id="189" style="display: none;" colspan="3"><td colspan="3"><h2>make this more generic to not just work if files have been
renamed, but also if they have been merged into a single file for instance.
using file_base</h2><h4>../src/torrent.cpp:7013</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		pieces.resize(m_torrent_file-&gt;num_pieces());
		if (!has_picker())
		{
			std::memset(&amp;pieces[0], m_have_all, pieces.size());
		}
		else if (has_picker())
		{
			for (int i = 0, end(pieces.size()); i &lt; end; ++i)
				pieces[i] = m_picker-&gt;have_piece(i) ? 1 : 0;
		}

		if (m_seed_mode)
		{
			TORRENT_ASSERT(m_verified.size() == pieces.size());
			TORRENT_ASSERT(m_verifying.size() == pieces.size());
			for (int i = 0, end(pieces.size()); i &lt; end; ++i)
				pieces[i] |= m_verified[i] ? 2 : 0;
		}

		// write renamed files
<div style="background: #ffff00" width="100%">		if (&amp;m_torrent_file-&gt;files() != &amp;m_torrent_file-&gt;orig_files()
</div>			&amp;&amp; m_torrent_file-&gt;files().num_files() == m_torrent_file-&gt;orig_files().num_files())
		{
			entry::list_type&amp; fl = ret["mapped_files"].list();
			file_storage const&amp; fs = m_torrent_file-&gt;files();
			for (int i = 0; i &lt; fs.num_files(); ++i)
			{
				fl.push_back(fs.file_path(i));
			}
		}

		// write local peers

		std::back_insert_iterator&lt;entry::string_type&gt; peers(ret["peers"].string());
		std::back_insert_iterator&lt;entry::string_type&gt; banned_peers(ret["banned_peers"].string());
#if TORRENT_USE_IPV6
		std::back_insert_iterator&lt;entry::string_type&gt; peers6(ret["peers6"].string());
		std::back_insert_iterator&lt;entry::string_type&gt; banned_peers6(ret["banned_peers6"].string());
#endif

		int num_saved_peers = 0;

		std::vector&lt;torrent_peer const*&gt; deferred_peers;

		if (m_peer_list)
		{
			for (peer_list::const_iterator i = m_peer_list-&gt;begin_peer()
				, end(m_peer_list-&gt;end_peer()); i != end; ++i)
			{
				error_code ec;
				torrent_peer const* p = *i;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(190)">../src/torrent.cpp:9028</a></td><td>add a flag to ignore stats, and only care about resume data for content. For unchanged files, don't trigger a load of the metadata just to save an empty resume data file</td></tr><tr id="190" style="display: none;" colspan="3"><td colspan="3"><h2>add a flag to ignore stats, and only care about resume data for
content. For unchanged files, don't trigger a load of the metadata
just to save an empty resume data file</h2><h4>../src/torrent.cpp:9028</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (m_complete != 0xffffff) seeds = m_complete;
		else seeds = m_peer_list ? m_peer_list-&gt;num_seeds() : 0;

		if (m_incomplete != 0xffffff) downloaders = m_incomplete;
		else downloaders = m_peer_list ? m_peer_list-&gt;num_peers() - m_peer_list-&gt;num_seeds() : 0;

		if (seeds == 0)
		{
			ret |= no_seeds;
			ret |= downloaders &amp; prio_mask;
		}
		else
		{
			ret |= ((1 + downloaders) * scale / seeds) &amp; prio_mask;
		}

		return ret;
	}

	// this is an async operation triggered by the client	
<div style="background: #ffff00" width="100%">	void torrent::save_resume_data(int flags)
</div>	{
		TORRENT_ASSERT(is_single_thread());
		INVARIANT_CHECK;
	
		if (!valid_metadata())
		{
			alerts().emplace_alert&lt;save_resume_data_failed_alert&gt;(get_handle()
				, errors::no_metadata);
			return;
		}

		if (!m_storage.get())
		{
			alerts().emplace_alert&lt;save_resume_data_failed_alert&gt;(get_handle()
				, errors::destructing_torrent);
			return;
		}

		if ((flags &amp; torrent_handle::only_if_modified) &amp;&amp; !m_need_save_resume_data)
		{
			alerts().emplace_alert&lt;save_resume_data_failed_alert&gt;(get_handle()
				, errors::resume_data_not_modified);
			return;
		}

		m_need_save_resume_data = false;
		m_last_saved_resume = m_ses.session_time();
		m_save_resume_flags = boost::uint8_t(flags);
		state_updated();

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(191)">../src/torrent.cpp:10641</a></td><td>instead of resorting the whole list, insert the peers directly into the right place</td></tr><tr id="191" style="display: none;" colspan="3"><td colspan="3"><h2>instead of resorting the whole list, insert the peers
directly into the right place</h2><h4>../src/torrent.cpp:10641</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				printf("timed out [average-piece-time: %d ms ]\n"
					, m_average_piece_time);
#endif
			}

			// pick all blocks for this piece. the peers list is kept up to date
			// and sorted. when we issue a request to a peer, its download queue
			// time will increase and it may need to be bumped in the peers list,
			// since it's ordered by download queue time
			pick_time_critical_block(peers, ignore_peers
				, peers_with_requests
				, pi, &amp;*i, m_picker.get()
				, blocks_in_piece, timed_out);

			// put back the peers we ignored into the peer list for the next piece
			if (!ignore_peers.empty())
			{
				peers.insert(peers.begin(), ignore_peers.begin(), ignore_peers.end());
				ignore_peers.clear();

<div style="background: #ffff00" width="100%">				std::sort(peers.begin(), peers.end()
</div>					, boost::bind(&amp;peer_connection::download_queue_time, _1, 16*1024)
					&lt; boost::bind(&amp;peer_connection::download_queue_time, _2, 16*1024));
			}

			// if this peer's download time exceeds 2 seconds, we're done.
			// We don't want to build unreasonably long request queues
			if (!peers.empty() &amp;&amp; peers[0]-&gt;download_queue_time() &gt; milliseconds(2000))
				break;
		}

		// commit all the time critical requests
		for (std::set&lt;peer_connection*&gt;::iterator i = peers_with_requests.begin()
			, end(peers_with_requests.end()); i != end; ++i)
		{
			(*i)-&gt;send_block_requests();
		}
	}

	std::set&lt;std::string&gt; torrent::web_seeds(web_seed_entry::type_t type) const
	{
		TORRENT_ASSERT(is_single_thread());
		std::set&lt;std::string&gt; ret;
		for (std::list&lt;web_seed_t&gt;::const_iterator i = m_web_seeds.begin()
			, end(m_web_seeds.end()); i != end; ++i)
		{
			if (i-&gt;peer_info.banned) continue;
			if (i-&gt;type != type) continue;
			ret.insert(i-&gt;url);
		}
		return ret;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(192)">../src/torrent_peer.cpp:179</a></td><td>how do we deal with our external address changing?</td></tr><tr id="192" style="display: none;" colspan="3"><td colspan="3"><h2>how do we deal with our external address changing?</h2><h4>../src/torrent_peer.cpp:179</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		, is_v6_addr(false)
#endif
#if TORRENT_USE_I2P
		, is_i2p_addr(false)
#endif
		, on_parole(false)
		, banned(false)
		, supports_utp(true) // assume peers support utp
		, confirmed_supports_utp(false)
		, supports_holepunch(false)
		, web_seed(false)
#if TORRENT_USE_ASSERTS
		, in_use(false)
#endif
	{
		TORRENT_ASSERT((src &amp; 0xff) == src);
	}

	boost::uint32_t torrent_peer::rank(external_ip const&amp; external, int external_port) const
	{
<div style="background: #ffff00" width="100%">		if (peer_rank == 0)
</div>			peer_rank = peer_priority(
				tcp::endpoint(external.external_address(this-&gt;address()), external_port)
				, tcp::endpoint(this-&gt;address(), this-&gt;port));
		return peer_rank;
	}

	boost::uint64_t torrent_peer::total_download() const
	{
		if (connection != 0)
		{
			TORRENT_ASSERT(prev_amount_download == 0);
			return connection-&gt;statistics().total_payload_download();
		}
		else
		{
			return boost::uint64_t(prev_amount_download) &lt;&lt; 10;
		}
	}

	boost::uint64_t torrent_peer::total_upload() const
	{
		if (connection != 0)
		{
			TORRENT_ASSERT(prev_amount_upload == 0);
			return connection-&gt;statistics().total_payload_upload();
		}
		else
		{
			return boost::uint64_t(prev_amount_upload) &lt;&lt; 10;
		}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(193)">../src/udp_socket.cpp:288</a></td><td>it would be nice to detect this on posix systems also</td></tr><tr id="193" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to detect this on posix systems also</h2><h4>../src/udp_socket.cpp:288</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		--m_v6_outstanding;
	}
	else
#endif
	{
		TORRENT_ASSERT(m_v4_outstanding &gt; 0);
		--m_v4_outstanding;
	}

	if (ec == asio::error::operation_aborted) return;
	if (m_abort) return;

	CHECK_MAGIC;

	for (;;)
	{
		error_code ec;
		udp::endpoint ep;
		size_t bytes_transferred = s-&gt;receive_from(asio::buffer(m_buf, m_buf_size), ep, 0, ec);

<div style="background: #ffff00" width="100%">#ifdef TORRENT_WINDOWS
</div>		if ((ec == error_code(ERROR_MORE_DATA, system_category())
			|| ec == error_code(WSAEMSGSIZE, system_category()))
			&amp;&amp; m_buf_size &lt; 65536)
		{
			// if this function fails to allocate memory, m_buf_size
			// is set to 0. In that case, don't issue the async_read().
			set_buf_size(m_buf_size * 2);
			if (m_buf_size == 0) return;
			continue;
		}
#endif

		if (ec == asio::error::would_block || ec == asio::error::try_again) break;
		on_read_impl(s, ep, ec, bytes_transferred);
	}
	call_drained_handler();
	setup_read(s);
}

void udp_socket::call_handler(error_code const&amp; ec, udp::endpoint const&amp; ep, char const* buf, int size)
{
	m_observers_locked = true;
	for (std::vector&lt;udp_socket_observer*&gt;::iterator i = m_observers.begin();
		i != m_observers.end();)
	{
		bool ret = false;
		TORRENT_TRY {
			ret = (*i)-&gt;incoming_packet(ec, ep, buf, size);
		} TORRENT_CATCH (std::exception&amp;) {}
		if (*i == NULL) i = m_observers.erase(i);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(194)">../src/udp_socket.cpp:779</a></td><td>use the system resolver_interface here</td></tr><tr id="194" style="display: none;" colspan="3"><td colspan="3"><h2>use the system resolver_interface here</h2><h4>../src/udp_socket.cpp:779</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
void udp_socket::set_proxy_settings(proxy_settings const&amp; ps)
{
	CHECK_MAGIC;
	TORRENT_ASSERT(is_single_thread());

	error_code ec;
	m_socks5_sock.close(ec);
	m_tunnel_packets = false;
	
	m_proxy_settings = ps;

	if (m_abort) return;

	if (ps.type == settings_pack::socks5
		|| ps.type == settings_pack::socks5_pw)
	{
		m_queue_packets = true;
		// connect to socks5 server and open up the UDP tunnel

<div style="background: #ffff00" width="100%">		tcp::resolver::query q(ps.hostname, to_string(ps.port).elems);
</div>		++m_outstanding_ops;
#if TORRENT_USE_ASSERTS
		++m_outstanding_resolve;
#endif
#if defined TORRENT_ASIO_DEBUGGING
		add_outstanding_async("udp_socket::on_name_lookup");
#endif
		m_resolver.async_resolve(q, boost::bind(
			&amp;udp_socket::on_name_lookup, this, _1, _2));
	}
}

void udp_socket::on_name_lookup(error_code const&amp; e, tcp::resolver::iterator i)
{
#if defined TORRENT_ASIO_DEBUGGING
	complete_async("udp_socket::on_name_lookup");
#endif
#if TORRENT_USE_ASSERTS
	TORRENT_ASSERT(m_outstanding_resolve &gt; 0);
	--m_outstanding_resolve;
#endif

	TORRENT_ASSERT(m_outstanding_ops &gt; 0);
	--m_outstanding_ops;
	TORRENT_ASSERT(m_outstanding_ops == m_outstanding_connect
		+ m_outstanding_timeout
		+ m_outstanding_resolve
		+ m_outstanding_socks);

	if (m_abort) return;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(195)">../src/ut_metadata.cpp:313</a></td><td>we really need to increment the refcounter on the torrent while this buffer is still in the peer's send buffer</td></tr><tr id="195" style="display: none;" colspan="3"><td colspan="3"><h2>we really need to increment the refcounter on the torrent
while this buffer is still in the peer's send buffer</h2><h4>../src/ut_metadata.cpp:313</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				if (!m_tp.need_loaded()) return;
				metadata = m_tp.metadata().begin + offset;
				metadata_piece_size = (std::min)(
					int(m_tp.get_metadata_size() - offset), 16 * 1024);
				TORRENT_ASSERT(metadata_piece_size &gt; 0);
				TORRENT_ASSERT(offset &gt;= 0);
				TORRENT_ASSERT(offset + metadata_piece_size &lt;= int(m_tp.get_metadata_size()));
			}

			char msg[200];
			char* header = msg;
			char* p = &amp;msg[6];
			int len = bencode(p, e);
			int total_size = 2 + len + metadata_piece_size;
			namespace io = detail;
			io::write_uint32(total_size, header);
			io::write_uint8(bt_peer_connection::msg_extended, header);
			io::write_uint8(m_message_index, header);

			m_pc.send_buffer(msg, len + 6);
<div style="background: #ffff00" width="100%">			if (metadata_piece_size) m_pc.append_const_send_buffer(
</div>				metadata, metadata_piece_size);

			m_pc.stats_counters().inc_stats_counter(counters::num_outgoing_extended);
			m_pc.stats_counters().inc_stats_counter(counters::num_outgoing_metadata);
		}

		virtual bool on_extended(int length
			, int extended_msg, buffer::const_interval body)
		{
			if (extended_msg != 2) return false;
			if (m_message_index == 0) return false;

			if (length &gt; 17 * 1024)
			{
#ifndef TORRENT_DISABLE_LOGGING
				m_pc.peer_log(peer_log_alert::incoming_message, "UT_METADATA"
					, "packet too big %d", length);
#endif
				m_pc.disconnect(errors::invalid_metadata_message, op_bittorrent, 2);
				return true;
			}

			if (!m_pc.packet_finished()) return true;

			int len;
			entry msg = bdecode(body.begin, body.end, len);
			if (msg.type() != entry::dictionary_t)
			{
#ifndef TORRENT_DISABLE_LOGGING
				m_pc.peer_log(peer_log_alert::incoming_message, "UT_METADATA"
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(196)">../src/utp_stream.cpp:1709</a></td><td>this loop is not very efficient. It could be fixed by having a separate list of sequence numbers that need resending</td></tr><tr id="196" style="display: none;" colspan="3"><td colspan="3"><h2>this loop is not very efficient. It could be fixed by having
a separate list of sequence numbers that need resending</h2><h4>../src/utp_stream.cpp:1709</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	char* m_buf;
};

// sends a packet, pulls data from the write buffer (if there's any)
// if ack is true, we need to send a packet regardless of if there's
// any data. Returns true if we could send more data (i.e. call
// send_pkt() again)
// returns true if there is more space for payload in our
// congestion window, false if there is no more space.
bool utp_socket_impl::send_pkt(int flags)
{
	INVARIANT_CHECK;

	bool force = (flags &amp; pkt_ack) || (flags &amp; pkt_fin);

//	TORRENT_ASSERT(m_state != UTP_STATE_FIN_SENT || (flags &amp; pkt_ack));

	// first see if we need to resend any packets

<div style="background: #ffff00" width="100%">	for (int i = (m_acked_seq_nr + 1) &amp; ACK_MASK; i != m_seq_nr; i = (i + 1) &amp; ACK_MASK)
</div>	{
		packet* p = (packet*)m_outbuf.at(i);
		if (!p) continue;
		if (!p-&gt;need_resend) continue;
		if (!resend_packet(p))
		{
			// we couldn't resend the packet. It probably doesn't
			// fit in our cwnd. If force is set, we need to continue
			// to send our packet anyway, if we don't have force set,
			// we might as well return
			if (!force) return false;
			// resend_packet might have failed
			if (m_state == UTP_STATE_ERROR_WAIT || m_state == UTP_STATE_DELETE) return false;
			break;
		}

		// don't fast-resend this packet
		if (m_fast_resend_seq_nr == i)
			m_fast_resend_seq_nr = (m_fast_resend_seq_nr + 1) &amp; ACK_MASK;
	}

	int sack = 0;
	if (m_inbuf.size())
	{
		// the SACK bitfield should ideally fit all
		// the pieces we have successfully received
		sack = (m_inbuf.span() + 7) / 8;
		if (sack &gt; 32) sack = 32;
	}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(197)">../src/web_connection_base.cpp:73</a></td><td>introduce a web-seed default class which has a low download priority</td></tr><tr id="197" style="display: none;" colspan="3"><td colspan="3"><h2>introduce a web-seed default class which has a low download priority</h2><h4>../src/web_connection_base.cpp:73</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">{
	web_connection_base::web_connection_base(
		peer_connection_args const&amp; pack
		, web_seed_t&amp; web)
		: peer_connection(pack)
		, m_first_request(true)
		, m_ssl(false)
		, m_external_auth(web.auth)
		, m_extra_headers(web.extra_headers)
		, m_parser(http_parser::dont_parse_chunks)
		, m_body_start(0)
	{
		TORRENT_ASSERT(&amp;web.peer_info == pack.peerinfo);
		// when going through a proxy, we don't necessarily have an endpoint here,
		// since the proxy might be resolving the hostname, not us
		TORRENT_ASSERT(web.endpoints.empty() || web.endpoints.front() == pack.endp);

		INVARIANT_CHECK;

		// we only want left-over bandwidth
<div style="background: #ffff00" width="100%">		
</div>		std::string protocol;
		error_code ec;
		boost::tie(protocol, m_basic_auth, m_host, m_port, m_path)
			= parse_url_components(web.url, ec);
		TORRENT_ASSERT(!ec);

		if (m_port == -1 &amp;&amp; protocol == "http")
			m_port = 80;

#ifdef TORRENT_USE_OPENSSL
		if (protocol == "https")
		{
			m_ssl = true;
			if (m_port == -1) m_port = 443;
		}
#endif

		if (!m_basic_auth.empty())
			m_basic_auth = base64encode(m_basic_auth);

		m_server_string = "URL seed @ ";
		m_server_string += m_host;
	}

	int web_connection_base::timeout() const
	{
		// since this is a web seed, change the timeout
		// according to the settings.
		return m_settings.get_int(settings_pack::urlseed_timeout);
	}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(198)">../src/kademlia/dht_tracker.cpp:307</a></td><td>ideally this function would be called when the put completes</td></tr><tr id="198" style="display: none;" colspan="3"><td colspan="3"><h2>ideally this function would be called when the
put completes</h2><h4>../src/kademlia/dht_tracker.cpp:307</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// since it controls whether we re-put the content
		TORRENT_ASSERT(!it.is_mutable());
		f(it);
		return false;
	}

	bool get_mutable_item_callback(item&amp; it, boost::function&lt;void(item const&amp;)&gt; f)
	{
		// the reason to wrap here is to control the return value
		// since it controls whether we re-put the content
		TORRENT_ASSERT(it.is_mutable());
		f(it);
		return false;
	}

	bool put_immutable_item_callback(item&amp; it, boost::function&lt;void()&gt; f
		, entry data)
	{
		TORRENT_ASSERT(!it.is_mutable());
		it.assign(data);
<div style="background: #ffff00" width="100%">		f();
</div>		return true;
	}

	bool put_mutable_item_callback(item&amp; it, boost::function&lt;void(item&amp;)&gt; cb)
	{
		cb(it);
		return true;
	}

	} // anonymous namespace

	void dht_tracker::get_item(sha1_hash const&amp; target
		, boost::function&lt;void(item const&amp;)&gt; cb)
	{
		m_dht.get_item(target, boost::bind(&amp;get_immutable_item_callback, _1, cb));
	}

	// key is a 32-byte binary string, the public key to look up.
	// the salt is optional
	void dht_tracker::get_item(char const* key
		, boost::function&lt;void(item const&amp;)&gt; cb
		, std::string salt)
	{
		m_dht.get_item(key, salt, boost::bind(&amp;get_mutable_item_callback, _1, cb));
	}

	void dht_tracker::put_item(entry data
		, boost::function&lt;void()&gt; cb)
	{
		std::string flat_data;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(199)">../include/libtorrent/bitfield.hpp:160</a></td><td>rename to data() ?</td></tr><tr id="199" style="display: none;" colspan="3"><td colspan="3"><h2>rename to data() ?</h2><h4>../include/libtorrent/bitfield.hpp:160</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				if (m_buf[i] != 0) return false;
			}
			return true;
		}

		// returns the size of the bitfield in bits.
		int size() const
		{
			return m_buf == NULL ? 0 : int(m_buf[-1]);
		}

		int num_words() const
		{
			return (size() + 31) / 32;
		}

		// returns true if the bitfield has zero size.
		bool empty() const { return m_buf == NULL ? true : m_buf[-1] == 0; }

		// returns a pointer to the internal buffer of the bitfield.
<div style="background: #ffff00" width="100%">		char const* bytes() const { return reinterpret_cast&lt;char const*&gt;(m_buf); }
</div>
		// copy operator
		bitfield&amp; operator=(bitfield const&amp; rhs)
		{
			assign(rhs.bytes(), rhs.size());
			return *this;
		}

		// count the number of bits in the bitfield that are set to 1.
		int count() const
		{
			int ret = 0;
			const int words = num_words();
#if TORRENT_HAS_SSE
			if (aux::mmx_support)
			{
				for (int i = 0; i &lt; words; ++i)
				{
#ifdef __GNUC__
					ret += __builtin_popcount(m_buf[i]);
#else
					ret += _mm_popcnt_u32(m_buf[i]);
#endif
				}

				return ret;
			}	
#endif // TORRENT_HAS_SSE

			for (int i = 0; i &lt; words; ++i)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(200)">../include/libtorrent/block_cache.hpp:219</a></td><td>make this 32 bits and to count seconds since the block cache was created</td></tr><tr id="200" style="display: none;" colspan="3"><td colspan="3"><h2>make this 32 bits and to count seconds since the block cache was created</h2><h4>../include/libtorrent/block_cache.hpp:219</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		bool operator==(cached_piece_entry const&amp; rhs) const
		{ return storage.get() == rhs.storage.get() &amp;&amp; piece == rhs.piece; }

		// if this is set, we'll be calculating the hash
		// for this piece. This member stores the interim
		// state while we're calulcating the hash.
		partial_hash* hash;

		// set to a unique identifier of a peer that last
		// requested from this piece.
		void* last_requester;

		// the pointers to the block data. If this is a ghost
		// cache entry, there won't be any data here
		boost::shared_array&lt;cached_block_entry&gt; blocks;

		// the last time a block was written to this piece
		// plus the minimum amount of time the block is guaranteed
		// to stay in the cache
<div style="background: #ffff00" width="100%">		time_point expire;
</div>
		boost::uint64_t piece:22;

		// the number of dirty blocks in this piece
		boost::uint64_t num_dirty:14;
		
		// the number of blocks in the cache for this piece
		boost::uint64_t num_blocks:14;

		// the total number of blocks in this piece (and the number
		// of elements in the blocks array)
		boost::uint64_t blocks_in_piece:14;

		// ---- 64 bit boundary ----

		// while we have an outstanding async hash operation
		// working on this piece, 'hashing' is set to 1
		// When the operation returns, this is set to 0.
		boost::uint32_t hashing:1;

		// if we've completed at least one hash job on this
		// piece, and returned it. This is set to one
		boost::uint32_t hashing_done:1;

		// if this is true, whenever refcount hits 0, 
		// this piece should be deleted
		boost::uint32_t marked_for_deletion:1;

		// this is set to true once we flush blocks past
		// the hash cursor. Once this happens, there's
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(201)">../include/libtorrent/config.hpp:339</a></td><td>Make this count Unicode characters instead of bytes on windows</td></tr><tr id="201" style="display: none;" colspan="3"><td colspan="3"><h2>Make this count Unicode characters instead of bytes on windows</h2><h4>../include/libtorrent/config.hpp:339</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#pragma message ( "unknown OS, assuming BSD" )
#else
#warning "unknown OS, assuming BSD"
#endif

#define TORRENT_BSD
#endif

#if defined __GNUC__ &amp;&amp; !(defined TORRENT_USE_OSATOMIC \
	|| defined TORRENT_USE_INTERLOCKED_ATOMIC \
	|| defined TORRENT_USE_BEOS_ATOMIC \
	|| defined TORRENT_USE_SOLARIS_ATOMIC)
// atomic operations in GCC were introduced in 4.1.1
# if (__GNUC__ &gt;= 4 &amp;&amp; __GNUC_MINOR__ &gt;= 1 &amp;&amp; __GNUC_PATCHLEVEL__ &gt;= 1) || __GNUC__ &gt; 4
#  define TORRENT_USE_GCC_ATOMIC 1
# endif
#endif

// on windows, NAME_MAX refers to Unicode characters
// on linux it refers to bytes (utf-8 encoded)
<div style="background: #ffff00" width="100%">
</div>// windows
#if defined FILENAME_MAX
#define TORRENT_MAX_PATH FILENAME_MAX

// beos
#elif defined B_PATH_NAME_LENGTH
#define TORRENT_MAX_PATH B_PATH_NAME_LENGTH

// solaris
#elif defined MAXPATH
#define TORRENT_MAX_PATH MAXPATH

// posix
#elif defined NAME_MAX
#define TORRENT_MAX_PATH NAME_MAX

// none of the above
#else
// this is the maximum number of characters in a
// path element / filename on windows
#define TORRENT_MAX_PATH 255

#ifdef _MSC_VER
#pragma message ( "unknown platform, assuming the longest path is 255" )
#else
#warning "unknown platform, assuming the longest path is 255"
#endif

#endif

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(202)">../include/libtorrent/disk_buffer_pool.hpp:137</a></td><td>try to remove the observers, only using the async_allocate handlers</td></tr><tr id="202" style="display: none;" colspan="3"><td colspan="3"><h2>try to remove the observers, only using the async_allocate handlers</h2><h4>../include/libtorrent/disk_buffer_pool.hpp:137</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// number of bytes per block. The BitTorrent
		// protocol defines the block size to 16 KiB.
		const int m_block_size;

		// number of disk buffers currently allocated
		int m_in_use;

		// cache size limit
		int m_max_use;

		// if we have exceeded the limit, we won't start
		// allowing allocations again until we drop below
		// this low watermark
		int m_low_watermark;

		// if we exceed the max number of buffers, we start
		// adding up callbacks to this queue. Once the number
		// of buffers in use drops below the low watermark,
		// we start calling these functions back
<div style="background: #ffff00" width="100%">		std::vector&lt;boost::shared_ptr&lt;disk_observer&gt; &gt; m_observers;
</div>
		// these handlers are executed when a new buffer is available
		std::vector&lt;handler_t&gt; m_handlers;

		// callback used to tell the cache it needs to free up some blocks
		boost::function&lt;void()&gt; m_trigger_cache_trim;

		// set to true to throttle more allocations
		bool m_exceeded_max_size;

		// this is the main thread io_service. Callbacks are
		// posted on this in order to have them execute in
		// the main thread.
		io_service&amp; m_ios;

	private:

		void check_buffer_level(mutex::scoped_lock&amp; l);

		mutable mutex m_pool_mutex;

		int m_cache_buffer_chunk_size;
		bool m_lock_disk_cache;

#if TORRENT_HAVE_MMAP
		// the file descriptor of the cache mmap file
		int m_cache_fd;
		// the pointer to the block of virtual address space
		// making up the mmapped cache space
		char* m_cache_pool;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(203)">../include/libtorrent/file.hpp:173</a></td><td>move this into a separate header file, TU pair</td></tr><tr id="203" style="display: none;" colspan="3"><td colspan="3"><h2>move this into a separate header file, TU pair</h2><h4>../include/libtorrent/file.hpp:173</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	TORRENT_EXTRA_EXPORT std::string parent_path(std::string const&amp; f);
	TORRENT_EXTRA_EXPORT bool has_parent_path(std::string const&amp; f);
	TORRENT_EXTRA_EXPORT char const* filename_cstr(char const* f);

	// internal used by create_torrent.hpp
	TORRENT_EXTRA_EXPORT std::string filename(std::string const&amp; f);
	TORRENT_EXTRA_EXPORT std::string combine_path(std::string const&amp; lhs
		, std::string const&amp; rhs);
	TORRENT_EXTRA_EXPORT void append_path(std::string&amp; branch
		, std::string const&amp; leaf);
	TORRENT_EXTRA_EXPORT void append_path(std::string&amp; branch
		, char const* str, int len);
	// internal used by create_torrent.hpp
	TORRENT_EXTRA_EXPORT std::string complete(std::string const&amp; f);
	TORRENT_EXTRA_EXPORT bool is_complete(std::string const&amp; f);
	TORRENT_EXTRA_EXPORT std::string current_working_directory();
#if TORRENT_USE_UNC_PATHS
	TORRENT_EXTRA_EXPORT std::string canonicalize_path(std::string const&amp; f);
#endif

<div style="background: #ffff00" width="100%">	class TORRENT_EXTRA_EXPORT directory : public boost::noncopyable
</div>	{
	public:
		directory(std::string const&amp; path, error_code&amp; ec);
		~directory();
		void next(error_code&amp; ec);
		std::string file() const;
		boost::uint64_t inode() const;
		bool done() const { return m_done; }
	private:
#ifdef TORRENT_WINDOWS
		HANDLE m_handle;
		int m_inode;
#if TORRENT_USE_WSTRING
		WIN32_FIND_DATAW m_fd;
#else
		WIN32_FIND_DATAA m_fd;
#endif
#else
		DIR* m_handle;
		// the dirent struct contains a zero-sized
		// array at the end, it will end up referring
		// to the m_name field
		struct dirent m_dirent;
		char m_name[TORRENT_MAX_PATH + 1]; // +1 to make room for null
#endif
		bool m_done;
	};

	struct file;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(204)">../include/libtorrent/heterogeneous_queue.hpp:185</a></td><td>if this throws, should we do anything?</td></tr><tr id="204" style="display: none;" colspan="3"><td colspan="3"><h2>if this throws, should we do anything?</h2><h4>../include/libtorrent/heterogeneous_queue.hpp:185</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			- 1) / sizeof(uintptr_t);

		void grow_capacity(int size)
		{
			int amount_to_grow = (std::max)(size + header_size
				, (std::max)(m_capacity * 3 / 2, 128));

			uintptr_t* new_storage = new uintptr_t[m_capacity + amount_to_grow];

			uintptr_t* src = m_storage;
			uintptr_t* dst = new_storage;
			uintptr_t const* const end = m_storage + m_size;
			while (src &lt; end)
			{
				header_t* src_hdr = reinterpret_cast&lt;header_t*&gt;(src);
				header_t* dst_hdr = reinterpret_cast&lt;header_t*&gt;(dst);
				*dst_hdr = *src_hdr;
				src += header_size;
				dst += header_size;
				TORRENT_ASSERT(src + src_hdr-&gt;len &lt;= end);
<div style="background: #ffff00" width="100%">				src_hdr-&gt;move(dst, src);
</div>				src += src_hdr-&gt;len;
				dst += src_hdr-&gt;len;
			}

			delete[] m_storage;
			m_storage = new_storage;
			m_capacity += amount_to_grow;
		}

		template &lt;class U&gt;
		static void move(uintptr_t* dst, uintptr_t* src)
		{
			U* rhs = reinterpret_cast&lt;U*&gt;(src);
#if __cplusplus &gt;= 201103L
			new (dst) U(std::move(*rhs));
#else
			new (dst) U(*rhs);
#endif
			rhs-&gt;~U();
		}

		uintptr_t* m_storage;
		// number of uintptr_t's allocated under m_storage
		int m_capacity;
		// the number of uintptr_t's used under m_storage
		int m_size;
		// the number of objects allocated under m_storage
		int m_num_items;
	};
}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(205)">../include/libtorrent/peer_connection.hpp:204</a></td><td>make this a raw pointer (to save size in the first cache line) and make the constructor take a raw pointer. torrent objects should always outlive their peers</td></tr><tr id="205" style="display: none;" colspan="3"><td colspan="3"><h2>make this a raw pointer (to save size in
the first cache line) and make the constructor
take a raw pointer. torrent objects should always
outlive their peers</h2><h4>../include/libtorrent/peer_connection.hpp:204</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			, m_connecting(!t.expired())
			, m_endgame_mode(false)
			, m_snubbed(false)
			, m_interesting(false)
			, m_choked(true)
			, m_corked(false)
			, m_ignore_stats(false)
		{}

	protected:

		// the pieces the other end have
		bitfield m_have_piece;

		// this is the torrent this connection is
		// associated with. If the connection is an
		// incoming connection, this is set to zero
		// until the info_hash is received. Then it's
		// set to the torrent it belongs to.

<div style="background: #ffff00" width="100%">		boost::weak_ptr&lt;torrent&gt; m_torrent;
</div>	
	public:

		// a back reference to the session
		// the peer belongs to.
		aux::session_interface&amp; m_ses;

		// settings that apply to this peer
		aux::session_settings const&amp; m_settings;
		
	protected:

		// this is true if this connection has been added
		// to the list of connections that will be closed.
		bool m_disconnecting:1;

		// this is true until this socket has become
		// writable for the first time (i.e. the
		// connection completed). While connecting
		// the timeout will not be triggered. This is
		// because windows XP SP2 may delay connection
		// attempts, which means that the connection
		// may not even have been attempted when the
		// time out is reached.
		bool m_connecting:1;

		// this is set to true if the last time we tried to
		// pick a piece to download, we could only find
		// blocks that were already requested from other
		// peers. In this case, we should not try to pick
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(206)">../include/libtorrent/peer_connection.hpp:1047</a></td><td>factor this out into its own class with a virtual interface torrent and session should implement this interface</td></tr><tr id="206" style="display: none;" colspan="3"><td colspan="3"><h2>factor this out into its own class with a virtual interface
torrent and session should implement this interface</h2><h4>../include/libtorrent/peer_connection.hpp:1047</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// the local endpoint for this peer, i.e. our address
		// and our port. If this is set for outgoing connections
		// before the connection completes, it means we want to
		// force the connection to be bound to the specified interface.
		// if it ends up being bound to a different local IP, the connection
		// is closed.
		tcp::endpoint m_local;
		
		// remote peer's id
		peer_id m_peer_id;

		// the bandwidth channels, upload and download
		// keeps track of the current quotas
		bandwidth_channel m_bandwidth_channel[num_channels];

	protected:
		// statistics about upload and download speeds
		// and total amount of uploads and downloads for
		// this peer
<div style="background: #ffff00" width="100%">		stat m_statistics;
</div>
		// the number of outstanding bytes expected
		// to be received by extensions
		int m_extension_outstanding_bytes;

		// the number of time critical requests
		// queued up in the m_request_queue that
		// soon will be committed to the download
		// queue. This is included in download_queue_time()
		// so that it can be used while adding more
		// requests and take the previous requests
		// into account without submitting it all
		// immediately
		int m_queued_time_critical;

		// the number of bytes we are currently reading
		// from disk, that will be added to the send
		// buffer as soon as they complete
		int m_reading_bytes;
		
		// options used for the piece picker. These flags will
		// be augmented with flags controlled by other settings
		// like sequential download etc. These are here to
		// let plugins control flags that should always be set
		int m_picker_options;
		
		// the number of invalid piece-requests
		// we have got from this peer. If the request
		// queue gets empty, and there have been
		// invalid requests, we can assume the
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(207)">../include/libtorrent/peer_connection_interface.hpp:47</a></td><td>make this interface smaller!</td></tr><tr id="207" style="display: none;" colspan="3"><td colspan="3"><h2>make this interface smaller!</h2><h4>../include/libtorrent/peer_connection_interface.hpp:47</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

*/

#ifndef TORRENT_PEER_CONNECTION_INTERFACE_HPP
#define TORRENT_PEER_CONNECTION_INTERFACE_HPP

#include "libtorrent/socket.hpp"
#include "libtorrent/error_code.hpp"
#include "libtorrent/alert_types.hpp"
#include "libtorrent/operations.hpp" // for operation_t enum

namespace libtorrent
{
	struct torrent_peer;
	class stat;
	struct peer_info;

<div style="background: #ffff00" width="100%">	struct peer_connection_interface
</div>	{
		virtual tcp::endpoint const&amp; remote() const = 0;
		virtual tcp::endpoint local_endpoint() const = 0;
		virtual void disconnect(error_code const&amp; ec
			, operation_t op, int error = 0) = 0;
		virtual peer_id const&amp; pid() const = 0;
		virtual void set_holepunch_mode() = 0;
		virtual torrent_peer* peer_info_struct() const = 0;
		virtual void set_peer_info(torrent_peer* pi) = 0;
		virtual bool is_outgoing() const = 0;
		virtual void add_stat(boost::int64_t downloaded, boost::int64_t uploaded) = 0;
		virtual bool fast_reconnect() const = 0;
		virtual bool is_choked() const = 0;
		virtual bool failed() const = 0;
		virtual stat const&amp; statistics() const = 0;
		virtual void get_peer_info(peer_info&amp; p) const = 0;
#ifndef TORRENT_DISABLE_LOGGING
		virtual void peer_log(peer_log_alert::direction_t direction
			, char const* event, char const* fmt = "", ...) const
#if defined __GNUC__ || defined __clang__
			__attribute__((format(printf, 4, 5)))
#endif
			= 0;
#endif
	protected:
		~peer_connection_interface() {}
	};
}

#endif
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(208)">../include/libtorrent/performance_counters.hpp:139</a></td><td>should keepalives be in here too? how about dont-have, share-mode, upload-only</td></tr><tr id="208" style="display: none;" colspan="3"><td colspan="3"><h2>should keepalives be in here too?
how about dont-have, share-mode, upload-only</h2><h4>../include/libtorrent/performance_counters.hpp:139</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// a connect candidate
			connection_attempt_loops,
			// successful incoming connections (not rejected for any reason)
			incoming_connections,

			// counts events where the network
			// thread wakes up
			on_read_counter,
			on_write_counter,
			on_tick_counter,
			on_lsd_counter,
			on_lsd_peer_counter,
			on_udp_counter,
			on_accept_counter,
			on_disk_queue_counter,
			on_disk_counter,

			torrent_evicted_counter,

			// bittorrent message counters
<div style="background: #ffff00" width="100%">			num_incoming_choke,
</div>			num_incoming_unchoke,
			num_incoming_interested,
			num_incoming_not_interested,
			num_incoming_have,
			num_incoming_bitfield,
			num_incoming_request,
			num_incoming_piece,
			num_incoming_cancel,
			num_incoming_dht_port,
			num_incoming_suggest,
			num_incoming_have_all,
			num_incoming_have_none,
			num_incoming_reject,
			num_incoming_allowed_fast,
			num_incoming_ext_handshake,
			num_incoming_pex,
			num_incoming_metadata,
			num_incoming_extended,

			num_outgoing_choke,
			num_outgoing_unchoke,
			num_outgoing_interested,
			num_outgoing_not_interested,
			num_outgoing_have,
			num_outgoing_bitfield,
			num_outgoing_request,
			num_outgoing_piece,
			num_outgoing_cancel,
			num_outgoing_dht_port,
			num_outgoing_suggest,
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(209)">../include/libtorrent/performance_counters.hpp:449</a></td><td>some space could be saved here by making gauges 32 bits</td></tr><tr id="209" style="display: none;" colspan="3"><td colspan="3"><h2>some space could be saved here by making gauges 32 bits</h2><h4>../include/libtorrent/performance_counters.hpp:449</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(210)">../include/libtorrent/performance_counters.hpp:450</a></td><td>restore these to regular integers. Instead have one copy of the counters per thread and collect them at convenient synchronization points</td></tr><tr id="210" style="display: none;" colspan="3"><td colspan="3"><h2>restore these to regular integers. Instead have one copy
of the counters per thread and collect them at convenient
synchronization points</h2><h4>../include/libtorrent/performance_counters.hpp:450</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			num_utp_deleted,

			num_counters,
			num_gauge_counters = num_counters - num_stats_counters
		};

		counters();

		counters(counters const&amp;);
		counters&amp; operator=(counters const&amp;);

		// returns the new value
		boost::int64_t inc_stats_counter(int c, boost::int64_t value = 1);
		boost::int64_t operator[](int i) const;

		void set_value(int c, boost::int64_t value);
		void blend_stats_counter(int c, boost::int64_t value, int ratio);

	private:

<div style="background: #ffff00" width="100%">#if BOOST_ATOMIC_LLONG_LOCK_FREE == 2
</div>		boost::atomic&lt;boost::int64_t&gt; m_stats_counter[num_counters];
#else
		// if the atomic type is't lock-free, use a single lock instead, for
		// the whole array
		mutable mutex m_mutex;
		boost::int64_t m_stats_counter[num_counters];
#endif
	};
}

#endif

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(211)">../include/libtorrent/piece_picker.hpp:762</a></td><td>should this be allocated lazily?</td></tr><tr id="211" style="display: none;" colspan="3"><td colspan="3"><h2>should this be allocated lazily?</h2><h4>../include/libtorrent/piece_picker.hpp:762</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		std::vector&lt;downloading_piece&gt;::const_iterator find_dl_piece(int queue, int index) const;
		std::vector&lt;downloading_piece&gt;::iterator find_dl_piece(int queue, int index);

		// returns an iterator to the downloading piece, whichever
		// download list it may live in now
		std::vector&lt;downloading_piece&gt;::iterator update_piece_state(
			std::vector&lt;downloading_piece&gt;::iterator dp);

	private:

		// the following vectors are mutable because they sometimes may
		// be updated lazily, triggered by const functions

		// this maps indices to number of peers that has this piece and
		// index into the m_piece_info vectors.
		// piece_pos::we_have_index means that we have the piece, so it
		// doesn't exist in the piece_info buckets
		// pieces with the filtered flag set doesn't have entries in
		// the m_piece_info buckets either
<div style="background: #ffff00" width="100%">		mutable std::vector&lt;piece_pos&gt; m_piece_map;
</div>
		// the number of seeds. These are not added to
		// the availability counters of the pieces
		int m_seeds;

		// the number of pieces that have passed the hash check
		int m_num_passed;

		// this vector contains all piece indices that are pickable
		// sorted by priority. Pieces are in random random order
		// among pieces with the same priority
		mutable std::vector&lt;int&gt; m_pieces;

		// these are indices to the priority boundries inside
		// the m_pieces vector. priority 0 always start at
		// 0, priority 1 starts at m_priority_boundries[0] etc.
		mutable std::vector&lt;int&gt; m_priority_boundries;

		// each piece that's currently being downloaded has an entry in this list
		// with block allocations. i.e. it says wich parts of the piece that is
		// being downloaded. This list is ordered by piece index to make lookups
		// efficient there are as many buckets as there are piece states. See
		// piece_pos::state_t. The only download state that does not have a
		// corresponding downloading_piece vector is piece_open and
		// piece_downloading_reverse (the latter uses the same as
		// piece_downloading).
		std::vector&lt;downloading_piece&gt; m_downloads[piece_pos::num_download_categories];

		// this holds the information of the blocks in partially downloaded
		// pieces. the downloading_piece::info index point into this vector for
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(212)">../include/libtorrent/proxy_base.hpp:173</a></td><td>it would be nice to remember the bind port and bind once we know where the proxy is m_sock.bind(endpoint, ec);</td></tr><tr id="212" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to remember the bind port and bind once we know where the proxy is
m_sock.bind(endpoint, ec);</h2><h4>../include/libtorrent/proxy_base.hpp:173</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	void bind(endpoint_type const&amp; /* endpoint */)
	{
//		m_sock.bind(endpoint);
	}
#endif

	error_code cancel(error_code&amp; ec)
	{
		return m_sock.cancel(ec);
	}

	void bind(endpoint_type const&amp; /* endpoint */, error_code&amp; /* ec */)
	{
		// the reason why we ignore binds here is because we don't
		// (necessarily) yet know what address family the proxy
		// will resolve to, and binding to the wrong one would
		// break our connection attempt later. The caller here
		// doesn't necessarily know that we're proxying, so this
		// bind address is based on the final endpoint, not the
		// proxy.
<div style="background: #ffff00" width="100%">	}
</div>
#ifndef BOOST_NO_EXCEPTIONS
	void open(protocol_type const&amp;)
	{
//		m_sock.open(p);
	}
#endif

	void open(protocol_type const&amp;, error_code&amp;)
	{
		// we need to ignore this for the same reason as stated
		// for ignoring bind()
//		m_sock.open(p, ec);
	}

#ifndef BOOST_NO_EXCEPTIONS
	void close()
	{
		m_remote_endpoint = endpoint_type();
		m_sock.close();
		m_resolver.cancel();
	}
#endif

	void close(error_code&amp; ec)
	{
		m_remote_endpoint = endpoint_type();
		m_sock.close(ec);
		m_resolver.cancel();
	}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(213)">../include/libtorrent/receive_buffer.hpp:258</a></td><td>Detect when the start of the next crpyto packet is aligned with the start of piece data and the crpyto packet is at least as large as the piece data. With a little extra work we could receive directly into a disk buffer in that case.</td></tr><tr id="213" style="display: none;" colspan="3"><td colspan="3"><h2>Detect when the start of the next crpyto packet is aligned
with the start of piece data and the crpyto packet is at least
as large as the piece data. With a little extra work
we could receive directly into a disk buffer in that case.</h2><h4>../include/libtorrent/receive_buffer.hpp:258</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	void cut(int size, int packet_size, int offset = 0);

	void crypto_cut(int size, int packet_size)
	{
		TORRENT_ASSERT(m_recv_pos != INT_MAX);
		m_connection_buffer.cut(size, m_recv_pos + packet_size, m_recv_pos);
	}

	void reset(int packet_size);
	void crypto_reset(int packet_size);

	void set_soft_packet_size(int size);

	int advance_pos(int bytes);

	buffer::const_interval get() const;

	bool can_recv_contiguous(int /*size*/) const
	{
<div style="background: #ffff00" width="100%">		return m_recv_pos == INT_MAX;
</div>	}

	void mutable_buffers(std::vector&lt;boost::asio::mutable_buffer&gt;&amp; vec
		, std::size_t bytes_transfered);

private:
	// explicitly disallow assignment, to silence msvc warning
	crypto_receive_buffer&amp; operator=(crypto_receive_buffer const&amp;);

	int m_recv_pos;
	int m_packet_size;
	int m_soft_packet_size;
	receive_buffer&amp; m_connection_buffer;
};
#endif // TORRENT_DISABLE_ENCRYPTION

} // namespace libtorrent

#endif // #ifndef TORRENT_RECEIVE_BUFFER_HPP_INCLUDED
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(214)">../include/libtorrent/session.hpp:844</a></td><td>add get_peer_class_type_filter() as well</td></tr><tr id="214" style="display: none;" colspan="3"><td colspan="3"><h2>add get_peer_class_type_filter() as well</h2><h4>../include/libtorrent/session.hpp:844</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// 
		// The ``peer_class`` argument cannot be greater than 31. The bitmasks
		// representing peer classes in the ``peer_class_filter`` are 32 bits.
		// 
		// For more information, see peer-classes_.
		void set_peer_class_filter(ip_filter const&amp; f);

		// Sets and gets the *peer class type filter*. This is controls automatic
		// peer class assignments to peers based on what kind of socket it is.
		// 
		// It does not only support assigning peer classes, it also supports
		// removing peer classes based on socket type.
		//
		// The order of these rules being applied are:
		// 
		// 1. peer-class IP filter
		// 2. peer-class type filter, removing classes
		// 3. peer-class type filter, adding classes
		//
		// For more information, see peer-classes_.
<div style="background: #ffff00" width="100%">		void set_peer_class_type_filter(peer_class_type_filter const&amp; f);
</div>
		// Creates a new peer class (see peer-classes_) with the given name. The
		// returned integer is the new peer class' identifier. Peer classes may
		// have the same name, so each invocation of this function creates a new
		// class and returns a unique identifier.
		// 
		// Identifiers are assigned from low numbers to higher. So if you plan on
		// using certain peer classes in a call to `set_peer_class_filter()`_,
		// make sure to create those early on, to get low identifiers.
		// 
		// For more information on peer classes, see peer-classes_.
		int create_peer_class(char const* name);

		// This call dereferences the reference count of the specified peer
		// class. When creating a peer class it's automatically referenced by 1.
		// If you want to recycle a peer class, you may call this function. You
		// may only call this function **once** per peer class you create.
		// Calling it more than once for the same class will lead to memory
		// corruption.
		// 
		// Since peer classes are reference counted, this function will not
		// remove the peer class if it's still assigned to torrents or peers. It
		// will however remove it once the last peer and torrent drops their
		// references to it.
		// 
		// There is no need to call this function for custom peer classes. All
		// peer classes will be properly destructed when the session object
		// destructs.
		// 
		// For more information on peer classes, see peer-classes_.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(215)">../include/libtorrent/settings_pack.hpp:1097</a></td><td>deprecate this ``max_rejects`` is the number of piece requests we will reject in a row while a peer is choked before the peer is considered abusive and is disconnected.</td></tr><tr id="215" style="display: none;" colspan="3"><td colspan="3"><h2>deprecate this
``max_rejects`` is the number of piece requests we will reject in a
row while a peer is choked before the peer is considered abusive
and is disconnected.</h2><h4>../include/libtorrent/settings_pack.hpp:1097</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			auto_manage_startup,

			// ``seeding_piece_quota`` is the number of pieces to send to a peer,
			// when seeding, before rotating in another peer to the unchoke set.
			// It defaults to 3 pieces, which means that when seeding, any peer
			// we've sent more than this number of pieces to will be unchoked in
			// favour of a choked peer.
			seeding_piece_quota,

			// ``max_sparse_regions`` is a limit of the number of *sparse regions*
			// in a torrent. A sparse region is defined as a hole of pieces we
			// have not yet downloaded, in between pieces that have been
			// downloaded. This is used as a hack for windows vista which has a
			// bug where you cannot write files with more than a certain number of
			// sparse regions. This limit is not hard, it will be exceeded. Once
			// it's exceeded, pieces that will maintain or decrease the number of
			// sparse regions are prioritized. To disable this functionality, set
			// this to 0. It defaults to 0 on all platforms except windows.
			max_sparse_regions,

<div style="background: #ffff00" width="100%">			max_rejects,
</div>
			// ``recv_socket_buffer_size`` and ``send_socket_buffer_size``
			// specifies the buffer sizes set on peer sockets. 0 (which is the
			// default) means the OS default (i.e. don't change the buffer sizes).
			// The socket buffer sizes are changed using setsockopt() with
			// SOL_SOCKET/SO_RCVBUF and SO_SNDBUFFER.
			recv_socket_buffer_size,
			send_socket_buffer_size,

			// ``file_checks_delay_per_block`` is the number of milliseconds to
			// sleep in between disk read operations when checking torrents. This
			// defaults to 0, but can be set to higher numbers to slow down the
			// rate at which data is read from the disk while checking. This may
			// be useful for background tasks that doesn't matter if they take a
			// bit longer, as long as they leave disk I/O time for other
			// processes.
			file_checks_delay_per_block,

			// ``read_cache_line_size`` is the number of blocks to read into the
			// read cache when a read cache miss occurs. Setting this to 0 is
			// essentially the same thing as disabling read cache. The number of
			// blocks read into the read cache is always capped by the piece
			// boundry.
			// 
			// When a piece in the write cache has ``write_cache_line_size``
			// contiguous blocks in it, they will be flushed. Setting this to 1
			// effectively disables the write cache.
			read_cache_line_size,
			write_cache_line_size,

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(216)">../include/libtorrent/torrent.hpp:1267</a></td><td>this wastes 5 bits per file</td></tr><tr id="216" style="display: none;" colspan="3"><td colspan="3"><h2>this wastes 5 bits per file</h2><h4>../include/libtorrent/torrent.hpp:1267</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		typedef std::list&lt;boost::shared_ptr&lt;torrent_plugin&gt; &gt; extension_list_t;
		extension_list_t m_extensions;
#endif

		// used for tracker announces
		deadline_timer m_tracker_timer;

		// used to detect when we are active or inactive for long enough
		// to trigger the auto-manage logic
		deadline_timer m_inactivity_timer;

		// this is the upload and download statistics for the whole torrent.
		// it's updated from all its peers once every second.
		libtorrent::stat m_stat;

		// -----------------------------

		// this vector is allocated lazily. If no file priorities are
		// ever changed, this remains empty. Any unallocated slot
		// implicitly means the file has priority 1.
<div style="background: #ffff00" width="100%">		std::vector&lt;boost::uint8_t&gt; m_file_priority;
</div>
		// this vector contains the number of bytes completely
		// downloaded (as in passed-hash-check) in each file.
		// this lets us trigger on individual files completing
		// the vector is allocated lazily, when file progress
		// is first queried by the client
		std::vector&lt;boost::uint64_t&gt; m_file_progress;

		// these are the pieces we're currently
		// suggesting to peers.
		std::vector&lt;suggest_piece_t&gt; m_suggested_pieces;
		
		std::vector&lt;announce_entry&gt; m_trackers;
		// this is an index into m_trackers

		// this list is sorted by time_critical_piece::deadline
		std::vector&lt;time_critical_piece&gt; m_time_critical_pieces;

		std::string m_trackerid;
		std::string m_username;
		std::string m_password;

		std::string m_save_path;

		// if we don't have the metadata, this is a url to
		// the torrent file
		std::string m_url;

		// if this was added from an RSS feed, this is the unique
		// identifier in the feed.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(217)">../include/libtorrent/torrent.hpp:1326</a></td><td>These two bitfields should probably be coalesced into one</td></tr><tr id="217" style="display: none;" colspan="3"><td colspan="3"><h2>These two bitfields should probably be coalesced into one</h2><h4>../include/libtorrent/torrent.hpp:1326</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// the .torrent file from m_url
//		std::vector&lt;char&gt; m_torrent_file_buf;

		// this is a list of all pieces that we have announced
		// as having, without actually having yet. If we receive
		// a request for a piece in this list, we need to hold off
		// on responding until we have completed the piece and
		// verified its hash. If the hash fails, send reject to
		// peers with outstanding requests, and dont_have to other
		// peers. This vector is ordered, to make lookups fast.
		std::vector&lt;int&gt; m_predictive_pieces;

		// the performance counters of this session
		counters&amp; m_stats_counters;

		// each bit represents a piece. a set bit means
		// the piece has had its hash verified. This
		// is only used in seed mode (when m_seed_mode
		// is true)

<div style="background: #ffff00" width="100%">		bitfield m_verified;
</div>		// this means there is an outstanding, async, operation
		// to verify each piece that has a 1
		bitfield m_verifying;

		// set if there's an error on this torrent
		error_code m_error;

		// used if there is any resume data
		boost::scoped_ptr&lt;resume_data_t&gt; m_resume_data;

		// if the torrent is started without metadata, it may
		// still be given a name until the metadata is received
		// once the metadata is received this field will no
		// longer be used and will be reset
		boost::scoped_ptr&lt;std::string&gt; m_name;

		storage_constructor_type m_storage_constructor;

		// the posix time this torrent was added and when
		// it was completed. If the torrent isn't yet
		// completed, m_completed_time is 0
		time_t m_added_time;
		time_t m_completed_time;

		// this was the last time _we_ saw a seed in this swarm
		time_t m_last_seen_complete;

		// this is the time last any of our peers saw a seed
		// in this swarm
		time_t m_swarm_last_seen_complete;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(218)">../include/libtorrent/torrent_info.hpp:115</a></td><td>include the number of peers received from this tracker, at last announce</td></tr><tr id="218" style="display: none;" colspan="3"><td colspan="3"><h2>include the number of peers received from this tracker, at last
announce</h2><h4>../include/libtorrent/torrent_info.hpp:115</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// if this tracker failed the last time it was contacted
		// this error code specifies what error occurred
		error_code last_error;

		// returns the number of seconds to the next announce on this tracker.
		// ``min_announce_in()`` returns the number of seconds until we are
		// allowed to force another tracker update with this tracker.
		// 
		// If the last time this tracker was contacted failed, ``last_error`` is
		// the error code describing what error occurred.
		int next_announce_in() const;
		int min_announce_in() const;

		// the time of next tracker announce
		time_point next_announce;

		// no announces before this time
		time_point min_announce;

<div style="background: #ffff00" width="100%">
</div>		// these are either -1 or the scrape information this tracker last
		// responded with. *incomplete* is the current number of downloaders in
		// the swarm, *complete* is the current number of seeds in the swarm and
		// *downloaded* is the cumulative number of completed downloads of this
		// torrent, since the beginning of time (from this tracker's point of
		// view).

		// if this tracker has returned scrape data, these fields are filled in
		// with valid numbers. Otherwise they are set to -1. the number of
		// current downloaders
		int scrape_incomplete;
		int scrape_complete;
		int scrape_downloaded;

		// the tier this tracker belongs to
		boost::uint8_t tier;

		// the max number of failures to announce to this tracker in
		// a row, before this tracker is not used anymore. 0 means unlimited
		boost::uint8_t fail_limit;

		// the number of times in a row we have failed to announce to this
		// tracker.
		boost::uint8_t fails:7;

		// true while we're waiting for a response from the tracker.
		bool updating:1;

		// flags for the source bitmask, each indicating where
		// we heard about this tracker
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(219)">../include/libtorrent/torrent_info.hpp:262</a></td><td>there may be some opportunities to optimize the size if torrent_info. specifically to turn some std::string and std::vector into pointers</td></tr><tr id="219" style="display: none;" colspan="3"><td colspan="3"><h2>there may be some opportunities to optimize the size if torrent_info.
specifically to turn some std::string and std::vector into pointers</h2><h4>../include/libtorrent/torrent_info.hpp:262</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// The URL of the web seed
		std::string url;

		// Optional authentication. If this is set, it's passed
		// in as HTTP basic auth to the web seed. The format is:
		// username:password.
		std::string auth;

		// Any extra HTTP headers that need to be passed to the web seed
		headers_t extra_headers;

		// The type of web seed (see type_t)
		boost::uint8_t type;
	};

#ifndef BOOST_NO_EXCEPTIONS
	// for backwards compatibility with 0.14
	typedef libtorrent_exception invalid_torrent_file;
#endif

<div style="background: #ffff00" width="100%">	class TORRENT_EXPORT torrent_info
</div>	{
	public:

		// The constructor that takes an info-hash  will initialize the info-hash
		// to the given value, but leave all other fields empty. This is used
		// internally when downloading torrents without the metadata. The
		// metadata will be created by libtorrent as soon as it has been
		// downloaded from the swarm.
		// 
		// The constructor that takes a bdecode_node will create a torrent_info
		// object from the information found in the given torrent_file. The
		// bdecode_node represents a tree node in an bencoded file. To load an
		// ordinary .torrent file into a bdecode_node, use bdecode().
		// 
		// The version that takes a buffer pointer and a size will decode it as a
		// .torrent file and initialize the torrent_info object for you.
		// 
		// The version that takes a filename will simply load the torrent file
		// and decode it inside the constructor, for convenience. This might not
		// be the most suitable for applications that want to be able to report
		// detailed errors on what might go wrong.
		//
		// There is an upper limit on the size of the torrent file that will be
		// loaded by the overload taking a filename. If it's important that even
		// very large torrent files are loaded, use one of the other overloads.
		// 
		// The overloads that takes an ``error_code const&amp;`` never throws if an
		// error occur, they will simply set the error code to describe what went
		// wrong and not fully initialize the torrent_info object. The overloads
		// that do not take the extra error_code parameter will always throw if
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(220)">../include/libtorrent/tracker_manager.hpp:384</a></td><td>this should be unique_ptr in the future</td></tr><tr id="220" style="display: none;" colspan="3"><td colspan="3"><h2>this should be unique_ptr in the future</h2><h4>../include/libtorrent/tracker_manager.hpp:384</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// this is only used for SOCKS packets, since
		// they may be addressed to hostname
		virtual bool incoming_packet(error_code const&amp; e, char const* hostname
			, char const* buf, int size);
		
		void update_transaction_id(
			boost::shared_ptr&lt;udp_tracker_connection&gt; c
			, boost::uint64_t tid);

		aux::session_settings const&amp; settings() const { return m_settings; }
		udp_socket&amp; get_udp_socket() { return m_udp_socket; }
		struct ip_filter const&amp; ip_filter() const { return m_ip_filter; }
		resolver_interface&amp; host_resolver() { return m_host_resolver; }

	private:

		typedef mutex mutex_t;
		mutable mutex_t m_mutex;

		// maps transactionid to the udp_tracker_connection
<div style="background: #ffff00" width="100%">		typedef boost::unordered_map&lt;boost::uint32_t
</div>			, boost::shared_ptr&lt;udp_tracker_connection&gt; &gt; udp_conns_t;
		udp_conns_t m_udp_conns;

		typedef std::vector&lt;boost::shared_ptr&lt;http_tracker_connection&gt; &gt; http_conns_t;
		http_conns_t m_http_conns;

		struct ip_filter const&amp; m_ip_filter;
		class udp_socket&amp; m_udp_socket;
		resolver_interface&amp; m_host_resolver;
		aux::session_settings const&amp; m_settings;
		counters&amp; m_stats_counters;
#if !defined TORRENT_DISABLE_LOGGING || TORRENT_USE_ASSERTS
		aux::session_logger&amp; m_ses;
#endif

		bool m_abort;
	};
}

#endif // TORRENT_TRACKER_MANAGER_HPP_INCLUDED

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(221)">../include/libtorrent/upnp.hpp:108</a></td><td>support using the windows API for UPnP operations as well</td></tr><tr id="221" style="display: none;" colspan="3"><td colspan="3"><h2>support using the windows API for UPnP operations as well</h2><h4>../include/libtorrent/upnp.hpp:108</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			external_port_must_be_wildcard = 727
		};

		// hidden
		TORRENT_EXPORT boost::system::error_code make_error_code(error_code_enum e);
	}

	// the boost.system error category for UPnP errors
	TORRENT_EXPORT boost::system::error_category&amp; get_upnp_category();

// int: port-mapping index
// address: external address as queried from router
// int: external port
// std::string: error message
// an empty string as error means success
// a port-mapping index of -1 means it's
// an informational log message
typedef boost::function&lt;void(int, address, int, error_code const&amp;)&gt; portmap_callback_t;
typedef boost::function&lt;void(char const*)&gt; log_callback_t;

<div style="background: #ffff00" width="100%">class TORRENT_EXTRA_EXPORT upnp : public boost::enable_shared_from_this&lt;upnp&gt;
</div>{
public:
	upnp(io_service&amp; ios
		, address const&amp; listen_interface, std::string const&amp; user_agent
		, portmap_callback_t const&amp; cb, log_callback_t const&amp; lcb
		, bool ignore_nonrouters);
	~upnp();

	void start(void* state = 0);

	void* drain_state();

	enum protocol_type { none = 0, udp = 1, tcp = 2 };

	// Attempts to add a port mapping for the specified protocol. Valid protocols are
	// ``upnp::tcp`` and ``upnp::udp`` for the UPnP class and ``natpmp::tcp`` and
	// ``natpmp::udp`` for the NAT-PMP class.
	// 
	// ``external_port`` is the port on the external address that will be mapped. This
	// is a hint, you are not guaranteed that this port will be available, and it may
	// end up being something else. In the portmap_alert_ notification, the actual
	// external port is reported.
	// 
	// ``local_port`` is the port in the local machine that the mapping should forward
	// to.
	// 
	// The return value is an index that identifies this port mapping. This is used
	// to refer to mappings that fails or succeeds in the portmap_error_alert_ and
	// portmap_alert_ respectively. If The mapping fails immediately, the return value
	// is -1, which means failure. There will not be any error alert notification for
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(222)">../include/libtorrent/utp_stream.hpp:402</a></td><td>implement blocking write. Low priority since it's not used (yet)</td></tr><tr id="222" style="display: none;" colspan="3"><td colspan="3"><h2>implement blocking write. Low priority since it's not used (yet)</h2><h4>../include/libtorrent/utp_stream.hpp:402</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		for (typename Mutable_Buffers::const_iterator i = buffers.begin()
			, end(buffers.end()); i != end; ++i)
		{
			using asio::buffer_cast;
			using asio::buffer_size;
			add_read_buffer(buffer_cast&lt;void*&gt;(*i), buffer_size(*i));
#if TORRENT_USE_ASSERTS
			buf_size += buffer_size(*i);
#endif
		}
		std::size_t ret = read_some(true);
		TORRENT_ASSERT(ret &lt;= buf_size);
		TORRENT_ASSERT(ret &gt; 0);
		return ret;
	}

	template &lt;class Const_Buffers&gt;
	std::size_t write_some(Const_Buffers const&amp; /* buffers */, error_code&amp; /* ec */)
	{
		TORRENT_ASSERT(false &amp;&amp; "not implemented!");
<div style="background: #ffff00" width="100%">		return 0;
</div>	}

#ifndef BOOST_NO_EXCEPTIONS
	template &lt;class Mutable_Buffers&gt;
	std::size_t read_some(Mutable_Buffers const&amp; buffers)
	{
		error_code ec;
		std::size_t ret = read_some(buffers, ec);
		if (ec)
			boost::throw_exception(boost::system::system_error(ec));
		return ret;
	}

	template &lt;class Const_Buffers&gt;
	std::size_t write_some(Const_Buffers const&amp; buffers)
	{
		error_code ec;
		std::size_t ret = write_some(buffers, ec);
		if (ec)
			boost::throw_exception(boost::system::system_error(ec));
		return ret;
	}
#endif

	template &lt;class Const_Buffers, class Handler&gt;
	void async_write_some(Const_Buffers const&amp; buffers, Handler const&amp; handler)
	{
		if (m_impl == 0)
		{
			m_io_service.post(boost::bind&lt;void&gt;(handler
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(223)">../include/libtorrent/kademlia/item.hpp:61</a></td><td>since this is a public function, it should probably be moved out of this header and into one with other public functions.</td></tr><tr id="223" style="display: none;" colspan="3"><td colspan="3"><h2>since this is a public function, it should probably be moved
out of this header and into one with other public functions.</h2><h4>../include/libtorrent/kademlia/item.hpp:61</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include &lt;boost/array.hpp&gt;

namespace libtorrent { namespace dht
{

// calculate the target hash for an immutable item.
sha1_hash TORRENT_EXTRA_EXPORT item_target_id(
	std::pair&lt;char const*, int&gt; v);

// calculate the target hash for a mutable item.
sha1_hash TORRENT_EXTRA_EXPORT item_target_id(std::pair&lt;char const*, int&gt; salt
	, char const* pk);

bool TORRENT_EXTRA_EXPORT verify_mutable_item(
	std::pair&lt;char const*, int&gt; v
	, std::pair&lt;char const*, int&gt; salt
	, boost::uint64_t seq
	, char const* pk
	, char const* sig);

<div style="background: #ffff00" width="100%">
</div>// given a byte range ``v`` and an optional byte range ``salt``, a
// sequence number, public key ``pk`` (must be 32 bytes) and a secret key
// ``sk`` (must be 64 bytes), this function produces a signature which
// is written into a 64 byte buffer pointed to by ``sig``. The caller
// is responsible for allocating the destination buffer that's passed in
// as the ``sig`` argument. Typically it would be allocated on the stack.
void TORRENT_EXPORT sign_mutable_item(
	std::pair&lt;char const*, int&gt; v
	, std::pair&lt;char const*, int&gt; salt
	, boost::uint64_t seq
	, char const* pk
	, char const* sk
	, char* sig);

enum
{
	item_pk_len = 32,
	item_sk_len = 64,
	item_sig_len = 64
};

class TORRENT_EXTRA_EXPORT item
{
public:
	item() : m_seq(0), m_mutable(false)  {}
	item(char const* pk, std::string const&amp; salt);
	item(entry const&amp; v) { assign(v); }
	item(entry const&amp; v
		, std::pair&lt;char const*, int&gt; salt
		, boost::uint64_t seq, char const* pk, char const* sk);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(224)">../include/libtorrent/aux_/session_impl.hpp:849</a></td><td>should this be renamed m_outgoing_interfaces?</td></tr><tr id="224" style="display: none;" colspan="3"><td colspan="3"><h2>should this be renamed m_outgoing_interfaces?</h2><h4>../include/libtorrent/aux_/session_impl.hpp:849</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// listen socket. For each retry the port number
			// is incremented by one
			int m_listen_port_retries;

			// the addresses or device names of the interfaces we are supposed to
			// listen on. if empty, it means that we should let the os decide
			// which interface to listen on
			std::vector&lt;std::pair&lt;std::string, int&gt; &gt; m_listen_interfaces;

			// keep this around until everything uses the list of interfaces
			// instead.
			tcp::endpoint m_listen_interface;

			// the network interfaces outgoing connections are opened through. If
			// there is more then one, they are used in a round-robin fasion
			// each element is a device name or IP address (in string form) and
			// a port number. The port determins which port to bind the listen
			// socket to, and the device or IP determines which network adapter
			// to be used. If no adapter with the specified name exists, the listen
			// socket fails.
<div style="background: #ffff00" width="100%">			std::vector&lt;std::string&gt; m_net_interfaces;
</div>
			// if we're listening on an IPv6 interface
			// this is one of the non local IPv6 interfaces
			// on this machine
			tcp::endpoint m_ipv6_interface;
			tcp::endpoint m_ipv4_interface;
			
			// since we might be listening on multiple interfaces
			// we might need more than one listen socket
			std::list&lt;listen_socket_t&gt; m_listen_sockets;

#if TORRENT_USE_I2P
			i2p_connection m_i2p_conn;
			boost::shared_ptr&lt;socket_type&gt; m_i2p_listen_socket;
#endif

#ifdef TORRENT_USE_OPENSSL
			boost::asio::ssl::context* ssl_ctx() { return &amp;m_ssl_ctx; } 
			void on_incoming_utp_ssl(boost::shared_ptr&lt;socket_type&gt; const&amp; s);
			void ssl_handshake(error_code const&amp; ec, boost::shared_ptr&lt;socket_type&gt; s);
#endif

			// when as a socks proxy is used for peers, also
			// listen for incoming connections on a socks connection
			boost::shared_ptr&lt;socket_type&gt; m_socks_listen_socket;
			boost::uint16_t m_socks_listen_port;

			// round-robin index into m_net_interfaces
			mutable boost::uint8_t m_interface_index;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(225)">../include/libtorrent/aux_/session_impl.hpp:900</a></td><td>replace this by a proper asio timer</td></tr><tr id="225" style="display: none;" colspan="3"><td colspan="3"><h2>replace this by a proper asio timer</h2><h4>../include/libtorrent/aux_/session_impl.hpp:900</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
			void open_new_incoming_socks_connection();

			enum listen_on_flags_t
			{
				open_ssl_socket = 0x10
			};

			listen_socket_t setup_listener(std::string const&amp; device
				, bool ipv4, int port, int&amp; retries, int flags, error_code&amp; ec);

#ifndef TORRENT_DISABLE_DHT	
			entry m_dht_state;
#endif

			// this is initialized to the unchoke_interval
			// session_setting and decreased every second.
			// when it reaches zero, it is reset to the
			// unchoke_interval and the unchoke set is
			// recomputed.
<div style="background: #ffff00" width="100%">			int m_unchoke_time_scaler;
</div>
			// this is used to decide when to recalculate which
			// torrents to keep queued and which to activate
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(226)">../include/libtorrent/aux_/session_impl.hpp:905</a></td><td>replace this by a proper asio timer</td></tr><tr id="226" style="display: none;" colspan="3"><td colspan="3"><h2>replace this by a proper asio timer</h2><h4>../include/libtorrent/aux_/session_impl.hpp:905</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			{
				open_ssl_socket = 0x10
			};

			listen_socket_t setup_listener(std::string const&amp; device
				, bool ipv4, int port, int&amp; retries, int flags, error_code&amp; ec);

#ifndef TORRENT_DISABLE_DHT	
			entry m_dht_state;
#endif

			// this is initialized to the unchoke_interval
			// session_setting and decreased every second.
			// when it reaches zero, it is reset to the
			// unchoke_interval and the unchoke set is
			// recomputed.
			int m_unchoke_time_scaler;

			// this is used to decide when to recalculate which
			// torrents to keep queued and which to activate
<div style="background: #ffff00" width="100%">			int m_auto_manage_time_scaler;
</div>
			// works like unchoke_time_scaler but it
			// is only decresed when the unchoke set
			// is recomputed, and when it reaches zero,
			// the optimistic unchoke is moved to another peer.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(227)">../include/libtorrent/aux_/session_impl.hpp:912</a></td><td>replace this by a proper asio timer</td></tr><tr id="227" style="display: none;" colspan="3"><td colspan="3"><h2>replace this by a proper asio timer</h2><h4>../include/libtorrent/aux_/session_impl.hpp:912</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
#ifndef TORRENT_DISABLE_DHT	
			entry m_dht_state;
#endif

			// this is initialized to the unchoke_interval
			// session_setting and decreased every second.
			// when it reaches zero, it is reset to the
			// unchoke_interval and the unchoke set is
			// recomputed.
			int m_unchoke_time_scaler;

			// this is used to decide when to recalculate which
			// torrents to keep queued and which to activate
			int m_auto_manage_time_scaler;

			// works like unchoke_time_scaler but it
			// is only decresed when the unchoke set
			// is recomputed, and when it reaches zero,
			// the optimistic unchoke is moved to another peer.
<div style="background: #ffff00" width="100%">			int m_optimistic_unchoke_time_scaler;
</div>
			// works like unchoke_time_scaler. Each time
			// it reaches 0, and all the connections are
			// used, the worst connection will be disconnected
			// from the torrent with the most peers
			int m_disconnect_time_scaler;

			// when this scaler reaches zero, it will
			// scrape one of the auto managed, paused,
			// torrents.
			int m_auto_scrape_time_scaler;

			// the index of the torrent that we'll
			// refresh the next time
			int m_next_explicit_cache_torrent;

			// this is a counter of the number of seconds until
			// the next time the read cache is rotated, if we're
			// using an explicit read read cache.
			int m_cache_rotation_timer;

			// the index of the torrent that we'll
			// refresh the next time
			int m_next_suggest_torrent;

			// this is a counter of the number of seconds until
			// the next time the suggest pieces are refreshed
			int m_suggest_timer;

			// statistics gathered from all torrents.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(228)">../include/libtorrent/aux_/session_interface.hpp:250</a></td><td>it would be nice to not have this be part of session_interface</td></tr><tr id="228" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to not have this be part of session_interface</h2><h4>../include/libtorrent/aux_/session_interface.hpp:250</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// load the specified torrent. also evict one torrent, except
		// for the one specified, if we are at the limit of loaded torrents
		virtual bool load_torrent(torrent* t) = 0;

		// bump the specified torrent to make it the most recently used one
		// in the torrent LRU (i.e. the least likely to get unloaded)
		virtual void bump_torrent(torrent* t, bool back = true) = 0;

		// ask for which interface and port to bind outgoing peer connections on
		virtual tcp::endpoint bind_outgoing_socket(socket_type&amp; s, address const&amp;
			remote_address, error_code&amp; ec) const = 0;
		virtual bool verify_bound_address(address const&amp; addr, bool utp
			, error_code&amp; ec) = 0;

#ifndef TORRENT_DISABLE_MUTABLE_TORRENTS
		virtual std::vector&lt;boost::shared_ptr&lt;torrent&gt; &gt; find_collection(
			std::string const&amp; collection) const = 0;
#endif

<div style="background: #ffff00" width="100%">		virtual proxy_settings proxy() const = 0;
</div>
#if TORRENT_USE_I2P
		virtual proxy_settings i2p_proxy() const = 0;
		virtual char const* i2p_session() const = 0;
#endif

		virtual void prioritize_connections(boost::weak_ptr&lt;torrent&gt; t) = 0;

		virtual tcp::endpoint get_ipv6_interface() const = 0;
		virtual tcp::endpoint get_ipv4_interface() const = 0;

		virtual void trigger_auto_manage() = 0;

		virtual void apply_settings_pack(settings_pack* pack) = 0;
		virtual session_settings const&amp; settings() const = 0;

		virtual void queue_tracker_request(tracker_request&amp; req
			, boost::weak_ptr&lt;request_callback&gt; c) = 0;

		// peer-classes
		virtual void set_peer_classes(peer_class_set* s, address const&amp; a, int st) = 0;
		virtual peer_class_pool const&amp; peer_classes() const = 0;
		virtual peer_class_pool&amp; peer_classes() = 0;
		virtual bool ignore_unchoke_slots_set(peer_class_set const&amp; set) const = 0;
		virtual int copy_pertinent_channels(peer_class_set const&amp; set
			, int channel, bandwidth_channel** dst, int max) = 0;
		virtual int use_quota_overhead(peer_class_set&amp; set, int amount_down, int amount_up) = 0;

		virtual bandwidth_manager* get_bandwidth_manager(int channel) = 0;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(229)">../include/libtorrent/aux_/session_settings.hpp:78</a></td><td>make this a bitfield</td></tr><tr id="229" style="display: none;" colspan="3"><td colspan="3"><h2>make this a bitfield</h2><h4>../include/libtorrent/aux_/session_settings.hpp:78</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	if ((name &amp; settings_pack::type_mask) != settings_pack:: type ## _type_base) return default_val; \
	return m_ ## type ## s[name - settings_pack:: type ## _type_base]

	struct TORRENT_EXTRA_EXPORT session_settings
	{
		friend void libtorrent::save_settings_to_dict(
			aux::session_settings const&amp; s, entry::dictionary_type&amp; sett);

		void set_str(int name, std::string const&amp; value) { SET(string); }
		std::string const&amp; get_str(int name) const { GET(string, m_strings[0]); }
		void set_int(int name, int value) { SET(int); }
		int get_int(int name) const { GET(int, 0); }
		void set_bool(int name, bool value) { SET(bool); }
		bool get_bool(int name) const { GET(bool, false); }

		session_settings();

	private:
		std::string m_strings[settings_pack::num_string_settings];
		int m_ints[settings_pack::num_int_settings];
<div style="background: #ffff00" width="100%">		bool m_bools[settings_pack::num_bool_settings];
</div>	};

#undef GET
#undef SET

} }

#endif

</pre></td></tr></table></body></html>